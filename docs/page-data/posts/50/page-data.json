{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/50","result":{"data":{"esaPost":{"number":50,"relative_category":"blog/health","fields":{"title":"30代からの胸郭変形（漏斗胸）手術","excerpt":"> PROBLEMPROBLEM \n\n- 重度の胸郭変形（漏斗胸）をかかえているため内臓への負荷がもとよりある。ヘイラーインデックス（後述）が健常者の3倍。\n- 30代を超えたあたりから肋軟骨が硬化してきたため心臓、肺を圧迫するようになった。   > TLDRTLDR \n\n漏斗胸患者の状況を医師から聞いたのだが、その話を考慮すると、1万人くらいは似たような課題をかかえる人がいるのではと思っている。本記事はあくまで患者の備忘なので、医療的な内容は 専門医に聞くといい。 \n\n漏斗胸患者の状況 \n\n- ナス法は2000年代に入ってから徐々に一般に知られるようなった\n- ナス法は10代のうちに受けるのが体力的・経済的にも適切\n- 日本人1000-300人に1人が漏斗胸患者の可能性がある\n- 漏斗胸患者の8-9割は男性である   > SOLUTIONSOLUTION \n\nそんなわけで、今まで放置していた胸郭を矯正する手術（ナス法）を先日おこなった。まだ経過観察中だが、様態も安定してきたので、備忘のために今までおこなった対策を記す。30代でこの手術をする人の情報があまりなかったので試行錯誤ではある。 \n\n私の記憶がたしかなら、ナス法は2000年代に入ってから徐々に一般に知られるようなり、今では美容目的の手術としてもあつかわれている。それまでの胸郭変形の手術は、胸を切開して骨を切りとりその骨を表裏反転させるなど大掛かりなものだった。 \n\nその内容は歯の矯正と原理はおなじで矯正器具を患部周辺にとりつけて時間をかけて適正に形を整えていくというもの。ただし、矯正器具を骨の内側にとりつけるため、歯の強制よりも時間と痛みを多くともなうものである。 \n\n- 治療期間でみると、歯の矯正が4-6か月、胸の矯正が2-3年かかる。\n- 痛みの度合いでみると、強度の医療麻薬・鎮痛剤にお世話になる期間が歯の矯正では7日ほど、胸の矯正では40日ほど。また、鎮痛剤が不要になっても、施術部位の皮膚組成が治るまで、前者は2週間ほど噛むことが制限され、後者は90日ほど運動（胸郭をつかう運動のこと：例えば、満員電車への乗車、タクシー乗車、ジョギング、サイクリングなど）が制限される。\n- 治療リスクは、歯の矯正が口内炎、歯髄炎である一方、胸の矯正が心臓の損傷、無気肺、肺水腫など。 \n\nさて、費用とタスク、そして手術後みえてきた課題（リハビリ）を以下に記す。   > 費用費用 \n\nまずは費用。手術・入院費用は健康保険適用で10万ほど。これは入院保険に加入していれば気にする必要はない。 \n\nただ、日常生活を送れるようになるまで4-6か月を有するので、収入分の金額を念頭にいれる必要がある。   > タスク、退院までの工程タスク、退院までの工程 \n\n次にタスク。下記5段階を順にみていく。調べてはじめて退院まで早くて6か月はみておいた方がいい。 \n\n1. ヘイラーインデックスを測る\n2. 入院保険にはいる\n3. 診察をうける、手術の打診\n4. 手術、入院\n5. 退院   > 1. ヘイラーインデックスを測る1. ヘイラーインデックスを測る \n\n自分が診察にいった際は知らなかったが、重度かどうかの判断はヘイラーインデックス（インデックス）を測ればいい。下記の式でインデックスを算出する。本来であればCTで詳細をみて導き出すものだが、それほど複雑ではないのでまずは診察に行くかの判断材料として概算をだすといい。 \n\nヘイラーインデックス = 肋骨の内側の距離 / 胸骨と背骨の距離  \n\nインデックスは通常は2.5ポイントぐらいでその値から離れるほど重症となる。重度の場合はさっと診察して、手術かどうかの判断を求められることがあるので準備に越したことはない。  \n\n参考までにWikipediaに掲載されているヘイラーインデックス算出画像をみる。画像で出されたインデックスは3.59ポイント (25.1cm / 7.0cm)で、心臓が圧迫されている様子が見て取れる。 \n\nちなみに私は8.7～9.0ポイントで、第4胸骨（第6-7肋軟骨）と背骨の距離が通常の4分1ほど（3 cm）の状態、肺と心臓が押しつぶされていた。 \n\n個人的実感だが、胸郭変形は整形上の問題もあるが、年齢をかさねるにつれて硬化する肋軟骨にある。変形した骨が内臓への負荷をじょじょに増進し、気づいたら循環器系の機能低下、それにともなう免疫力低下につながる可能性がある。医師によると漏斗胸の患者には肺炎・心臓病が多く見られるが、その関係解明はこれからの課題だそうだ。   > 2. 入院保険にはいる2. 入院保険にはいる \n\n入院保険について、すでに入っているなら必要ない。胸郭変形の手術は健康保険適用なので通常の民間保険であれば同様に適用されるはず。私はネットで安いところ、期間縛りでトータル20万（月2千）くらいの保険商品を購入した。 \n\nまた、術後の合併症などで想定外に入院・手術費がかさむ可能性があるので、手術が確定したら市区町村の高額医療費制度を利用するといい。   > 3. 診察をうける、手術の打診3. 診察をうける、手術の打診 \n\nまだ、町のクリニックと形成外科との連携がとられるほどナス法手術が業界に浸透してないため、かかりつけの医師より紹介状をもらえる可能性は低い。従って、ネットで執刀数や論文提出数など勘案して信頼できる医師を選定する。ナス法が受けられる医療施設はこちら。外科には自分の体調不良とその原因を棚卸するため、診察してもらいに来たとでも言うと伝わるだろう。 \n\n診察ではX線、CTをとって、ヘイラーインデックスの状態と患部の状態をくらべて施術判断がされる。初回ではCT、X線のみ。2回目にあらためて専任の医師より判断される。医師の判断は一瞬で、施術リスクの重説と施術有無の打診がされ、スケジュール調整となる。   > 4. 入院、手術4. 入院、手術 \n\n手術を受けるようになっても入院までは普段と変わらない生活が送れる。それ以降は入院関連の慣習、業務フローを知らないと生活上でいろいろと不都合が生じる。 \n\n入院初日。入院手続きで連帯保証人が複数人必要と何人かの事務方にいわれる。ただ、この情報は、患者が死亡した際の身柄引き取り先や医療費滞納が起きることを想定して病院が事前に知りたいだけで、法的にグレーな慣習である。マストではないので情報提供を断っても強く追及してこない。 \n\n手術前日。貴重品を持てない、荷物を持てないという制約がかかる。警備体制が整ってていない病院は防犯がよわいのであえて金庫をおかない、貴重品をあずからない。手術時患者は貴重品をもつことができないので、実質貴重品なしで入院することになる。しかし、手ぶらでは入院手続きできないので1人身で入院するには工夫が必要である。 \n\n術後。突然ICUで目が覚める、6本カテーテルが体に刺さっていて医療麻薬・鎮痛剤投与のルーチンがはじまる。ICUから通常病棟への移管は受け入れ態勢によって変動する。術前に麻酔をうたれる辺りまでは記憶にあるが、それ以降のことはまったく覚えていないので混乱する時期である。 \n\n病棟移管後。ネット利用禁止。こちらはは昔からの慣習で建前上禁止になっているにすぎず、スマホの普及とともに黙認、あるいは容認するようになっている。ただ、手術前日の荷物をもてないという制約があることと、術後2週間は動くのがままならない状態なので1人身で入院すると外界と接続ができなくなる。   > 閑話休題 入院時の様子閑話休題 入院時の様子 \n\nここでちょうど入院時の様子がTwitterに残っていたので、抜粋する。入院直後、手術前、手術後、退院間近の心境の変化がみてとれる。 \n\n入院直後 \n\n手術がおもったよりも大変そうと気づく。 \n\nnabinno, 02:26 PM October 01, 2016: かるい手術と思ったらICUに入ることになってる // from Twitter for Android [Tokyo, JP]  \n\n手術前 \n\n手術まで暇なのでPowerShellをいじりはじめる。 \n\nnabinno, 05:41 PM October 01, 2016: Hum > $($(curl http://www.yahoo.co.jp).Images | foreach {$_.src}) ` | sort ` | uniq ` | foreach { ` curl -Uri $_ -OutFile \"$(pwd)\\$(basename $_)\" ` } // from Twitter Web Client [Tokyo, JP]  \n\n手術後 \n\n麻酔の痛みがきれてナーバスになる。 \n\nnabinno, 04:06 PM October 08, 2016: ナースコールは enqueue/dequue もされてるがワーカーがかなりの頻度 でこける。夜になると汚いログがはかれるのは #医療OS の仕様だろうか ... // from Twitter for Android [Tokyo, JP]  \n\n気持ちを落ち着かせるためにEmacsをさわる。 \n\nnabinno, 09:01 PM October 11, 2016: 可能なかぎり Emacs で #Xamarin さわりたいので、CentOS 上に samba 立てた。 https://t.co/XXCds2pwtx // from Twitter Web Client [Tokyo, JP]  \n\nBashOnWindowsで無茶をやる。少し落ち着く。 \n\nnabinno, 09:18 PM October 11, 2016: #BashOnWindows の Emacs から #Xamarin さわったら 関連ファイルが消 されたり権限が変更されたりしたのだった ... // from twmode [Tokyo, JP]  \n\n術後ずっと寝たきりだったが、なんとか動けるようになってきた。 \n\nnabinno, 06:50 AM October 18, 2016: 胸郭手術時の 🛏 起床と就寝をマスターした https://t.co/ipIU4LPlBq // from Twitter Web Client [Tokyo, JP]  \n\n激痛のためノートPCがもてない体になっていた。 \n\nnabinno, 08:35 PM October 20, 2016: ノート PC は肉体的にまだ持てない ... // from twmode [Tokyo, JP]  \n\n退院間近 \n\nアクティブトラッカーで客観的にみるよう心がけ始める。 \n\nnabinno, 05:22 PM October 21, 2016: #MicrosoftBand #HealthVault #MyFitnessPal で記録つけていて、ふと 医療機器がからだに入ってることにきづいた。他人事じゃないいんだけ ど、おもしろいなあ。 // from twmode [Tokyo, JP]    > 5. 退院5. 退院 \n\n退院は主治医が判断する、病棟の見回り医師ではない。そして、たいてい腕のたつ主治医は多忙なので1週間に1度しか顔を出さない。その時の様態次第で退院がどんどん後ろにずれていくので注意が必要だ。 \n\n退院の条件 \n\n- 肺の状態、肺の膨らみ\n- 歩行の有無\n- 起床の有無\n- 退院したいという意志 \n\n入院中は上記の条件をクリアできるようこころがけること。無為に過ごすと退院が遅れる。   > 手術後のリハビリ手術後のリハビリ   > 1か月後 ひたすら静養1か月後 ひたすら静養 \n\n退院直後の時期は風邪をひくと肺炎になる可能性が高まるので、2点注意する。 \n\nまずは内科。退院前に外科から出される鎮痛剤が強力なので薬の組み合わせには注意する。特に内科で出される風邪薬自体にも鎮痛剤が入っており、同時に飲むと神経系に支障をきたすことがある。内科医には、咳をしたら胸に激痛が走るため鎮痛剤を利用している旨をつたえ、抗生剤、鎮咳剤、去痰剤の薬を処方してもらうようにする。 \n\nまた、肺炎の気がありX線検査する場合、内科医にバーが邪魔をして検査がむずかしい状況にあることを共有する。内科医によっては、外科医が処方・処置した鎮痛剤とバーが自分の仕事を邪魔していると考える人もいる。 \n\n次に、免疫力。できるだけ免疫力が高まるように工夫する。 \n\n食事。MyFitnessPal（Under Armour）のような栄養を主としたアクティビティトラッカーで不足栄養を観察し、まずは機能食品などで不足栄養を補う。私は皮膚の組成に関係しそうなマルチビタミン、ビタミンC、タンパク質を積極的にとった（ている）。余裕が出てきたらスーパー食材、外食チェーンHPの栄養表をみて、実際に食事し体調を観察する。体調はWithing BodyとMS Bandでトラックすると管理が楽だ。 \n\n運動。運動はウォーキング程度に控えるよう医師から注意される。従って、この期間はスクワットなど胸郭や脇の傷周囲の皮膚組織に動きつけない運動で落ちた筋力を回復させる程度にする。また、無理のないストレッチで胸郭にうめこまれたバー周辺の皮膚を徐々に伸ばす、あたしい皮膚組織をつくるよう心掛ける。室内での自重トレーニングよりもジムのトレーニングマシンで、リハビリという視点で負荷を調整しながら無理なくおこなうといい。実際にトレーニングする前に医師からリハビリスタッフを紹介してもらうのも手だろう。 \n\n3つの運動 \n\n- 有酸素運動。ウォーキングで循環器系をきたえる。退院後でも起床など胸郭をうごかすのがむずかしい状態なので、まずウォーキングが普通にできるようにのぞむ。慣れてきたら距離をのばして5km、10kmとのばすといいだろう。足の負担を気にするようだったらAsics DynaFlyteのような、機能性を追求したランニングシューズの検討をすすめる。\n- 無酸素運動。無理のない筋トレで筋骨格をきたえる、皮膚を生成する。退院直後は腹筋、三角筋はバー周囲の皮膚が生成されていないので痛みとともに力を出すことがむずかしい。僧帽筋、大胸筋あたりから皮膚の生成を促すようにする。また、有酸素運動を無理なく行えるように下腿三頭筋（ふくろはぎ）や大腿四頭筋を積極的に動かす。余裕が出てきたら筋肉とトレーニングマシンの対応表を参考にするといい。\n- ストレッチ。ヨガで皮膚の生成を促す。退院直後はヨガをする余裕はないが、軽いウォーキングや筋トレをはじめたあたりで、バウンドエンジェル、チャイルドポーズ、ハッピーベイビーポーズなど軽めなものを混ぜるといい。参考までにポーズ集がある。 \n\nまた、入院時に手術用コンプレッションウェアのタイツを着ていたが、退院後はスポーツ用コンプレッションウェアをシャツ、タイツともに着るといい。適度な負荷が皮膚に与えられるとともに、交感神経の活性化につながる。 \n\n私はできなかったが、免疫力向上は準備するのに時間がかかるので入院・手術前から取り組んでおくといいだろう。   > 3か月後どうなったか3か月後どうなったか \n\n下記にリハビリの経過を示すため体組成の一部を記す。    体組成 入院前 退院後1か月 退院後2か月 退院後3か月     胸囲 (cm) 68.5 80.8 82.7 82.9   体重 (kg) 51.0 46.6 49.6 50.8   筋肉 (kg) - 39.3 41.4 42.4   脂肪 (kg) - 4.9 5.8 5.9    \n\n退院後1か月目は胸囲が劇的に変わった一方で、体重が低下している。ノートパソコンを持てないほどだったので筋力も同様に低下しているものと推測される。退院後2か月目はリハビリを始めた効果が順当に出てどの体組成値も回復している。そして、3か月目あたりで本来の値にもどっている様子がうかがえる。 \n\n3か月目以降はほぼ手術前、あるいはそれ以上の生活の質を担保できるので、バーを抜く最終手術の3年後を見越して無理なくリハビリをつづけるといいと考えている。","thumbnail":"https://upload.wikimedia.org/wikipedia/commons/3/33/Haller_index_PE.jpg"},"wip":false,"body_md":"# PROBLEM\r\n- 重度の胸郭変形（漏斗胸）をかかえているため内臓への負荷がもとよりある。ヘイラーインデックス（後述）が健常者の3倍。\r\n- 30代を超えたあたりから肋軟骨が硬化してきたため心臓、肺を圧迫するようになった。\r\n\r\n# TLDR\r\n漏斗胸患者の状況を医師から聞いたのだが、その話を考慮すると、1万人くらいは似たような課題をかかえる人がいるのではと思っている。本記事はあくまで患者の備忘なので、医療的な内容は [専門医](http://www.mua.co.jp/patients/facilities)に聞くといい。\r\n\r\n**漏斗胸患者の状況**\r\n\r\n- ナス法は**2000年代**に入ってから徐々に一般に知られるようなった\r\n- ナス法は**10代**のうちに受けるのが体力的・経済的にも適切\r\n- 日本人**1000-300人に1人**が漏斗胸患者の可能性がある\r\n- 漏斗胸患者の**8-9割は男性**である\r\n\r\n# SOLUTION\r\nそんなわけで、今まで放置していた胸郭を矯正する手術（[ナス法](http://www.mua.co.jp/patients/nuss)）を先日おこなった。まだ経過観察中だが、様態も安定してきたので、備忘のために今までおこなった対策を記す。30代でこの手術をする人の情報があまりなかったので試行錯誤ではある。\r\n\r\n私の記憶がたしかなら、ナス法は2000年代に入ってから徐々に一般に知られるようなり、今では美容目的の手術としてもあつかわれている。それまでの胸郭変形の手術は、胸を切開して骨を切りとりその骨を表裏反転させるなど大掛かりなものだった。\r\n\r\nその内容は歯の矯正と原理はおなじで矯正器具を患部周辺にとりつけて時間をかけて適正に形を整えていくというもの。ただし、矯正器具を骨の内側にとりつけるため、歯の強制よりも時間と痛みを多くともなうものである。\r\n\r\n- 治療期間でみると、歯の矯正が**4-6か月**、胸の矯正が**2-3年**かかる。\r\n- 痛みの度合いでみると、強度の医療麻薬・鎮痛剤にお世話になる期間が歯の矯正では**7日ほど**、胸の矯正では**40日ほど**。また、鎮痛剤が不要になっても、施術部位の皮膚組成が治るまで、前者は**2週間ほど噛むこと**が制限され、後者は**90日ほど運動**（胸郭をつかう運動のこと：例えば、満員電車への乗車、タクシー乗車、ジョギング、サイクリングなど）が制限される。\r\n- 治療リスクは、歯の矯正が口内炎、歯髄炎である一方、胸の矯正が心臓の損傷、無気肺、肺水腫など。\r\n\r\nさて、費用とタスク、そして手術後みえてきた課題（リハビリ）を以下に記す。\r\n\r\n## 費用\r\n\r\nまずは費用。手術・入院費用は健康保険適用で10万ほど。これは入院保険に加入していれば気にする必要はない。\r\n\r\nただ、日常生活を送れるようになるまで4-6か月を有するので、収入分の金額を念頭にいれる必要がある。\r\n\r\n## タスク、退院までの工程\r\n次にタスク。下記5段階を順にみていく。調べてはじめて退院まで早くて6か月はみておいた方がいい。\r\n\r\n1. ヘイラーインデックスを測る\r\n2. 入院保険にはいる\r\n3. 診察をうける、手術の打診\r\n4. 手術、入院\r\n5. 退院\r\n\r\n### 1. ヘイラーインデックスを測る\r\n自分が診察にいった際は知らなかったが、重度かどうかの判断は[ヘイラーインデックス（インデックス）](https://en.wikipedia.org/wiki/Haller_index)を測ればいい。下記の式でインデックスを算出する。本来であればCTで詳細をみて導き出すものだが、それほど複雑ではないのでまずは診察に行くかの判断材料として概算をだすといい。\r\n\r\n    ヘイラーインデックス = 肋骨の内側の距離 / 胸骨と背骨の距離\r\n\r\nインデックスは通常は2.5ポイントぐらいでその値から離れるほど重症となる。重度の場合はさっと診察して、手術かどうかの判断を求められることがあるので準備に越したことはない。\r\n\r\n<img alt=\"thumbnail\" src=\"https://upload.wikimedia.org/wikipedia/commons/3/33/Haller_index_PE.jpg\" />\r\n\r\n参考までにWikipediaに掲載されているヘイラーインデックス算出画像をみる。画像で出されたインデックスは3.59ポイント (25.1cm / 7.0cm)で、心臓が圧迫されている様子が見て取れる。\r\n\r\nちなみに私は8.7～9.0ポイントで、第4胸骨（第6-7肋軟骨）と背骨の距離が通常の4分1ほど（3 cm）の状態、肺と心臓が押しつぶされていた。\r\n\r\n個人的実感だが、胸郭変形は整形上の問題もあるが、年齢をかさねるにつれて硬化する肋軟骨にある。変形した骨が内臓への負荷をじょじょに増進し、気づいたら循環器系の機能低下、それにともなう免疫力低下につながる可能性がある。医師によると漏斗胸の患者には肺炎・心臓病が多く見られるが、その関係解明はこれからの課題だそうだ。\r\n\r\n### 2. 入院保険にはいる\r\n入院保険について、すでに入っているなら必要ない。胸郭変形の手術は健康保険適用なので通常の民間保険であれば同様に適用されるはず。私はネットで安いところ、期間縛りでトータル20万（月2千）くらいの保険商品を購入した。\r\n\r\nまた、術後の合併症などで想定外に入院・手術費がかさむ可能性があるので、手術が確定したら市区町村の高額医療費制度を利用するといい。\r\n\r\n### 3. 診察をうける、手術の打診\r\nまだ、町のクリニックと形成外科との連携がとられるほどナス法手術が業界に浸透してないため、かかりつけの医師より紹介状をもらえる可能性は低い。従って、ネットで執刀数や論文提出数など勘案して信頼できる医師を選定する。ナス法が受けられる医療施設は[こちら](http://www.mua.co.jp/patients/facilities)。外科には自分の体調不良とその原因を棚卸するため、診察してもらいに来たとでも言うと伝わるだろう。\r\n\r\n診察ではX線、CTをとって、ヘイラーインデックスの状態と患部の状態をくらべて施術判断がされる。初回ではCT、X線のみ。2回目にあらためて専任の医師より判断される。医師の判断は一瞬で、施術リスクの重説と施術有無の打診がされ、スケジュール調整となる。\r\n\r\n### 4. 入院、手術\r\n手術を受けるようになっても入院までは普段と変わらない生活が送れる。それ以降は入院関連の慣習、業務フローを知らないと生活上でいろいろと不都合が生じる。\r\n\r\n**入院初日**。入院手続きで連帯保証人が複数人必要と何人かの事務方にいわれる。ただ、この情報は、患者が死亡した際の身柄引き取り先や医療費滞納が起きることを想定して病院が事前に知りたいだけで、法的にグレーな慣習である。マストではないので情報提供を断っても強く追及してこない。\r\n\r\n**手術前日**。貴重品を持てない、荷物を持てないという制約がかかる。警備体制が整ってていない病院は防犯がよわいのであえて金庫をおかない、貴重品をあずからない。手術時患者は貴重品をもつことができないので、実質貴重品なしで入院することになる。しかし、手ぶらでは入院手続きできないので1人身で入院するには工夫が必要である。\r\n\r\n**術後**。突然ICUで目が覚める、6本カテーテルが体に刺さっていて医療麻薬・鎮痛剤投与のルーチンがはじまる。ICUから通常病棟への移管は受け入れ態勢によって変動する。術前に麻酔をうたれる辺りまでは記憶にあるが、それ以降のことはまったく覚えていないので混乱する時期である。\r\n\r\n**病棟移管後**。ネット利用禁止。こちらはは昔からの慣習で建前上禁止になっているにすぎず、スマホの普及とともに黙認、あるいは容認するようになっている。ただ、手術前日の荷物をもてないという制約があることと、術後2週間は動くのがままならない状態なので1人身で入院すると外界と接続ができなくなる。\r\n\r\n### 閑話休題 入院時の様子\r\nここでちょうど入院時の様子がTwitterに残っていたので、抜粋する。入院直後、手術前、手術後、退院間近の心境の変化がみてとれる。\r\n\r\n**入院直後**\r\n\r\n手術がおもったよりも大変そうと気づく。\r\n\r\n    nabinno,  02:26 PM October 01, 2016:\r\n     かるい手術と思ったらICUに入ることになってる\r\n    // from Twitter for Android [Tokyo, JP]\r\n\r\n**手術前**\r\n\r\n手術まで暇なのでPowerShellをいじりはじめる。\r\n\r\n    nabinno,  05:41 PM October 01, 2016:\r\n     Hum\r\n\r\n     > $($(curl http://www.yahoo.co.jp).Images | foreach {$_.src}) `\r\n         | sort `\r\n         | uniq `\r\n         | foreach { `\r\n           curl -Uri $_ -OutFile \"$(pwd)\\$(basename $_)\" `\r\n         }\r\n    // from Twitter Web Client [Tokyo, JP]\r\n\r\n**手術後**\r\n\r\n麻酔の痛みがきれてナーバスになる。\r\n\r\n    nabinno,  04:06 PM October 08, 2016:\r\n     ナースコールは enqueue/dequue もされてるがワーカーがかなりの頻度\r\n     でこける。夜になると汚いログがはかれるのは #医療OS の仕様だろうか\r\n     ...\r\n    // from Twitter for Android [Tokyo, JP]\r\n\r\n気持ちを落ち着かせるためにEmacsをさわる。\r\n\r\n    nabinno,  09:01 PM October 11, 2016:\r\n     可能なかぎり Emacs で #Xamarin さわりたいので、CentOS 上に samba\r\n     立てた。 https://t.co/XXCds2pwtx\r\n    // from Twitter Web Client [Tokyo, JP]\r\n\r\nBashOnWindowsで無茶をやる。少し落ち着く。\r\n\r\n    nabinno,  09:18 PM October 11, 2016:\r\n     #BashOnWindows の Emacs から #Xamarin さわったら 関連ファイルが消\r\n     されたり権限が変更されたりしたのだった ...\r\n    // from twmode [Tokyo, JP]\r\n\r\n術後ずっと寝たきりだったが、なんとか動けるようになってきた。\r\n\r\n    nabinno,  06:50 AM October 18, 2016:\r\n     胸郭手術時の 🛏 起床と就寝をマスターした https://t.co/ipIU4LPlBq\r\n    // from Twitter Web Client [Tokyo, JP]\r\n\r\n激痛のためノートPCがもてない体になっていた。\r\n\r\n    nabinno,  08:35 PM October 20, 2016:\r\n     ノート PC は肉体的にまだ持てない ...\r\n    // from twmode [Tokyo, JP]\r\n\r\n**退院間近**\r\n\r\nアクティブトラッカーで客観的にみるよう心がけ始める。\r\n\r\n    nabinno,  05:22 PM October 21, 2016:\r\n     #MicrosoftBand #HealthVault #MyFitnessPal で記録つけていて、ふと\r\n     医療機器がからだに入ってることにきづいた。他人事じゃないいんだけ\r\n     ど、おもしろいなあ。\r\n    // from twmode [Tokyo, JP]\r\n\r\n### 5. 退院\r\n退院は主治医が判断する、病棟の見回り医師ではない。そして、たいてい腕のたつ主治医は多忙なので1週間に1度しか顔を出さない。その時の様態次第で退院がどんどん後ろにずれていくので注意が必要だ。\r\n\r\n**退院の条件**\r\n\r\n- 肺の状態、肺の膨らみ\r\n- 歩行の有無\r\n- 起床の有無\r\n- 退院したいという意志\r\n\r\n入院中は上記の条件をクリアできるようこころがけること。無為に過ごすと退院が遅れる。\r\n\r\n## 手術後のリハビリ\r\n\r\n### 1か月後 ひたすら静養\r\n\r\n退院直後の時期は風邪をひくと肺炎になる可能性が高まるので、2点注意する。\r\n\r\n**まずは内科**。退院前に外科から出される鎮痛剤が強力なので薬の組み合わせには注意する。特に内科で出される風邪薬自体にも鎮痛剤が入っており、同時に飲むと神経系に支障をきたすことがある。内科医には、咳をしたら胸に激痛が走るため鎮痛剤を利用している旨をつたえ、抗生剤、鎮咳剤、去痰剤の薬を処方してもらうようにする。\r\n\r\nまた、肺炎の気がありX線検査する場合、内科医にバーが邪魔をして検査がむずかしい状況にあることを共有する。内科医によっては、外科医が処方・処置した鎮痛剤とバーが自分の仕事を邪魔していると考える人もいる。\r\n\r\n**次に、免疫力**。できるだけ免疫力が高まるように工夫する。\r\n\r\n食事。[MyFitnessPal（Under Armour）](https://www.myfitnesspal.com/)のような栄養を主としたアクティビティトラッカーで不足栄養を観察し、まずは機能食品などで不足栄養を補う。私は皮膚の組成に関係しそうなマルチビタミン、ビタミンC、タンパク質を積極的にとった（ている）。余裕が出てきたらスーパー食材、外食チェーンHPの栄養表をみて、実際に食事し体調を観察する。体調は[Withing Body](https://www.withings.com/jp/ja/products/body)と[MS Band](https://www.microsoft.com/microsoft-band/en-us)でトラックすると管理が楽だ。\r\n\r\n運動。運動はウォーキング程度に控えるよう医師から注意される。従って、この期間はスクワットなど胸郭や脇の傷周囲の皮膚組織に動きつけない運動で落ちた筋力を回復させる程度にする。また、無理のないストレッチで胸郭にうめこまれたバー周辺の皮膚を徐々に伸ばす、あたしい皮膚組織をつくるよう心掛ける。室内での自重トレーニングよりもジムのトレーニングマシンで、リハビリという視点で負荷を調整しながら無理なくおこなうといい。実際にトレーニングする前に医師からリハビリスタッフを紹介してもらうのも手だろう。\r\n\r\n**3つの運動**\r\n\r\n- **有酸素運動**。ウォーキングで循環器系をきたえる。退院後でも起床など胸郭をうごかすのがむずかしい状態なので、まずウォーキングが普通にできるようにのぞむ。慣れてきたら距離をのばして5km、10kmとのばすといいだろう。足の負担を気にするようだったら[Asics DynaFlyte](http://www.asics.com/jp/ja-jp/dynaflyte)のような、機能性を追求したランニングシューズの検討をすすめる。\r\n- **無酸素運動**。無理のない筋トレで筋骨格をきたえる、皮膚を生成する。退院直後は腹筋、三角筋はバー周囲の皮膚が生成されていないので痛みとともに力を出すことがむずかしい。僧帽筋、大胸筋あたりから皮膚の生成を促すようにする。また、有酸素運動を無理なく行えるように下腿三頭筋（ふくろはぎ）や大腿四頭筋を積極的に動かす。余裕が出てきたら筋肉とトレーニングマシンの[対応表](https://en.wikipedia.org/wiki/List_of_weight_training_exercises)を参考にするといい。\r\n- **ストレッチ**。ヨガで皮膚の生成を促す。退院直後はヨガをする余裕はないが、軽いウォーキングや筋トレをはじめたあたりで、バウンドエンジェル、チャイルドポーズ、ハッピーベイビーポーズなど軽めなものを混ぜるといい。参考までに[ポーズ集](https://en.wikipedia.org/wiki/List_of_asanas)がある。\r\n\r\nまた、入院時に手術用コンプレッションウェアのタイツを着ていたが、退院後はスポーツ用コンプレッションウェアをシャツ、タイツともに着るといい。適度な負荷が皮膚に与えられるとともに、交感神経の活性化につながる。\r\n\r\n私はできなかったが、免疫力向上は準備するのに時間がかかるので入院・手術前から取り組んでおくといいだろう。\r\n\r\n### 3か月後どうなったか\r\n下記にリハビリの経過を示すため体組成の一部を記す。\r\n\r\n| 体組成    | 入院前 | 退院後1か月 | 退院後2か月 | 退院後3か月 |\r\n|-----------|--------|-------------|-------------|-------------|\r\n| 胸囲 (cm) | 68.5   |        80.8 |        82.7 |        82.9 |\r\n| 体重 (kg) | 51.0   |        46.6 |        49.6 |        50.8 |\r\n| 筋肉 (kg) | -      |        39.3 |        41.4 |        42.4 |\r\n| 脂肪 (kg) | -      |         4.9 |         5.8 |         5.9 |\r\n\r\n退院後1か月目は胸囲が劇的に変わった一方で、体重が低下している。ノートパソコンを持てないほどだったので筋力も同様に低下しているものと推測される。退院後2か月目はリハビリを始めた効果が順当に出てどの体組成値も回復している。そして、3か月目あたりで本来の値にもどっている様子がうかがえる。\r\n\r\n3か月目以降はほぼ手術前、あるいはそれ以上の生活の質を担保できるので、バーを抜く最終手術の3年後を見越して無理なくリハビリをつづけるといいと考えている。\r\n","body_html":"<h1 data-sourcepos=\"1:1-1:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"2:1-4:0\">\n<li data-sourcepos=\"2:1-2:171\">重度の胸郭変形（漏斗胸）をかかえているため内臓への負荷がもとよりある。ヘイラーインデックス（後述）が健常者の3倍。</li>\n<li data-sourcepos=\"3:1-4:0\">30代を超えたあたりから肋軟骨が硬化してきたため心臓、肺を圧迫するようになった。</li>\n</ul>\n<h1 data-sourcepos=\"5:1-5:6\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"TLDR\" name=\"TLDR\" href=\"#TLDR\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"TLDR\"> &gt; TLDR</span></a>TLDR</h1>\n<p data-sourcepos=\"6:1-6:334\">漏斗胸患者の状況を医師から聞いたのだが、その話を考慮すると、1万人くらいは似たような課題をかかえる人がいるのではと思っている。本記事はあくまで患者の備忘なので、医療的な内容は <a href=\"http://www.mua.co.jp/patients/facilities\" target=\"_blank\" rel=\"noopener noreferrer\">専門医</a>に聞くといい。</p>\n<p data-sourcepos=\"8:1-8:28\"><strong>漏斗胸患者の状況</strong></p>\n<ul data-sourcepos=\"10:1-14:0\">\n<li data-sourcepos=\"10:1-10:91\">ナス法は<strong>2000年代</strong>に入ってから徐々に一般に知られるようなった</li>\n<li data-sourcepos=\"11:1-11:83\">ナス法は<strong>10代</strong>のうちに受けるのが体力的・経済的にも適切</li>\n<li data-sourcepos=\"12:1-12:72\">日本人<strong>1000-300人に1人</strong>が漏斗胸患者の可能性がある</li>\n<li data-sourcepos=\"13:1-14:0\">漏斗胸患者の<strong>8-9割は男性</strong>である</li>\n</ul>\n<h1 data-sourcepos=\"15:1-15:10\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"16:1-16:379\">そんなわけで、今まで放置していた胸郭を矯正する手術（<a href=\"http://www.mua.co.jp/patients/nuss\" target=\"_blank\" rel=\"noopener noreferrer\">ナス法</a>）を先日おこなった。まだ経過観察中だが、様態も安定してきたので、備忘のために今までおこなった対策を記す。30代でこの手術をする人の情報があまりなかったので試行錯誤ではある。</p>\n<p data-sourcepos=\"18:1-18:337\">私の記憶がたしかなら、ナス法は2000年代に入ってから徐々に一般に知られるようなり、今では美容目的の手術としてもあつかわれている。それまでの胸郭変形の手術は、胸を切開して骨を切りとりその骨を表裏反転させるなど大掛かりなものだった。</p>\n<p data-sourcepos=\"20:1-20:303\">その内容は歯の矯正と原理はおなじで矯正器具を患部周辺にとりつけて時間をかけて適正に形を整えていくというもの。ただし、矯正器具を骨の内側にとりつけるため、歯の強制よりも時間と痛みを多くともなうものである。</p>\n<ul data-sourcepos=\"22:1-25:0\">\n<li data-sourcepos=\"22:1-22:97\">治療期間でみると、歯の矯正が<strong>4-6か月</strong>、胸の矯正が<strong>2-3年</strong>かかる。</li>\n<li data-sourcepos=\"23:1-23:510\">痛みの度合いでみると、強度の医療麻薬・鎮痛剤にお世話になる期間が歯の矯正では<strong>7日ほど</strong>、胸の矯正では<strong>40日ほど</strong>。また、鎮痛剤が不要になっても、施術部位の皮膚組成が治るまで、前者は<strong>2週間ほど噛むこと</strong>が制限され、後者は<strong>90日ほど運動</strong>（胸郭をつかう運動のこと：例えば、満員電車への乗車、タクシー乗車、ジョギング、サイクリングなど）が制限される。</li>\n<li data-sourcepos=\"24:1-25:0\">治療リスクは、歯の矯正が口内炎、歯髄炎である一方、胸の矯正が心臓の損傷、無気肺、肺水腫など。</li>\n</ul>\n<p data-sourcepos=\"26:1-26:108\">さて、費用とタスク、そして手術後みえてきた課題（リハビリ）を以下に記す。</p>\n<h2 data-sourcepos=\"28:1-28:9\" id=\"3-1-0\" name=\"3-1-0\">\n<a class=\"anchor\" id=\"費用\" name=\"%E8%B2%BB%E7%94%A8\" href=\"#%E8%B2%BB%E7%94%A8\" data-position=\"3-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"費用\"> &gt; 費用</span></a>費用</h2>\n<p data-sourcepos=\"30:1-30:152\">まずは費用。手術・入院費用は健康保険適用で10万ほど。これは入院保険に加入していれば気にする必要はない。</p>\n<p data-sourcepos=\"32:1-32:141\">ただ、日常生活を送れるようになるまで4-6か月を有するので、収入分の金額を念頭にいれる必要がある。</p>\n<h2 data-sourcepos=\"34:1-34:36\" id=\"3-2-0\" name=\"3-2-0\">\n<a class=\"anchor\" id=\"タスク、退院までの工程\" name=\"%E3%82%BF%E3%82%B9%E3%82%AF%E3%80%81%E9%80%80%E9%99%A2%E3%81%BE%E3%81%A7%E3%81%AE%E5%B7%A5%E7%A8%8B\" href=\"#%E3%82%BF%E3%82%B9%E3%82%AF%E3%80%81%E9%80%80%E9%99%A2%E3%81%BE%E3%81%A7%E3%81%AE%E5%B7%A5%E7%A8%8B\" data-position=\"3-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"タスク、退院までの工程\"> &gt; タスク、退院までの工程</span></a>タスク、退院までの工程</h2>\n<p data-sourcepos=\"35:1-35:137\">次にタスク。下記5段階を順にみていく。調べてはじめて退院まで早くて6か月はみておいた方がいい。</p>\n<ol data-sourcepos=\"37:1-42:0\">\n<li data-sourcepos=\"37:1-37:42\">ヘイラーインデックスを測る</li>\n<li data-sourcepos=\"38:1-38:27\">入院保険にはいる</li>\n<li data-sourcepos=\"39:1-39:39\">診察をうける、手術の打診</li>\n<li data-sourcepos=\"40:1-40:18\">手術、入院</li>\n<li data-sourcepos=\"41:1-42:0\">退院</li>\n</ol>\n<h3 data-sourcepos=\"43:1-43:46\" id=\"3-2-1\" name=\"3-2-1\">\n<a class=\"anchor\" id=\"1. ヘイラーインデックスを測る\" name=\"1.%20%E3%83%98%E3%82%A4%E3%83%A9%E3%83%BC%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E6%B8%AC%E3%82%8B\" href=\"#1.%20%E3%83%98%E3%82%A4%E3%83%A9%E3%83%BC%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E6%B8%AC%E3%82%8B\" data-position=\"3-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. ヘイラーインデックスを測る\"> &gt; 1. ヘイラーインデックスを測る</span></a>1. ヘイラーインデックスを測る</h3>\n<p data-sourcepos=\"44:1-44:438\">自分が診察にいった際は知らなかったが、重度かどうかの判断は<a href=\"https://en.wikipedia.org/wiki/Haller_index\" target=\"_blank\" rel=\"noopener noreferrer\">ヘイラーインデックス（インデックス）</a>を測ればいい。下記の式でインデックスを算出する。本来であればCTで詳細をみて導き出すものだが、それほど複雑ではないのでまずは診察に行くかの判断材料として概算をだすといい。</p>\n<div class=\"code-block\" data-sourcepos=\"46:5-47:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>ヘイラーインデックス = 肋骨の内側の距離 / 胸骨と背骨の距離\n</code></pre></div></div>\n<p data-sourcepos=\"48:1-48:249\">インデックスは通常は2.5ポイントぐらいでその値から離れるほど重症となる。重度の場合はさっと診察して、手術かどうかの判断を求められることがあるので準備に越したことはない。</p>\n<a href=\"https://upload.wikimedia.org/wikipedia/commons/3/33/Haller_index_PE.jpg\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"thumbnail\" src=\"https://upload.wikimedia.org/wikipedia/commons/3/33/Haller_index_PE.jpg\"></a>\n<p data-sourcepos=\"52:1-52:240\">参考までにWikipediaに掲載されているヘイラーインデックス算出画像をみる。画像で出されたインデックスは3.59ポイント (25.1cm / 7.0cm)で、心臓が圧迫されている様子が見て取れる。</p>\n<p data-sourcepos=\"54:1-54:184\">ちなみに私は8.7～9.0ポイントで、第4胸骨（第6-7肋軟骨）と背骨の距離が通常の4分1ほど（3 cm）の状態、肺と心臓が押しつぶされていた。</p>\n<p data-sourcepos=\"56:1-56:465\">個人的実感だが、胸郭変形は整形上の問題もあるが、年齢をかさねるにつれて硬化する肋軟骨にある。変形した骨が内臓への負荷をじょじょに増進し、気づいたら循環器系の機能低下、それにともなう免疫力低下につながる可能性がある。医師によると漏斗胸の患者には肺炎・心臓病が多く見られるが、その関係解明はこれからの課題だそうだ。</p>\n<h3 data-sourcepos=\"58:1-58:31\" id=\"3-2-2\" name=\"3-2-2\">\n<a class=\"anchor\" id=\"2. 入院保険にはいる\" name=\"2.%20%E5%85%A5%E9%99%A2%E4%BF%9D%E9%99%BA%E3%81%AB%E3%81%AF%E3%81%84%E3%82%8B\" href=\"#2.%20%E5%85%A5%E9%99%A2%E4%BF%9D%E9%99%BA%E3%81%AB%E3%81%AF%E3%81%84%E3%82%8B\" data-position=\"3-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. 入院保険にはいる\"> &gt; 2. 入院保険にはいる</span></a>2. 入院保険にはいる</h3>\n<p data-sourcepos=\"59:1-59:312\">入院保険について、すでに入っているなら必要ない。胸郭変形の手術は健康保険適用なので通常の民間保険であれば同様に適用されるはず。私はネットで安いところ、期間縛りでトータル20万（月2千）くらいの保険商品を購入した。</p>\n<p data-sourcepos=\"61:1-61:192\">また、術後の合併症などで想定外に入院・手術費がかさむ可能性があるので、手術が確定したら市区町村の高額医療費制度を利用するといい。</p>\n<h3 data-sourcepos=\"63:1-63:43\" id=\"3-2-3\" name=\"3-2-3\">\n<a class=\"anchor\" id=\"3. 診察をうける、手術の打診\" name=\"3.%20%E8%A8%BA%E5%AF%9F%E3%82%92%E3%81%86%E3%81%91%E3%82%8B%E3%80%81%E6%89%8B%E8%A1%93%E3%81%AE%E6%89%93%E8%A8%BA\" href=\"#3.%20%E8%A8%BA%E5%AF%9F%E3%82%92%E3%81%86%E3%81%91%E3%82%8B%E3%80%81%E6%89%8B%E8%A1%93%E3%81%AE%E6%89%93%E8%A8%BA\" data-position=\"3-2-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. 診察をうける、手術の打診\"> &gt; 3. 診察をうける、手術の打診</span></a>3. 診察をうける、手術の打診</h3>\n<p data-sourcepos=\"64:1-64:554\">まだ、町のクリニックと形成外科との連携がとられるほどナス法手術が業界に浸透してないため、かかりつけの医師より紹介状をもらえる可能性は低い。従って、ネットで執刀数や論文提出数など勘案して信頼できる医師を選定する。ナス法が受けられる医療施設は<a href=\"http://www.mua.co.jp/patients/facilities\" target=\"_blank\" rel=\"noopener noreferrer\">こちら</a>。外科には自分の体調不良とその原因を棚卸するため、診察してもらいに来たとでも言うと伝わるだろう。</p>\n<p data-sourcepos=\"66:1-66:355\">診察ではX線、CTをとって、ヘイラーインデックスの状態と患部の状態をくらべて施術判断がされる。初回ではCT、X線のみ。2回目にあらためて専任の医師より判断される。医師の判断は一瞬で、施術リスクの重説と施術有無の打診がされ、スケジュール調整となる。</p>\n<h3 data-sourcepos=\"68:1-68:22\" id=\"3-2-4\" name=\"3-2-4\">\n<a class=\"anchor\" id=\"4. 入院、手術\" name=\"4.%20%E5%85%A5%E9%99%A2%E3%80%81%E6%89%8B%E8%A1%93\" href=\"#4.%20%E5%85%A5%E9%99%A2%E3%80%81%E6%89%8B%E8%A1%93\" data-position=\"3-2-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"4. 入院、手術\"> &gt; 4. 入院、手術</span></a>4. 入院、手術</h3>\n<p data-sourcepos=\"69:1-69:222\">手術を受けるようになっても入院までは普段と変わらない生活が送れる。それ以降は入院関連の慣習、業務フローを知らないと生活上でいろいろと不都合が生じる。</p>\n<p data-sourcepos=\"71:1-71:403\"><strong>入院初日</strong>。入院手続きで連帯保証人が複数人必要と何人かの事務方にいわれる。ただ、この情報は、患者が死亡した際の身柄引き取り先や医療費滞納が起きることを想定して病院が事前に知りたいだけで、法的にグレーな慣習である。マストではないので情報提供を断っても強く追及してこない。</p>\n<p data-sourcepos=\"73:1-73:467\"><strong>手術前日</strong>。貴重品を持てない、荷物を持てないという制約がかかる。警備体制が整ってていない病院は防犯がよわいのであえて金庫をおかない、貴重品をあずからない。手術時患者は貴重品をもつことができないので、実質貴重品なしで入院することになる。しかし、手ぶらでは入院手続きできないので1人身で入院するには工夫が必要である。</p>\n<p data-sourcepos=\"75:1-75:389\"><strong>術後</strong>。突然ICUで目が覚める、6本カテーテルが体に刺さっていて医療麻薬・鎮痛剤投与のルーチンがはじまる。ICUから通常病棟への移管は受け入れ態勢によって変動する。術前に麻酔をうたれる辺りまでは記憶にあるが、それ以降のことはまったく覚えていないので混乱する時期である。</p>\n<p data-sourcepos=\"77:1-77:426\"><strong>病棟移管後</strong>。ネット利用禁止。こちらはは昔からの慣習で建前上禁止になっているにすぎず、スマホの普及とともに黙認、あるいは容認するようになっている。ただ、手術前日の荷物をもてないという制約があることと、術後2週間は動くのがままならない状態なので1人身で入院すると外界と接続ができなくなる。</p>\n<h3 data-sourcepos=\"79:1-79:35\" id=\"3-2-5\" name=\"3-2-5\">\n<a class=\"anchor\" id=\"閑話休題 入院時の様子\" name=\"%E9%96%91%E8%A9%B1%E4%BC%91%E9%A1%8C%20%E5%85%A5%E9%99%A2%E6%99%82%E3%81%AE%E6%A7%98%E5%AD%90\" href=\"#%E9%96%91%E8%A9%B1%E4%BC%91%E9%A1%8C%20%E5%85%A5%E9%99%A2%E6%99%82%E3%81%AE%E6%A7%98%E5%AD%90\" data-position=\"3-2-5\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"閑話休題 入院時の様子\"> &gt; 閑話休題 入院時の様子</span></a>閑話休題 入院時の様子</h3>\n<p data-sourcepos=\"80:1-80:181\">ここでちょうど入院時の様子がTwitterに残っていたので、抜粋する。入院直後、手術前、手術後、退院間近の心境の変化がみてとれる。</p>\n<p data-sourcepos=\"82:1-82:16\"><strong>入院直後</strong></p>\n<p data-sourcepos=\"84:1-84:57\">手術がおもったよりも大変そうと気づく。</p>\n<div class=\"code-block\" data-sourcepos=\"86:5-89:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  02:26 PM October 01, 2016:\n かるい手術と思ったらICUに入ることになってる\n// from Twitter for Android [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"90:1-90:13\"><strong>手術前</strong></p>\n<p data-sourcepos=\"92:1-92:61\">手術まで暇なのでPowerShellをいじりはじめる。</p>\n<div class=\"code-block\" data-sourcepos=\"94:5-104:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  05:41 PM October 01, 2016:\n Hum\n\n &gt; $($(curl http://www.yahoo.co.jp).Images | foreach {$_.src}) `\n     | sort `\n     | uniq `\n     | foreach { `\n       curl -Uri $_ -OutFile \"$(pwd)\\$(basename $_)\" `\n     }\n// from Twitter Web Client [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"105:1-105:13\"><strong>手術後</strong></p>\n<p data-sourcepos=\"107:1-107:51\">麻酔の痛みがきれてナーバスになる。</p>\n<div class=\"code-block\" data-sourcepos=\"109:5-114:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  04:06 PM October 08, 2016:\n ナースコールは enqueue/dequue もされてるがワーカーがかなりの頻度\n でこける。夜になると汚いログがはかれるのは #医療OS の仕様だろうか\n ...\n// from Twitter for Android [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"115:1-115:59\">気持ちを落ち着かせるためにEmacsをさわる。</p>\n<div class=\"code-block\" data-sourcepos=\"117:5-121:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  09:01 PM October 11, 2016:\n 可能なかぎり Emacs で #Xamarin さわりたいので、CentOS 上に samba\n 立てた。 https://t.co/XXCds2pwtx\n// from Twitter Web Client [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"122:1-122:55\">BashOnWindowsで無茶をやる。少し落ち着く。</p>\n<div class=\"code-block\" data-sourcepos=\"124:5-128:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  09:18 PM October 11, 2016:\n #BashOnWindows の Emacs から #Xamarin さわったら 関連ファイルが消\n されたり権限が変更されたりしたのだった ...\n// from twmode [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"129:1-129:90\">術後ずっと寝たきりだったが、なんとか動けるようになってきた。</p>\n<div class=\"code-block\" data-sourcepos=\"131:5-134:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  06:50 AM October 18, 2016:\n 胸郭手術時の 🛏 起床と就寝をマスターした https://t.co/ipIU4LPlBq\n// from Twitter Web Client [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"135:1-135:65\">激痛のためノートPCがもてない体になっていた。</p>\n<div class=\"code-block\" data-sourcepos=\"137:5-140:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  08:35 PM October 20, 2016:\n ノート PC は肉体的にまだ持てない ...\n// from twmode [Tokyo, JP]\n</code></pre></div></div>\n<p data-sourcepos=\"141:1-141:16\"><strong>退院間近</strong></p>\n<p data-sourcepos=\"143:1-143:78\">アクティブトラッカーで客観的にみるよう心がけ始める。</p>\n<div class=\"code-block\" data-sourcepos=\"145:5-150:0\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>nabinno,  05:22 PM October 21, 2016:\n #MicrosoftBand #HealthVault #MyFitnessPal で記録つけていて、ふと\n 医療機器がからだに入ってることにきづいた。他人事じゃないいんだけ\n ど、おもしろいなあ。\n// from twmode [Tokyo, JP]\n</code></pre></div></div>\n<h3 data-sourcepos=\"151:1-151:13\" id=\"3-2-6\" name=\"3-2-6\">\n<a class=\"anchor\" id=\"5. 退院\" name=\"5.%20%E9%80%80%E9%99%A2\" href=\"#5.%20%E9%80%80%E9%99%A2\" data-position=\"3-2-6\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"5. 退院\"> &gt; 5. 退院</span></a>5. 退院</h3>\n<p data-sourcepos=\"152:1-152:278\">退院は主治医が判断する、病棟の見回り医師ではない。そして、たいてい腕のたつ主治医は多忙なので1週間に1度しか顔を出さない。その時の様態次第で退院がどんどん後ろにずれていくので注意が必要だ。</p>\n<p data-sourcepos=\"154:1-154:19\"><strong>退院の条件</strong></p>\n<ul data-sourcepos=\"156:1-160:0\">\n<li data-sourcepos=\"156:1-156:32\">肺の状態、肺の膨らみ</li>\n<li data-sourcepos=\"157:1-157:17\">歩行の有無</li>\n<li data-sourcepos=\"158:1-158:17\">起床の有無</li>\n<li data-sourcepos=\"159:1-160:0\">退院したいという意志</li>\n</ul>\n<p data-sourcepos=\"161:1-161:123\">入院中は上記の条件をクリアできるようこころがけること。無為に過ごすと退院が遅れる。</p>\n<h2 data-sourcepos=\"163:1-163:27\" id=\"3-3-0\" name=\"3-3-0\">\n<a class=\"anchor\" id=\"手術後のリハビリ\" name=\"%E6%89%8B%E8%A1%93%E5%BE%8C%E3%81%AE%E3%83%AA%E3%83%8F%E3%83%93%E3%83%AA\" href=\"#%E6%89%8B%E8%A1%93%E5%BE%8C%E3%81%AE%E3%83%AA%E3%83%8F%E3%83%93%E3%83%AA\" data-position=\"3-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"手術後のリハビリ\"> &gt; 手術後のリハビリ</span></a>手術後のリハビリ</h2>\n<h3 data-sourcepos=\"165:1-165:33\" id=\"3-3-1\" name=\"3-3-1\">\n<a class=\"anchor\" id=\"1か月後 ひたすら静養\" name=\"1%E3%81%8B%E6%9C%88%E5%BE%8C%20%E3%81%B2%E3%81%9F%E3%81%99%E3%82%89%E9%9D%99%E9%A4%8A\" href=\"#1%E3%81%8B%E6%9C%88%E5%BE%8C%20%E3%81%B2%E3%81%9F%E3%81%99%E3%82%89%E9%9D%99%E9%A4%8A\" data-position=\"3-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1か月後 ひたすら静養\"> &gt; 1か月後 ひたすら静養</span></a>1か月後 ひたすら静養</h3>\n<p data-sourcepos=\"167:1-167:106\">退院直後の時期は風邪をひくと肺炎になる可能性が高まるので、2点注意する。</p>\n<p data-sourcepos=\"169:1-169:460\"><strong>まずは内科</strong>。退院前に外科から出される鎮痛剤が強力なので薬の組み合わせには注意する。特に内科で出される風邪薬自体にも鎮痛剤が入っており、同時に飲むと神経系に支障をきたすことがある。内科医には、咳をしたら胸に激痛が走るため鎮痛剤を利用している旨をつたえ、抗生剤、鎮咳剤、去痰剤の薬を処方してもらうようにする。</p>\n<p data-sourcepos=\"171:1-171:298\">また、肺炎の気がありX線検査する場合、内科医にバーが邪魔をして検査がむずかしい状況にあることを共有する。内科医によっては、外科医が処方・処置した鎮痛剤とバーが自分の仕事を邪魔していると考える人もいる。</p>\n<p data-sourcepos=\"173:1-173:85\"><strong>次に、免疫力</strong>。できるだけ免疫力が高まるように工夫する。</p>\n<p data-sourcepos=\"175:1-175:666\">食事。<a href=\"https://www.myfitnesspal.com/\" target=\"_blank\" rel=\"noopener noreferrer\">MyFitnessPal（Under Armour）</a>のような栄養を主としたアクティビティトラッカーで不足栄養を観察し、まずは機能食品などで不足栄養を補う。私は皮膚の組成に関係しそうなマルチビタミン、ビタミンC、タンパク質を積極的にとった（ている）。余裕が出てきたらスーパー食材、外食チェーンHPの栄養表をみて、実際に食事し体調を観察する。体調は<a href=\"https://www.withings.com/jp/ja/products/body\" target=\"_blank\" rel=\"noopener noreferrer\">Withing Body</a>と<a href=\"https://www.microsoft.com/microsoft-band/en-us\" target=\"_blank\" rel=\"noopener noreferrer\">MS Band</a>でトラックすると管理が楽だ。</p>\n<p data-sourcepos=\"177:1-177:729\">運動。運動はウォーキング程度に控えるよう医師から注意される。従って、この期間はスクワットなど胸郭や脇の傷周囲の皮膚組織に動きつけない運動で落ちた筋力を回復させる程度にする。また、無理のないストレッチで胸郭にうめこまれたバー周辺の皮膚を徐々に伸ばす、あたしい皮膚組織をつくるよう心掛ける。室内での自重トレーニングよりもジムのトレーニングマシンで、リハビリという視点で負荷を調整しながら無理なくおこなうといい。実際にトレーニングする前に医師からリハビリスタッフを紹介してもらうのも手だろう。</p>\n<p data-sourcepos=\"179:1-179:17\"><strong>3つの運動</strong></p>\n<ul data-sourcepos=\"181:1-184:0\">\n<li data-sourcepos=\"181:1-181:506\">\n<strong>有酸素運動</strong>。ウォーキングで循環器系をきたえる。退院後でも起床など胸郭をうごかすのがむずかしい状態なので、まずウォーキングが普通にできるようにのぞむ。慣れてきたら距離をのばして5km、10kmとのばすといいだろう。足の負担を気にするようだったら<a href=\"http://www.asics.com/jp/ja-jp/dynaflyte\" target=\"_blank\" rel=\"noopener noreferrer\">Asics DynaFlyte</a>のような、機能性を追求したランニングシューズの検討をすすめる。</li>\n<li data-sourcepos=\"182:1-182:634\">\n<strong>無酸素運動</strong>。無理のない筋トレで筋骨格をきたえる、皮膚を生成する。退院直後は腹筋、三角筋はバー周囲の皮膚が生成されていないので痛みとともに力を出すことがむずかしい。僧帽筋、大胸筋あたりから皮膚の生成を促すようにする。また、有酸素運動を無理なく行えるように下腿三頭筋（ふくろはぎ）や大腿四頭筋を積極的に動かす。余裕が出てきたら筋肉とトレーニングマシンの<a href=\"https://en.wikipedia.org/wiki/List_of_weight_training_exercises\" target=\"_blank\" rel=\"noopener noreferrer\">対応表</a>を参考にするといい。</li>\n<li data-sourcepos=\"183:1-184:0\">\n<strong>ストレッチ</strong>。ヨガで皮膚の生成を促す。退院直後はヨガをする余裕はないが、軽いウォーキングや筋トレをはじめたあたりで、バウンドエンジェル、チャイルドポーズ、ハッピーベイビーポーズなど軽めなものを混ぜるといい。参考までに<a href=\"https://en.wikipedia.org/wiki/List_of_asanas\" target=\"_blank\" rel=\"noopener noreferrer\">ポーズ集</a>がある。</li>\n</ul>\n<p data-sourcepos=\"185:1-185:306\">また、入院時に手術用コンプレッションウェアのタイツを着ていたが、退院後はスポーツ用コンプレッションウェアをシャツ、タイツともに着るといい。適度な負荷が皮膚に与えられるとともに、交感神経の活性化につながる。</p>\n<p data-sourcepos=\"187:1-187:156\">私はできなかったが、免疫力向上は準備するのに時間がかかるので入院・手術前から取り組んでおくといいだろう。</p>\n<h3 data-sourcepos=\"189:1-189:32\" id=\"3-3-2\" name=\"3-3-2\">\n<a class=\"anchor\" id=\"3か月後どうなったか\" name=\"3%E3%81%8B%E6%9C%88%E5%BE%8C%E3%81%A9%E3%81%86%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%8B\" href=\"#3%E3%81%8B%E6%9C%88%E5%BE%8C%E3%81%A9%E3%81%86%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%8B\" data-position=\"3-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3か月後どうなったか\"> &gt; 3か月後どうなったか</span></a>3か月後どうなったか</h3>\n<p data-sourcepos=\"190:1-190:75\">下記にリハビリの経過を示すため体組成の一部を記す。</p>\n<table data-sourcepos=\"192:1-197:66\">\n<thead>\n<tr data-sourcepos=\"192:1-192:85\">\n<th data-sourcepos=\"192:2-192:15\">体組成</th>\n<th data-sourcepos=\"192:17-192:27\">入院前</th>\n<th data-sourcepos=\"192:29-192:46\">退院後1か月</th>\n<th data-sourcepos=\"192:48-192:65\">退院後2か月</th>\n<th data-sourcepos=\"192:67-192:84\">退院後3か月</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"194:1-194:66\">\n<td data-sourcepos=\"194:2-194:14\">胸囲 (cm)</td>\n<td data-sourcepos=\"194:16-194:23\">68.5</td>\n<td data-sourcepos=\"194:25-194:37\">80.8</td>\n<td data-sourcepos=\"194:39-194:51\">82.7</td>\n<td data-sourcepos=\"194:53-194:65\">82.9</td>\n</tr>\n<tr data-sourcepos=\"195:1-195:66\">\n<td data-sourcepos=\"195:2-195:14\">体重 (kg)</td>\n<td data-sourcepos=\"195:16-195:23\">51.0</td>\n<td data-sourcepos=\"195:25-195:37\">46.6</td>\n<td data-sourcepos=\"195:39-195:51\">49.6</td>\n<td data-sourcepos=\"195:53-195:65\">50.8</td>\n</tr>\n<tr data-sourcepos=\"196:1-196:66\">\n<td data-sourcepos=\"196:2-196:14\">筋肉 (kg)</td>\n<td data-sourcepos=\"196:16-196:23\">-</td>\n<td data-sourcepos=\"196:25-196:37\">39.3</td>\n<td data-sourcepos=\"196:39-196:51\">41.4</td>\n<td data-sourcepos=\"196:53-196:65\">42.4</td>\n</tr>\n<tr data-sourcepos=\"197:1-197:66\">\n<td data-sourcepos=\"197:2-197:14\">脂肪 (kg)</td>\n<td data-sourcepos=\"197:16-197:23\">-</td>\n<td data-sourcepos=\"197:25-197:37\">4.9</td>\n<td data-sourcepos=\"197:39-197:51\">5.8</td>\n<td data-sourcepos=\"197:53-197:65\">5.9</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"199:1-199:420\">退院後1か月目は胸囲が劇的に変わった一方で、体重が低下している。ノートパソコンを持てないほどだったので筋力も同様に低下しているものと推測される。退院後2か月目はリハビリを始めた効果が順当に出てどの体組成値も回復している。そして、3か月目あたりで本来の値にもどっている様子がうかがえる。</p>\n<p data-sourcepos=\"201:1-201:224\">3か月目以降はほぼ手術前、あるいはそれ以上の生活の質を担保できるので、バーを抜く最終手術の3年後を見越して無理なくリハビリをつづけるといいと考えている。</p>\n","tags":["pectus-excavatum","bash-on-windows","emacs","powershell"],"updated_at":"2021-01-11T12:23:15+09:00","childPublishedDate":{"published_on":"2017-02-06T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- 今回作ったコード https://github.com/nabinno/esa.red    > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（nabinno/red-elixir）。 \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。"},"name":"[2019-03-31]イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","tags":["red","esa"],"childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z","published_on_unix":1553990400}}},{"node":{"number":53,"relative_category":"blog/frontend","fields":{"title":"Hyper-VモードでLinux OSとAndroid OSを同時使用する","excerpt":"Xamarinの開発環境を模索しています。普段はLinux/Hyper-V上でAPIを開発しているのですが、Hyper-VとAndroid Emulatorとの組み合わせがまだ整備されておらず一筋縄ではいかなかったのでその備忘となります。   > PROBLEMPROBLEM \n\n- 普段の開発環境CentOS/Hyper-Vを変更することなく、Xamarinをつかいたい CentOS/Hyper-V上にAPIサーバーをたてて、XamarinアプリからAPIをたたく構成 \n- CentOS/Hyper-V上にAPIサーバーをたてて、XamarinアプリからAPIをたたく構成\n- Android EmulatorはIntel HAXM＋ホスト型Hypervisor前提のものが多い VirtualBoxなどホスト型HypervisorだとVMがよくクラッシュしてつらい なので、APIサーバーはHyper-Vでたてている また、オフィス移動が多いのでネットワーク環境はおもにWi-Fi（無線LAN）を使用している \n- VirtualBoxなどホスト型HypervisorだとVMがよくクラッシュしてつらい なので、APIサーバーはHyper-Vでたてている また、オフィス移動が多いのでネットワーク環境はおもにWi-Fi（無線LAN）を使用している \n- なので、APIサーバーはHyper-Vでたてている\n- また、オフィス移動が多いのでネットワーク環境はおもにWi-Fi（無線LAN）を使用している   > SOLUTIONSOLUTION \n\nというわけで、Hyper-Vでイメージ管理するVisual Studio Emulator for Android（VS Emulator）を使うことにしました。これで何もせずに解決かというそうではなく、まず前提としてネットワーク上の注意があります。 \n\n1. VS EmulatorはHyper-VのNetwork AdapterをEthernet（有線LAN）しか使用できません。Wi-Fi（無線LAN）は使用できません\n2. VS Emulatorの各デバイス(Android VM）を初回起動させる際に、有線LANと無線LAN双方からネットワークにつなげていると失敗します   > Hyper-VモードでLinux OS（VM）とAndroid OS（VM）を同時使用する方法Hyper-VモードでLinux OS（VM）とAndroid OS（VM）を同時使用する方法 \n\nその上で、同時使用する方法ですが、先ほどネットワークの注意を考慮すると下記のような流れになります。 \n\n1. Stop-VM CentOS 現在稼働しているLinux VMを停止します\n2. Disable-NetAdapter Wi-Fi 無線LANの接続を停止し、有線LANのみの接続にします\n3. VS EmulatorからAndroid VMを初回起動します、そうすると有線LAN用のvEthernetが作成されます\n4. Enable-NetAdapter Wi-Fi - 無線LAN、有線LAN、双方を接続します\n5. Start-VM CentOS - Linux VMを起動します   > WRAPUPWRAPUP \n\nWindows Subsystems for Linux等、Windowsの仮想化環境はまだ発展途上にあります。おそらく今回の対処方法は一時的なものに過ぎず、こうしたネットワーク上の注意を意識することなく解決できると思われます。しばし様子見です。"},"name":"[2017-03-09]Hyper-VモードでLinux OSとAndroid OSを同時使用する","tags":["android","smartphone","visual-studio-emulator-for-android","surface-book","android-emulator"],"childPublishedDate":{"published_on":"2017-03-09T00:00:00.000Z","published_on_unix":1489017600}}},{"node":{"number":65,"relative_category":"blog/backend","fields":{"title":"LYSE本を読む","excerpt":"Elixirの存在を知ったのが2014年7月14日。それからおよそ3年経つというのに一向に理解した気になれないでいます。特にSLAナイン・ナインはなぜその数値なのか腑に落ちないでいました。今回『Learn You Some Erlang for Great Good!（通称LYSE本）』を読むことで積年の謎を解明してみようと臨みました。   > PROBLEMPROBLEM \n\n- Elixirをさわりはじめてしばらく経つけどふかく理解した気になれない\n- Phoenixやほかのフレームワークに頼られないケースが出てきたとき自由な発想ができるようになっておきたい\n- 巷でいわれているSLAナイン・ナイン（99.9999999%）などの実際がどうなのか腹落ちしてない   > TLDRTLDR \n\n- 下記Erlang機能を中心に高いSLAを提供する素地をなしている 分散システム Erlang Port Mapper Daemon（EPMD） 他の言語・フレームワークが「分散コンピューティングの落とし穴」「CAP定理」にどのように対応している比較すると、Erlangの特徴がより見えてくる。 EMPDの特徴 耐障害性（スケーリングはやや弱い） マルチプロセス ネットワークの障害監視 ライフサイクル、再起動戦略を備えたライブラリ（分散OTP） CPシステムでNoSQLデータベース「Mnesia」 \n- 分散システム Erlang Port Mapper Daemon（EPMD） 他の言語・フレームワークが「分散コンピューティングの落とし穴」「CAP定理」にどのように対応している比較すると、Erlangの特徴がより見えてくる。 EMPDの特徴 耐障害性（スケーリングはやや弱い） マルチプロセス ネットワークの障害監視 \n- 他の言語・フレームワークが「分散コンピューティングの落とし穴」「CAP定理」にどのように対応している比較すると、Erlangの特徴がより見えてくる。\n- EMPDの特徴 耐障害性（スケーリングはやや弱い） マルチプロセス ネットワークの障害監視 \n- 耐障害性（スケーリングはやや弱い）\n- マルチプロセス\n- ネットワークの障害監視\n- ライフサイクル、再起動戦略を備えたライブラリ（分散OTP）\n- CPシステムでNoSQLデータベース「Mnesia」   > SOLUTIONSOLUTION \n\nというわけで、「LYSE本」を読むことにしました。各セクションにはElixirに関係ありそうな箇所を抜粋しています。長い長いメモになるので、TLDRだけで済ませて問題ありません。結論、輪郭は見えてきましたがまだその探求の入り口に来たに過ぎないのだということは理解しました。   > 1-3 Erlang概要1-3 Erlang概要   > 1.2 Erlangって何？1.2 Erlangって何？ \n\n- 関数型言語 純粋主義（参照透過性、破壊的データを避けるなど）に従いつつ、実世界で問題が発生した場合はそれを取り払う \n- 純粋主義（参照透過性、破壊的データを避けるなど）に従いつつ、実世界で問題が発生した場合はそれを取り払う\n- アクターモデル 同時並行性 高可用性 Ex: Blue-Green deployment Log management Policy: Let it crash - クラッシュするならさせておけ As bad as anything else let it crashが生んだ誤解 \n- 同時並行性\n- 高可用性\n- Ex: Blue-Green deployment Log management \n- Blue-Green deployment\n- Log management\n- Policy: Let it crash - クラッシュするならさせておけ As bad as anything else let it crashが生んだ誤解 \n- Let it crash - クラッシュするならさせておけ As bad as anything else let it crashが生んだ誤解 \n- As bad as anything else\n- let it crashが生んだ誤解\n- 開発環境 クロスプラットフォーム BEAM 開発ツール コンパイラ デバッガ プロファイラ テストフレームワーク \n- クロスプラットフォーム BEAM \n- BEAM\n- 開発ツール コンパイラ デバッガ プロファイラ テストフレームワーク \n- コンパイラ\n- デバッガ\n- プロファイラ\n- テストフレームワーク\n- ライブラリ OTPフレームワーク Webサーバー パーサジェネレータ Mnesiaデータベース \n- OTPフレームワーク\n- Webサーバー\n- パーサジェネレータ\n- Mnesiaデータベース   > 1.3 Don't drink too much Kool-Aid1.3 Don't drink too much Kool-Aid \n\n- 軽量プロセスによるスケール タスクを細かく分けすぎる＝むやみに並行処理させると処理速度に影響がでる \n- タスクを細かく分けすぎる＝むやみに並行処理させると処理速度に影響がでる\n- CPUコア数によるスケール すべてを同時に稼働させることができない \n- すべてを同時に稼働させることができない\n- 技術領域 適切でない技術領域 画像処理 信号処理 OSのデバイスドライバ 適切な技術領域 巨大なサーバソフトウェア - QMS, MapReduce 多言語との接続 高レベルプロトコルの実装 Ex: IANOというUNICTチームが作成したロボット Wings 3D \n- 適切でない技術領域 画像処理 信号処理 OSのデバイスドライバ \n- 画像処理\n- 信号処理\n- OSのデバイスドライバ\n- 適切な技術領域 巨大なサーバソフトウェア - QMS, MapReduce 多言語との接続 高レベルプロトコルの実装 Ex: IANOというUNICTチームが作成したロボット Wings 3D \n- 巨大なサーバソフトウェア - QMS, MapReduce\n- 多言語との接続\n- 高レベルプロトコルの実装\n- Ex: IANOというUNICTチームが作成したロボット Wings 3D \n- IANOというUNICTチームが作成したロボット\n- Wings 3D   > 3.2. 変化できない変数3.2. 変化できない変数 \n\n- パターンマッチング（= 演算子） 比較の役割も果たしている 値が違っていたらエラーを出す 値が同じだったら当該の値を返す \n- 比較の役割も果たしている 値が違っていたらエラーを出す 値が同じだったら当該の値を返す \n- 値が違っていたらエラーを出す\n- 値が同じだったら当該の値を返す   erlang \n\n> 47 = 45 + 2. > 47 = 45 + 3. ** exception error: no match of right hand side value 48   \n\n- アンダースコア変数（_） 使用はできるが値の格納はできない \n- 使用はできるが値の格納はできない   erlang \n\n> _ = 14+3. 17 > _. * 1: variable '_' is unbound     > 3.3. アトム3.3. アトム \n\n- アトムと予約語 いくつかのアトムは予約語 after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor false true \n- いくつかのアトムは予約語 after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor false true \n- after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor false true   > 3.4. ブール代数と比較演算子3.4. ブール代数と比較演算子 \n\n- false trueはアトムなので数値の代替にはならない\n- アトムなどのほかの型も比較対象になる number < atom < reference < fun < port < pid < tuple < list < bit string \n- number < atom < reference < fun < port < pid < tuple < list < bit string   erlang \n\n> 0 == false. false > 1 < false. true     > 3.8. ビット構文!3.8. ビット構文! \n\n- Erlangはおもいデータを数値処理するにはむいてない\n- 一方、数値処理が必要ないアプリケーションの中では速い 次のような処理にむいている イベントに反応する イベントをミリ秒単位でしょりできリアルタイムアプリケーションに適している メッセージングパッシング アトムをつかうと軽く処理できる \n- 次のような処理にむいている イベントに反応する イベントをミリ秒単位でしょりできリアルタイムアプリケーションに適している メッセージングパッシング アトムをつかうと軽く処理できる \n- イベントに反応する イベントをミリ秒単位でしょりできリアルタイムアプリケーションに適している \n- イベントをミリ秒単位でしょりできリアルタイムアプリケーションに適している\n- メッセージングパッシング アトムをつかうと軽く処理できる \n- アトムをつかうと軽く処理できる\n- 軽量なビット文字列 Pros リストで表現する文字列は1文字につき1ノード ビット文字列はC言語の配列のようなもの - <<\"this is a bit string!\">> Cons パターンマッチなどの捜査の際に単純さが失われる \n- Pros リストで表現する文字列は1文字につき1ノード ビット文字列はC言語の配列のようなもの - <<\"this is a bit string!\">> \n- リストで表現する文字列は1文字につき1ノード\n- ビット文字列はC言語の配列のようなもの - <<\"this is a bit string!\">> \n- Cons パターンマッチなどの捜査の際に単純さが失われる \n- パターンマッチなどの捜査の際に単純さが失われる   > 4-5 パターンマッチング4-5 パターンマッチング \n\n4-5章からIDEがないとreplなどに時間がとられるので整備しておこう。Emacsならerlang.elがある。インデント、フィルコメント、コメントアウト、OTPなどのscafold、Eshell、コンパイル等ひととおりそろっている。   > 5.5. 関数呼び出しによるパターンマッチガードはcase文よりも優れているのか？5.5. 関数呼び出しによるパターンマッチガードはcase文よりも優れているのか？ \n\nまず、パフォーマンス上かわらない。 \n\nつぎに、引数が複数あるときは関数をつかう。   erlang \n\nbeach(Temperature) -> case Temperature of {celsius, N} when N > 20 andalso N =< 45 -> 'favorable'; {kelvin, N} when N >= 293 andalso N =< 318 -> 'scientifically favorable'; {fahrenheit, N} when N >= 68 andalso N =< 113 -> 'favorable in the US'; _ -> 'avoid beach' end.   \n\n上記のようだと可読性がさがる、冗長的。以下のように関数でまとめる。   erlang \n\nbeachf({celsius, N}) when N >= 20 andalso N =< 45 -> 'favorable'; beachf({kelvin, N}) when N >=293 andalso N =< 318 -> 'scientifically favorable'; beachf({fahrenheit, N}) when N >= 68 andalso N =< 113 -> 'favorable in the US'; beachf(_) -> 'avoid beach'.   \n\nただし、引数が評価関数の対象の場合はcase文が向いている。   erlang \n\nprepend(X, []) -> [X]; prepend(X, Set) -> case lists:member(X, Set) of true -> Set; false -> [X | Set] end.     > 6-11 文法6-11 文法 \n\n- 今回は標準文法について Erlangの特徴はざっと次の通り 型変換の関数が素朴 erlang:<type>_to_<type> という形式をとっているため、型が追加されるたびに変換用関数を BIF (built-in function) に追加しなければいけない 再帰、無名関数、エラーは普通、Ruby, JSっぽい レコードによってインターフェイスを定義できる データ構造にキーバリューストア、セット、配列、有効グラフ、キューがある ただ配列は、他の手続き型言語の配列とは逆に、一定時間での挿入や検索ができない Erlangでなされるプログラミングスタイルでは配列や行列と結びつける必要がなく、実際にはめったに使われないため \n- Erlangの特徴はざっと次の通り 型変換の関数が素朴 erlang:<type>_to_<type> という形式をとっているため、型が追加されるたびに変換用関数を BIF (built-in function) に追加しなければいけない 再帰、無名関数、エラーは普通、Ruby, JSっぽい レコードによってインターフェイスを定義できる データ構造にキーバリューストア、セット、配列、有効グラフ、キューがある ただ配列は、他の手続き型言語の配列とは逆に、一定時間での挿入や検索ができない Erlangでなされるプログラミングスタイルでは配列や行列と結びつける必要がなく、実際にはめったに使われないため \n- 型変換の関数が素朴 erlang:<type>_to_<type> という形式をとっているため、型が追加されるたびに変換用関数を BIF (built-in function) に追加しなければいけない \n- erlang:<type>_to_<type> という形式をとっているため、型が追加されるたびに変換用関数を BIF (built-in function) に追加しなければいけない\n- 再帰、無名関数、エラーは普通、Ruby, JSっぽい\n- レコードによってインターフェイスを定義できる\n- データ構造にキーバリューストア、セット、配列、有効グラフ、キューがある ただ配列は、他の手続き型言語の配列とは逆に、一定時間での挿入や検索ができない Erlangでなされるプログラミングスタイルでは配列や行列と結びつける必要がなく、実際にはめったに使われないため \n- ただ配列は、他の手続き型言語の配列とは逆に、一定時間での挿入や検索ができない Erlangでなされるプログラミングスタイルでは配列や行列と結びつける必要がなく、実際にはめったに使われないため \n- Erlangでなされるプログラミングスタイルでは配列や行列と結びつける必要がなく、実際にはめったに使われないため   > 7. 再帰7. 再帰 \n\n- lists モジュール sort/1 join/2 last/1 flatten/1 all/1 reverse/1 map/2 filter/2 \n- sort/1\n- join/2\n- last/1\n- flatten/1\n- all/1\n- reverse/1\n- map/2\n- filter/2\n- gb_tree モジュール lookup/2 map/2 \n- lookup/2\n- map/2   > 8.2. 無名関数8.2. 無名関数   erlang \n\n> (fun() -> a end)(). a > lists:filter(fun(X) -> X rem 2 == 0 end, lists:seq(1, 10)). [2,4,6,8,10]     > 9. エラー9. エラー コンパイル時エラー    type error description     Module Module name 'madule' does not match file name 'module'  -module 属性内に書いたモジュール名がファイル名と一致していない   Function Warning: function somefunction/0 is unused 関数を公開していない、あるいはその関数が使われている場所が間違った関数名やアリティになっている   Function function somefunction/1 undefined 関数が存在していない:  -export 属性内あるいは関数を宣言するときに間違った関数名やアリティを書いてる   Function head mismatch 関数定義を他の関数での先頭の節の間に差し込んでいる   Syntax syntax error before: 'SomeCharacterOrWord' Ex: 括弧の閉じ忘れやタプルやおかしな式接尾辞、予約語・おかしな文字コードにエンコードされたUnicode文字の使用   Syntax syntax error before: 行末がおかしい   Variable Warning: this expression will fail with a 'badarith' exception Ex: llama + 5    Variable Warning: a term is constructed, but never used 関数の中に、リス作成、タプル宣言、どんな変数にも束縛されていない無名関数・自身を返す無名関数の宣言がある   Variable Warning: variable 'Var' is unused 使わない変数を宣言している   Variable Warning: this clause cannot match because a previous clause at line 4 always matches モジュール内で定義された関数が catch-all 節のあとに特定の節を持っている   Variable variable 'A' unsafe in 'case'  case ... of の中で宣言されている変数を、その外側で使っている    ランタイムエラー (exception error)    type error description     function clause no function clause matching somefunction 関数内のすべてのガード節で失敗、あるいはすべてのパターンマッチで失敗   case clause no case clause matching 'value' 条件の書き忘れ、誤った種類のデータ送信、 catch-all 節が必要な場合   if clause no true branch found when evaluating an if expression 条件の書き忘れ、 catch-all 節が必要な場合   badmatch no match of right hand side value 無理なパターンマッチ、変数束縛の繰り返し   badarg bad argument 誤った引数の呼び出し   undef undefined function somefunction 未定義関数の呼び出し   badarith bad argument in an arithmetic expression 誤った算術演算   badfun bad function 変数を関数として呼び出した場合   badarity interpreted function with arity 1 called with two arguments 誤ったアリティ    例外処理   erlang \n\n1> erlang:error(badarith). ** exception error: bad argument in an arithmetic expression 2> erlang:error(custom_error). ** exception error: custom_error     > 11.2 レコード11.2 レコード   erlang \n\n-record(robot, {name, type=industrial, hobbies, details=[]}).     erlang \n\n5> Crusher = #robot{name=\"Crusher\", hobbies=[\"Crushing people\",\"petting cats\"]}. #robot{name = \"Crusher\",type = industrial, hobbies = [\"Crushing people\",\"petting cats\"], details = []} 6> Crusher#robot.hobbies. %% 参照 [\"Crushing people\",\"petting cats\"] 7> NestedBot = #robot{details=#robot{name=\"erNest\"}}. #robot{name = undefined,type = industrial, hobbies = undefined, details = #robot{name = \"erNest\",type = industrial, hobbies = undefined,details = []}} 8> NestedBot#robot.details#robot.name. %% ネスト参照 \"erNest\"     > 11.3. キーバリューストア11.3. キーバリューストア \n\nキーバリューストアは4つのモジュールで提供されている。    module methods description     proplist  get_value/2, get_all_values/2, lookup/2, lookup_all/2  少量データ向け, 緩いデータ構造   orddict  store/3, find/2, fetch/2, erase/2  少量データ向け（75要素くらい）   dict  store/3, find/2, fetch/2, erase/2, map/2, fold/2  大量データ向け、ordict と同じインターフェイス   gb_trees  enter/2, lookup/2, delete_any/2, insert/3, get/2, update/3, delete/2  大量データ向け、データ構造の入出力がわかるスマートモードとわからないネイティブモードがあるため状況に応じて安全性とパフォーマンスのバランスを取ることができる      > 11.5.セット11.5.セット \n\nセット（集合）は4つのモジュールで提供されている。    module methods description     ordsets  new/0, is_element/2, add_element/2, del_element/2, union/1, intersection/1  少量セット向け、遅いが可読性が高い   sets - 大量セット向け、ordsets と同じインターフェイス   gb_sets - 大量セット向け、スマートモード・ネイティブモードがあるため状況に応じ安全性とパフォーマンスのバランスを取ることができる   sofs - 一意な要素の集合だけではなく、数学的な概念として集合が必要な場合      > 11.6. 有効グラフ11.6. 有効グラフ \n\n有効グラフは2つのモジュールで提供されている。    module description     digraph 生成、変更、エッジ・辺の操作、経路・周の検索   digraph_utils グラフの誘導、木のテスト、隣接ノードの検索      > 11.7. キュー11.7. キュー \n\nqueue モジュール    api methods description     Original API  new/0, in/2, out/1  キューの作成・削除   Extended API  get/1, peek/1, drop/1  キューの中身の確認   Okasaki API - 関数型データ構造にもとづく      > 12-13 並列性について12-13 並列性について   > 12.2.1. 並列性の概念12.2.1. 並列性の概念 \n\n- Erlangの開発の背景 大抵の人は並行ソフトウェアを書くことにうんざりしてる 並行の解決策のほとんどがロックやミューテックスと呼ばれる小さな理論を扱うことに終始する 通信業界では並行性・並列性をめざす文化があった PLEX AXE \n- 大抵の人は並行ソフトウェアを書くことにうんざりしてる 並行の解決策のほとんどがロックやミューテックスと呼ばれる小さな理論を扱うことに終始する \n- 並行の解決策のほとんどがロックやミューテックスと呼ばれる小さな理論を扱うことに終始する\n- 通信業界では並行性・並列性をめざす文化があった PLEX AXE \n- PLEX\n- AXE\n- 満たすべき要求 スケーラビリティ リニアスケールが可能 実装方針 小さなプロセス プロセスに共有メモリの使用を禁じる フォールトレランス (交換機上の何千ものユーザをサポートすること) クラッシュが可能 クラッシュ後リスタートが可能 実装方針 分散 非同期メッセージングパッシング \n- スケーラビリティ リニアスケールが可能 実装方針 小さなプロセス プロセスに共有メモリの使用を禁じる \n- リニアスケールが可能\n- 実装方針 小さなプロセス プロセスに共有メモリの使用を禁じる \n- 小さなプロセス\n- プロセスに共有メモリの使用を禁じる\n- フォールトレランス (交換機上の何千ものユーザをサポートすること) クラッシュが可能 クラッシュ後リスタートが可能 実装方針 分散 非同期メッセージングパッシング \n- クラッシュが可能\n- クラッシュ後リスタートが可能\n- 実装方針 分散 非同期メッセージングパッシング \n- 分散\n- 非同期メッセージングパッシング\n- 実装 並列・並行に最適化されたVM コア1つに対してスケジューラとして1つのスケジューラを起動 実行キューにあるタスクが多すぎた場合、他スレッドのスケジューラに移される 過負荷なプロセスに対して送れるメッセージ量を制御 \n- 並列・並行に最適化されたVM コア1つに対してスケジューラとして1つのスケジューラを起動 実行キューにあるタスクが多すぎた場合、他スレッドのスケジューラに移される 過負荷なプロセスに対して送れるメッセージ量を制御 \n- コア1つに対してスケジューラとして1つのスケジューラを起動\n- 実行キューにあるタスクが多すぎた場合、他スレッドのスケジューラに移される\n- 過負荷なプロセスに対して送れるメッセージ量を制御   > 12.3. すべてが線形にスケールするわけではない12.3. すべてが線形にスケールするわけではない \n\n- アムダールの法則 50%並行にしたコードは2倍ほど速くなる 95%並行にしたコードは20倍ほど速くなる \n- 50%並行にしたコードは2倍ほど速くなる\n- 95%並行にしたコードは20倍ほど速くなる   > 14 プロセス間通信14 プロセス間通信 \n\n- 今回は2つのプロセス間通信のプロセス管理について 片方のプロセスがエラーになっても、もう片方のプロセスが死なないようにする プロセスがエラーになったものはクラッシュさせる クラッシュしたプロセスをリスタートさせる また、そのクラッシュ情報をもう片方にメッセージとして送る \n- 片方のプロセスがエラーになっても、もう片方のプロセスが死なないようにする プロセスがエラーになったものはクラッシュさせる クラッシュしたプロセスをリスタートさせる また、そのクラッシュ情報をもう片方にメッセージとして送る \n- プロセスがエラーになったものはクラッシュさせる クラッシュしたプロセスをリスタートさせる \n- クラッシュしたプロセスをリスタートさせる\n- また、そのクラッシュ情報をもう片方にメッセージとして送る   > エラーとプロセスエラーとプロセス \n\n以下、3つの関数をつかい実装する。 \n\n1. erlang:exit(Pid, Why) - Pid に対して自分が異常終了で死んだとつたえる。自身は死なない。\n2. erlang:process_flag(trap_exit, Value) - Value が true ならシステムプロセスとなり、 false ならシステムプロセスでなくなる。デフォルトは false。この関数によりクラッシュしたプロセスをリスタートさせる\n3. erlang:register(Atom, Pid) と erlang:make_ref() - register/2 で予測不可能な Pid を Atom として登録し、make_ref/0 で生成された Reference をもとにメッセージ送信をおこなう。なお、ここで生成される Reference は同一Erlang VM上、あるいはクラスタリングしたVM上のみでユニークになる。   erlang \n\nstart_critic2() -> spawn(?MODULE, restarter, []). restarter() -> process_flag(trap_exit, true), Pid = spawn_link(?MODULE, critic2, []), register(critic2, Pid), receive {'EXIT', Pid, normal} -> % not a crash  ok; {'EXIT', Pid, shutdown} -> % manual termination, not a crash  ok; {'EXIT', Pid, _} -> restarter() end. judge2(Band, Album) -> Ref = make_ref(), critic2 ! {self(), Ref, {Band, Album}}, receive {Ref, Criticism} -> Criticism after 2000 -> timeout end. critic2() -> receive {From, Ref, {\"Rage Against the Turing Machine\", \"Unit Testify\"}} -> From ! {Ref, \"They are great!\"}; {From, Ref, {\"System of a Downtime\", \"Memoize\"}} -> From ! {Ref, \"They're not Johnny Crash but they're good.\"}; {From, Ref, {\"Johnny Crash\", \"The Token Ring of Fire\"}} -> From ! {Ref, \"Simply incredible.\"}; {From, Ref, {_Band, _Album}} -> From ! {Ref, \"They are terrible!\"} end, critic2().     erlang \n\n27> functions:start_critic2(). <0.125.0> 28> functions:judge2(\"The Doors\", \"Light my Firewall\"). \"They are terrible!\" 29> exit(whereis(critic2), kill). true 30> whereis(critic2). <0.129.0> 31> functions:judge2(\"The Doors\", \"Light my Firewall\"). \"They are terrible!\"     > 15 アプリケーションを作成する15 アプリケーションを作成する   > リマインダーアプリケーションリマインダーアプリケーション \n\n- 仕様 イベントを追加 イベントには締切り（警告する時間）、イベント名、詳細が含まれます イベントの時間が来たら警告 イベント名でイベントをキャンセル 永続的なディスク保存先を持たない 注 これは今回見ようとしているのアーキテクチャの概念を示すのに必要ありません これは実際のアプリケーションを作るなら全然ダメなことですが、代わりにもし実装したくなったらその機能はどこに挿入されるかを示して、ちょっとだけその実装の手助けになる関数も示します 永続化保存先がないとした場合、実行中にコードを更新しなければいけません ソフトウェアとのやりとりはコマンドライン経由で あとでこれは拡張できる たとえばGUI、Webページアクセス、IMソフト、メールなど \n- イベントを追加 イベントには締切り（警告する時間）、イベント名、詳細が含まれます \n- イベントには締切り（警告する時間）、イベント名、詳細が含まれます\n- イベントの時間が来たら警告\n- イベント名でイベントをキャンセル\n- 永続的なディスク保存先を持たない 注 これは今回見ようとしているのアーキテクチャの概念を示すのに必要ありません これは実際のアプリケーションを作るなら全然ダメなことですが、代わりにもし実装したくなったらその機能はどこに挿入されるかを示して、ちょっとだけその実装の手助けになる関数も示します 永続化保存先がないとした場合、実行中にコードを更新しなければいけません \n- 注 これは今回見ようとしているのアーキテクチャの概念を示すのに必要ありません これは実際のアプリケーションを作るなら全然ダメなことですが、代わりにもし実装したくなったらその機能はどこに挿入されるかを示して、ちょっとだけその実装の手助けになる関数も示します \n- これは今回見ようとしているのアーキテクチャの概念を示すのに必要ありません\n- これは実際のアプリケーションを作るなら全然ダメなことですが、代わりにもし実装したくなったらその機能はどこに挿入されるかを示して、ちょっとだけその実装の手助けになる関数も示します\n- 永続化保存先がないとした場合、実行中にコードを更新しなければいけません\n- ソフトウェアとのやりとりはコマンドライン経由で あとでこれは拡張できる たとえばGUI、Webページアクセス、IMソフト、メールなど \n- あとでこれは拡張できる たとえばGUI、Webページアクセス、IMソフト、メールなど \n- たとえばGUI、Webページアクセス、IMソフト、メールなど\n- ユースケース Client イベントサーバをサブスクライブして、メッセージとして通知を受ける こうすることで、すべてイベントサーバをサブスクライブしている多くのクライアントを設計するのが簡単になる 各クライアントは潜在的に、前述した異なるゲートウェイとなる GUI、Webページ、IMソフト、メールなど サーバにイベントを詳細情報とともに追加するように依頼 サーバにイベントをキャンセルするように依頼 サーバを（落ちたかどうか知る為に）監視 必要があればイベントサーバを終了 Event Server メソッド クライアントからのサブスクライブを受取 イベントプロセスから出された通知を各サブスクライバに転送 イベントを追加するためにメッセージを受取 必要なX, Y, Zプロセスを起動 イベントキャンセルのメッセージを受取 イベントプロセスを殺す クライアントから終了できる シェルから自分自身のコードを再読込出来る Process X, Y, Z 発報が待たれる通知を表す 天気にはイベントサーバにリンクされたタイマーに過ぎない 時間が来たらイベントサーバにメッセージを送る キャンセルのメッセージを受け取って死ぬ \n- Client イベントサーバをサブスクライブして、メッセージとして通知を受ける こうすることで、すべてイベントサーバをサブスクライブしている多くのクライアントを設計するのが簡単になる 各クライアントは潜在的に、前述した異なるゲートウェイとなる GUI、Webページ、IMソフト、メールなど サーバにイベントを詳細情報とともに追加するように依頼 サーバにイベントをキャンセルするように依頼 サーバを（落ちたかどうか知る為に）監視 必要があればイベントサーバを終了 \n- イベントサーバをサブスクライブして、メッセージとして通知を受ける こうすることで、すべてイベントサーバをサブスクライブしている多くのクライアントを設計するのが簡単になる 各クライアントは潜在的に、前述した異なるゲートウェイとなる GUI、Webページ、IMソフト、メールなど \n- こうすることで、すべてイベントサーバをサブスクライブしている多くのクライアントを設計するのが簡単になる\n- 各クライアントは潜在的に、前述した異なるゲートウェイとなる GUI、Webページ、IMソフト、メールなど \n- GUI、Webページ、IMソフト、メールなど\n- サーバにイベントを詳細情報とともに追加するように依頼\n- サーバにイベントをキャンセルするように依頼\n- サーバを（落ちたかどうか知る為に）監視\n- 必要があればイベントサーバを終了\n- Event Server メソッド クライアントからのサブスクライブを受取 イベントプロセスから出された通知を各サブスクライバに転送 イベントを追加するためにメッセージを受取 必要なX, Y, Zプロセスを起動 イベントキャンセルのメッセージを受取 イベントプロセスを殺す クライアントから終了できる シェルから自分自身のコードを再読込出来る Process X, Y, Z 発報が待たれる通知を表す 天気にはイベントサーバにリンクされたタイマーに過ぎない 時間が来たらイベントサーバにメッセージを送る キャンセルのメッセージを受け取って死ぬ \n- メソッド クライアントからのサブスクライブを受取 イベントプロセスから出された通知を各サブスクライバに転送 イベントを追加するためにメッセージを受取 必要なX, Y, Zプロセスを起動 イベントキャンセルのメッセージを受取 イベントプロセスを殺す クライアントから終了できる シェルから自分自身のコードを再読込出来る \n- クライアントからのサブスクライブを受取\n- イベントプロセスから出された通知を各サブスクライバに転送\n- イベントを追加するためにメッセージを受取 必要なX, Y, Zプロセスを起動 \n- 必要なX, Y, Zプロセスを起動\n- イベントキャンセルのメッセージを受取 イベントプロセスを殺す \n- イベントプロセスを殺す\n- クライアントから終了できる\n- シェルから自分自身のコードを再読込出来る\n- Process X, Y, Z 発報が待たれる通知を表す 天気にはイベントサーバにリンクされたタイマーに過ぎない 時間が来たらイベントサーバにメッセージを送る キャンセルのメッセージを受け取って死ぬ \n- 発報が待たれる通知を表す 天気にはイベントサーバにリンクされたタイマーに過ぎない \n- 天気にはイベントサーバにリンクされたタイマーに過ぎない\n- 時間が来たらイベントサーバにメッセージを送る\n- キャンセルのメッセージを受け取って死ぬ\n- 実装 ディレクトリ構成 ebin/ include/ priv/ src/ event.erl - event module loop/1 normalize/1 start/2 start_link/2 cancel/1 time_to_go/1 init/3 evserv.erl - event server loop/1 valid_datetime/1 valid_time/1 valid_time/3 send_to_clients/2 start/0 start_link/0 terminate/0 subscribe/1 add_event/3 add_event2/3 cancel/1 listen/1 init/0 sup.erl - supervisor start/2 start_link/2 init/1 loop/1 Emakefile{'src/*', [debug_info, {i, \"src\"}, {i, \"include\"}, {outdir, \"ebin\"}]}. \n- ディレクトリ構成 ebin/ include/ priv/ src/ event.erl - event module loop/1 normalize/1 start/2 start_link/2 cancel/1 time_to_go/1 init/3 evserv.erl - event server loop/1 valid_datetime/1 valid_time/1 valid_time/3 send_to_clients/2 start/0 start_link/0 terminate/0 subscribe/1 add_event/3 add_event2/3 cancel/1 listen/1 init/0 sup.erl - supervisor start/2 start_link/2 init/1 loop/1 Emakefile{'src/*', [debug_info, {i, \"src\"}, {i, \"include\"}, {outdir, \"ebin\"}]}. \n- ebin/\n- include/\n- priv/\n- src/ event.erl - event module loop/1 normalize/1 start/2 start_link/2 cancel/1 time_to_go/1 init/3 evserv.erl - event server loop/1 valid_datetime/1 valid_time/1 valid_time/3 send_to_clients/2 start/0 start_link/0 terminate/0 subscribe/1 add_event/3 add_event2/3 cancel/1 listen/1 init/0 sup.erl - supervisor start/2 start_link/2 init/1 loop/1 \n- event.erl - event module loop/1 normalize/1 start/2 start_link/2 cancel/1 time_to_go/1 init/3 \n- loop/1\n- normalize/1\n- start/2\n- start_link/2\n- cancel/1\n- time_to_go/1\n- init/3\n- evserv.erl - event server loop/1 valid_datetime/1 valid_time/1 valid_time/3 send_to_clients/2 start/0 start_link/0 terminate/0 subscribe/1 add_event/3 add_event2/3 cancel/1 listen/1 init/0 \n- loop/1\n- valid_datetime/1\n- valid_time/1\n- valid_time/3\n- send_to_clients/2\n- start/0\n- start_link/0\n- terminate/0\n- subscribe/1\n- add_event/3\n- add_event2/3\n- cancel/1\n- listen/1\n- init/0\n- sup.erl - supervisor start/2 start_link/2 init/1 loop/1 \n- start/2\n- start_link/2\n- init/1\n- loop/1\n- Emakefile{'src/*', [debug_info, {i, \"src\"}, {i, \"include\"}, {outdir, \"ebin\"}]}.    sh \n\n$ erl -make && erl -pa ebin/ Erlang/OTP 19 [erts-8.1] [source] [64-bit] [smp:2:2] [async-threads:10] [kernel-poll:false] Eshell V8.1 (abort with ^G) 1> evserv:start(). <0.59.0> 2> evserv:subscribe(self()). {ok,#Ref<0.0.2.84>} 3> evserv:add_event(\"Hey there3\", \"test\", { {2017, 7, 9}, {1, 23, 59} }). ok 4> evserv:listen(2000). [{done,\"Hey there3\",\"test\"}]     > TIPSTIPS \n\n- Erlangのタイムアウト値はミリ秒でおよそ50日に制限されている   > 16 OTP16 OTP   > OTPとはなにかOTPとはなにか \n\n- Erlangの特徴 並列・分散 エラー処理 \n- 並列・分散\n- エラー処理\n- 組込関数 リンク モニター タイムアウト 終了の補足 \n- リンク\n- モニター\n- タイムアウト\n- 終了の補足\n- OTP 下記のようなバグになりやすい箇所をモジュールとして吸収 プロセスの順番 競合条件をどのように避けるか プロセスはいつでも死ぬ可能性があること ホットコードローディング 名前付きプロセス Supervisor Pros バグを解決するための時間を大幅に減らせる 個々のモジュールのテストが行いやすい 個々のモジュールの最適化が利用者全員の恩恵となる \n- 下記のようなバグになりやすい箇所をモジュールとして吸収 プロセスの順番 競合条件をどのように避けるか プロセスはいつでも死ぬ可能性があること ホットコードローディング 名前付きプロセス Supervisor \n- プロセスの順番\n- 競合条件をどのように避けるか プロセスはいつでも死ぬ可能性があること \n- プロセスはいつでも死ぬ可能性があること\n- ホットコードローディング\n- 名前付きプロセス\n- Supervisor\n- Pros バグを解決するための時間を大幅に減らせる 個々のモジュールのテストが行いやすい 個々のモジュールの最適化が利用者全員の恩恵となる \n- バグを解決するための時間を大幅に減らせる\n- 個々のモジュールのテストが行いやすい\n- 個々のモジュールの最適化が利用者全員の恩恵となる   > 17 gen_server17 gen_server \n\n今回はよくつかわれるビヘイビア gen_server 。この汎用化によって、メンテナンス、コードの単純化、テストの簡易化へとつながる。下記に gen_server のコールバックの概要を記す。   > クライアントとサーバクライアントとサーバ \n\n- gen_server init/1 Return {ok, State} {ok, State, TimeOut} {ok, State, hibernate} {stop, Reason} ignore handle_call/3 Params Request, From, State Return {reply, Reply, NewState} {reply, Reply, NewState, Timeout} {reply, Reply, NewState, hibernate} {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, Reply, NewState} {stop, Reason, NewState} handle_cast/2 Params Message, State Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} handle_info/2 Callback case bang operator (!) TimeOut モニター通知 'EXIT' シグナル Params Message, State Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} terminate/2 Callback case handle_* 関数の返値 {stop, Reason, NewState} {stop, Reason, Reply, NewState} 親が死んで、gen_serverが終了を補足していた場合 Params Reason, State Return init/1 の反対 VMがETS (erlang term storage) を削除 code_change/3 Params PreviousVersion {down, Version} State {ok, NewState} Extra \n- init/1 Return {ok, State} {ok, State, TimeOut} {ok, State, hibernate} {stop, Reason} ignore \n- Return {ok, State} {ok, State, TimeOut} {ok, State, hibernate} {stop, Reason} ignore \n- {ok, State}\n- {ok, State, TimeOut}\n- {ok, State, hibernate}\n- {stop, Reason}\n- ignore\n- handle_call/3 Params Request, From, State Return {reply, Reply, NewState} {reply, Reply, NewState, Timeout} {reply, Reply, NewState, hibernate} {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, Reply, NewState} {stop, Reason, NewState} \n- Params Request, From, State \n- Request, From, State\n- Return {reply, Reply, NewState} {reply, Reply, NewState, Timeout} {reply, Reply, NewState, hibernate} {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, Reply, NewState} {stop, Reason, NewState} \n- {reply, Reply, NewState}\n- {reply, Reply, NewState, Timeout}\n- {reply, Reply, NewState, hibernate}\n- {noreply, NewState}\n- {noreply, NewState, Timeout}\n- {noreply, NewState, hibernate}\n- {stop, Reason, Reply, NewState}\n- {stop, Reason, NewState}\n- handle_cast/2 Params Message, State Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} \n- Params Message, State \n- Message, State\n- Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} \n- {noreply, NewState}\n- {noreply, NewState, Timeout}\n- {noreply, NewState, hibernate}\n- {stop, Reason, NewState}\n- handle_info/2 Callback case bang operator (!) TimeOut モニター通知 'EXIT' シグナル Params Message, State Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} \n- Callback case bang operator (!) TimeOut モニター通知 'EXIT' シグナル \n- bang operator (!)\n- TimeOut\n- モニター通知\n- 'EXIT' シグナル\n- Params Message, State \n- Message, State\n- Return {noreply, NewState} {noreply, NewState, Timeout} {noreply, NewState, hibernate} {stop, Reason, NewState} \n- {noreply, NewState}\n- {noreply, NewState, Timeout}\n- {noreply, NewState, hibernate}\n- {stop, Reason, NewState}\n- terminate/2 Callback case handle_* 関数の返値 {stop, Reason, NewState} {stop, Reason, Reply, NewState} 親が死んで、gen_serverが終了を補足していた場合 Params Reason, State Return init/1 の反対 VMがETS (erlang term storage) を削除 \n- Callback case handle_* 関数の返値 {stop, Reason, NewState} {stop, Reason, Reply, NewState} 親が死んで、gen_serverが終了を補足していた場合 \n- handle_* 関数の返値 {stop, Reason, NewState} {stop, Reason, Reply, NewState} \n- {stop, Reason, NewState}\n- {stop, Reason, Reply, NewState}\n- 親が死んで、gen_serverが終了を補足していた場合\n- Params Reason, State \n- Reason, State\n- Return init/1 の反対 VMがETS (erlang term storage) を削除 \n- init/1 の反対\n- VMがETS (erlang term storage) を削除\n- code_change/3 Params PreviousVersion {down, Version} State {ok, NewState} Extra \n- Params PreviousVersion {down, Version} State {ok, NewState} Extra \n- PreviousVersion {down, Version} \n- {down, Version}\n- State {ok, NewState} \n- {ok, NewState}\n- Extra   > 18 gen_fsm18 gen_fsm \n\n今回は有限ステートマシン (finite state machine)。ビヘイビア gen_fsm をとりあげる。このビヘイビアは gen_server に基本似た挙動をするが、呼び出しやメッセージ投入をあつかうのではなく同期や非同期のイベントをあつう。   > 18.1. 有限ステートマシン18.1. 有限ステートマシン \n\n- 状態遷移図 (state diagram) による記述\n- シーケンス図による記述\n- gen_fsm init/1 Return {ok, StateName, Data} {ok, StateName, Data, Timeout} {ok, StateName, Data, hibernate} {stop, Reason} StateName/2 非同期イベント Params Event, StateData Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} StateName/3 同期イベント Params Event, From, StateData Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} handle_event/3 非同期イベント、グローバルイベント Params Event, StateData Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} handle_sync_event/4 同期イベント、グローバルイベント Params Event, From, StateData Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} code_change/4 Params OldVersion, StateName, Data, Extra Return {ok, NextStateName, NewStateData} terminate/3 init/1 と逆の挙動をする \n- init/1 Return {ok, StateName, Data} {ok, StateName, Data, Timeout} {ok, StateName, Data, hibernate} {stop, Reason} \n- Return {ok, StateName, Data} {ok, StateName, Data, Timeout} {ok, StateName, Data, hibernate} {stop, Reason} \n- {ok, StateName, Data}\n- {ok, StateName, Data, Timeout}\n- {ok, StateName, Data, hibernate}\n- {stop, Reason}\n- StateName/2 非同期イベント Params Event, StateData Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} \n- 非同期イベント\n- Params Event, StateData \n- Event, StateData\n- Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} \n- {next_state, NextStateName, NewData}\n- {next_state, NextStateName, NewData, Timeout}\n- {next_state, NextStateName, hibernate}\n- {stop, Reason, Data}\n- StateName/3 同期イベント Params Event, From, StateData Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} \n- 同期イベント\n- Params Event, From, StateData \n- Event, From, StateData\n- Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} \n- {reply, Reply, NextStateName, NewStateData}\n- {reply, Reply, NextStateName, NewStateData, Timeout}\n- {reply, Reply, NextStateName, NewStateData, hibernate}\n- {next_state, NextStateName, NewStateData}\n- {next_state, NextStateName, NewStateData, Timeout}\n- {next_state, NextStateName, NewStateData, hibernate}\n- {stop, Reason, Reply, NewStateData}\n- {stop, Reason, NewStateData}\n- handle_event/3 非同期イベント、グローバルイベント Params Event, StateData Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} \n- 非同期イベント、グローバルイベント\n- Params Event, StateData \n- Event, StateData\n- Return {next_state, NextStateName, NewData} {next_state, NextStateName, NewData, Timeout} {next_state, NextStateName, hibernate} {stop, Reason, Data} \n- {next_state, NextStateName, NewData}\n- {next_state, NextStateName, NewData, Timeout}\n- {next_state, NextStateName, hibernate}\n- {stop, Reason, Data}\n- handle_sync_event/4 同期イベント、グローバルイベント Params Event, From, StateData Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} \n- 同期イベント、グローバルイベント\n- Params Event, From, StateData \n- Event, From, StateData\n- Return {reply, Reply, NextStateName, NewStateData} {reply, Reply, NextStateName, NewStateData, Timeout} {reply, Reply, NextStateName, NewStateData, hibernate} {next_state, NextStateName, NewStateData} {next_state, NextStateName, NewStateData, Timeout} {next_state, NextStateName, NewStateData, hibernate} {stop, Reason, Reply, NewStateData} {stop, Reason, NewStateData} \n- {reply, Reply, NextStateName, NewStateData}\n- {reply, Reply, NextStateName, NewStateData, Timeout}\n- {reply, Reply, NextStateName, NewStateData, hibernate}\n- {next_state, NextStateName, NewStateData}\n- {next_state, NextStateName, NewStateData, Timeout}\n- {next_state, NextStateName, NewStateData, hibernate}\n- {stop, Reason, Reply, NewStateData}\n- {stop, Reason, NewStateData}\n- code_change/4 Params OldVersion, StateName, Data, Extra Return {ok, NextStateName, NewStateData} \n- Params OldVersion, StateName, Data, Extra \n- OldVersion, StateName, Data, Extra\n- Return {ok, NextStateName, NewStateData} \n- {ok, NextStateName, NewStateData}\n- terminate/3 init/1 と逆の挙動をする \n- init/1 と逆の挙動をする\n- イベント送信関数 ローカル send_event/2 sync_send_event/2-3 グローバル send_all_state_event/2-3 sync_send_event/2-3 \n- ローカル send_event/2 sync_send_event/2-3 \n- send_event/2\n- sync_send_event/2-3\n- グローバル send_all_state_event/2-3 sync_send_event/2-3 \n- send_all_state_event/2-3\n- sync_send_event/2-3   > 18.2. ユーザー同士の取引システム例18.2. ユーザー同士の取引システム例 \n\n- \n-    > 19 gen_event19 gen_event \n\n今回はイベントハンドラ。ビヘイビアは gen_event をつかう。 \n\n- 人々（あるいは、あるプロセスやアプリケーション）にイベントが起きたことを知らせる機能の実装方法 単純出力方式 結果を出力するのみ 単純サブスクライバ方式 メッセージ送信前にサブスクライバのPidを取得 Cons コールバックのために待機プロセスが必要 イベントマネージャ方式 関数をうけとるプロセスをたて、すべてのイベントに対して当該関数をはしらせる Pros サーバのサブスクライバがたくさんあっても稼働し続けられる すべてのコールバックは同じインスタンスで操作される 短命なタスクに対して新しいプロセスを生成する必要がない Cons 関数が長時間動作する必要があった場合、お互いブロックしあう イベントマネージャをイベントフォワーダにすれば防ぐことができる 無限ループする関数はクラッシュするまで新規イベントをブロックする \n- 単純出力方式 結果を出力するのみ \n- 結果を出力するのみ\n- 単純サブスクライバ方式 メッセージ送信前にサブスクライバのPidを取得 Cons コールバックのために待機プロセスが必要 \n- メッセージ送信前にサブスクライバのPidを取得\n- Cons コールバックのために待機プロセスが必要 \n- コールバックのために待機プロセスが必要\n- イベントマネージャ方式 関数をうけとるプロセスをたて、すべてのイベントに対して当該関数をはしらせる Pros サーバのサブスクライバがたくさんあっても稼働し続けられる すべてのコールバックは同じインスタンスで操作される 短命なタスクに対して新しいプロセスを生成する必要がない Cons 関数が長時間動作する必要があった場合、お互いブロックしあう イベントマネージャをイベントフォワーダにすれば防ぐことができる 無限ループする関数はクラッシュするまで新規イベントをブロックする \n- 関数をうけとるプロセスをたて、すべてのイベントに対して当該関数をはしらせる\n- Pros サーバのサブスクライバがたくさんあっても稼働し続けられる すべてのコールバックは同じインスタンスで操作される 短命なタスクに対して新しいプロセスを生成する必要がない \n- サーバのサブスクライバがたくさんあっても稼働し続けられる\n- すべてのコールバックは同じインスタンスで操作される\n- 短命なタスクに対して新しいプロセスを生成する必要がない\n- Cons 関数が長時間動作する必要があった場合、お互いブロックしあう イベントマネージャをイベントフォワーダにすれば防ぐことができる 無限ループする関数はクラッシュするまで新規イベントをブロックする \n- 関数が長時間動作する必要があった場合、お互いブロックしあう イベントマネージャをイベントフォワーダにすれば防ぐことができる \n- イベントマネージャをイベントフォワーダにすれば防ぐことができる\n- 無限ループする関数はクラッシュするまで新規イベントをブロックする   > 19.2. 汎用イベントハンドラ gen_event19.2. 汎用イベントハンドラ gen_event  \n\n- gen_event の各関数 init/1 Response {ok, State} terminate/2 handle_event/2 非同期 すべてのイベントマネージャは戻り値を返さないことで呼び出しプロセスをブロックする Params Event, State Response {ok, NewState} gen_server:handle_cast/2 と似た動作 {ok, NewState, hibernate} {remove_handler} イベントマネージャからハンドラを削除する {swap_handler, Args1, NewState, NewHandler, Args2} 今あるイベントハンドラを削除して新しいものに置き換える notify/2 すべての流入イベントを通知する (非同期) sync_notify/2 すべての流入イベントを通知する (同期) cast/2 非同期 handle_call gen_server:handle_call コールバックに似ているがレスポンスが異なる gen_server:call/3-4 が呼び出しに使われている Response {ok, Reply, NewState} {ok, Reply, NewState, hibernate} {remove_handler, Reply} {swap_handler, Reply, Args1, NewState, Handle_Call} handle_info/2 hendle_event と同じレスポンスだが、終了シグナルや ! 演算子でイベントマネージャに贈られたメッセージのみを扱う点で異なる code_change/3 gen_server:code_change と同じ動作をする Params OldVsn バージョン番号, State ハンドラの状態, Extra Response {ok, NewState} \n- init/1 Response {ok, State} \n- Response {ok, State} \n- {ok, State}\n- terminate/2\n- handle_event/2 非同期 すべてのイベントマネージャは戻り値を返さないことで呼び出しプロセスをブロックする Params Event, State Response {ok, NewState} gen_server:handle_cast/2 と似た動作 {ok, NewState, hibernate} {remove_handler} イベントマネージャからハンドラを削除する {swap_handler, Args1, NewState, NewHandler, Args2} 今あるイベントハンドラを削除して新しいものに置き換える \n- 非同期 すべてのイベントマネージャは戻り値を返さないことで呼び出しプロセスをブロックする \n- すべてのイベントマネージャは戻り値を返さないことで呼び出しプロセスをブロックする\n- Params Event, State \n- Event, State\n- Response {ok, NewState} gen_server:handle_cast/2 と似た動作 {ok, NewState, hibernate} {remove_handler} イベントマネージャからハンドラを削除する {swap_handler, Args1, NewState, NewHandler, Args2} 今あるイベントハンドラを削除して新しいものに置き換える \n- {ok, NewState} gen_server:handle_cast/2 と似た動作 \n- gen_server:handle_cast/2 と似た動作\n- {ok, NewState, hibernate}\n- {remove_handler} イベントマネージャからハンドラを削除する \n- イベントマネージャからハンドラを削除する\n- {swap_handler, Args1, NewState, NewHandler, Args2} 今あるイベントハンドラを削除して新しいものに置き換える \n- 今あるイベントハンドラを削除して新しいものに置き換える\n- notify/2 すべての流入イベントを通知する (非同期) \n- すべての流入イベントを通知する (非同期)\n- sync_notify/2 すべての流入イベントを通知する (同期) \n- すべての流入イベントを通知する (同期)\n- cast/2 非同期 \n- 非同期\n- handle_call gen_server:handle_call コールバックに似ているがレスポンスが異なる gen_server:call/3-4 が呼び出しに使われている Response {ok, Reply, NewState} {ok, Reply, NewState, hibernate} {remove_handler, Reply} {swap_handler, Reply, Args1, NewState, Handle_Call} \n- gen_server:handle_call コールバックに似ているがレスポンスが異なる\n- gen_server:call/3-4 が呼び出しに使われている\n- Response {ok, Reply, NewState} {ok, Reply, NewState, hibernate} {remove_handler, Reply} {swap_handler, Reply, Args1, NewState, Handle_Call} \n- {ok, Reply, NewState}\n- {ok, Reply, NewState, hibernate}\n- {remove_handler, Reply}\n- {swap_handler, Reply, Args1, NewState, Handle_Call}\n- handle_info/2 hendle_event と同じレスポンスだが、終了シグナルや ! 演算子でイベントマネージャに贈られたメッセージのみを扱う点で異なる \n- hendle_event と同じレスポンスだが、終了シグナルや ! 演算子でイベントマネージャに贈られたメッセージのみを扱う点で異なる\n- code_change/3 gen_server:code_change と同じ動作をする Params OldVsn バージョン番号, State ハンドラの状態, Extra Response {ok, NewState} \n- gen_server:code_change と同じ動作をする\n- Params OldVsn バージョン番号, State ハンドラの状態, Extra \n- OldVsn バージョン番号, State ハンドラの状態, Extra\n- Response {ok, NewState} \n- {ok, NewState}   > 20 supervisor20 supervisor \n\n今回のビヘイビアはスーパバイザ supervisor。 監視戦略の概要にふれてみる。 \n\n- init/1 レスポンス {ok, { {RestartStrategy, MaxRestart, MaxTime}, [{ChildId, StartFunc, Restart, Shutdown, Type, Modules}] } }. 例 {ok, { {one_for_all, 5, 60}, [ {fake_id, {fake_mod, start_link, [SomeArg]}, permanent, 5000, worker, [fake_mod]}, {other_id, {event_manager_mod, start_link, []}, transient, infinity, worker, dynamic} ] } }. 再起動戦略 one_for_one 1つのワーカがクラッシュしたら当該ワーカを再起動する 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう one_for_all 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する 各々のワーカが互いに強く依存している場合につかう rest_for_one 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する 各々のワーカがチェーン状態に依存している場合につかう simple_one_for_one one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している 再起動制限 MaxTime 秒以内に MaxRestart 回起動したら、スーパバイザは再起動をやめて自身をシャットダウンする ワーカ (子プロセス) 構成要素 ChildId StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する Shutdown 終了期限 Type 子プロセスの種類 ワーカ スーパバイザ Modules コールバックモジュールのリスト \n- レスポンス {ok, { {RestartStrategy, MaxRestart, MaxTime}, [{ChildId, StartFunc, Restart, Shutdown, Type, Modules}] } }. 例 {ok, { {one_for_all, 5, 60}, [ {fake_id, {fake_mod, start_link, [SomeArg]}, permanent, 5000, worker, [fake_mod]}, {other_id, {event_manager_mod, start_link, []}, transient, infinity, worker, dynamic} ] } }. 再起動戦略 one_for_one 1つのワーカがクラッシュしたら当該ワーカを再起動する 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう one_for_all 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する 各々のワーカが互いに強く依存している場合につかう rest_for_one 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する 各々のワーカがチェーン状態に依存している場合につかう simple_one_for_one one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している 再起動制限 MaxTime 秒以内に MaxRestart 回起動したら、スーパバイザは再起動をやめて自身をシャットダウンする ワーカ (子プロセス) 構成要素 ChildId StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する Shutdown 終了期限 Type 子プロセスの種類 ワーカ スーパバイザ Modules コールバックモジュールのリスト \n- {ok, { {RestartStrategy, MaxRestart, MaxTime}, [{ChildId, StartFunc, Restart, Shutdown, Type, Modules}] } }. 例 {ok, { {one_for_all, 5, 60}, [ {fake_id, {fake_mod, start_link, [SomeArg]}, permanent, 5000, worker, [fake_mod]}, {other_id, {event_manager_mod, start_link, []}, transient, infinity, worker, dynamic} ] } }. 再起動戦略 one_for_one 1つのワーカがクラッシュしたら当該ワーカを再起動する 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう one_for_all 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する 各々のワーカが互いに強く依存している場合につかう rest_for_one 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する 各々のワーカがチェーン状態に依存している場合につかう simple_one_for_one one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している 再起動制限 MaxTime 秒以内に MaxRestart 回起動したら、スーパバイザは再起動をやめて自身をシャットダウンする ワーカ (子プロセス) 構成要素 ChildId StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する Shutdown 終了期限 Type 子プロセスの種類 ワーカ スーパバイザ Modules コールバックモジュールのリスト \n- 例 {ok, { {one_for_all, 5, 60}, [ {fake_id, {fake_mod, start_link, [SomeArg]}, permanent, 5000, worker, [fake_mod]}, {other_id, {event_manager_mod, start_link, []}, transient, infinity, worker, dynamic} ] } }. \n- {ok, { {one_for_all, 5, 60}, [ {fake_id, {fake_mod, start_link, [SomeArg]}, permanent, 5000, worker, [fake_mod]}, {other_id, {event_manager_mod, start_link, []}, transient, infinity, worker, dynamic} ] } }.\n- 再起動戦略 one_for_one 1つのワーカがクラッシュしたら当該ワーカを再起動する 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう one_for_all 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する 各々のワーカが互いに強く依存している場合につかう rest_for_one 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する 各々のワーカがチェーン状態に依存している場合につかう simple_one_for_one one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している \n- one_for_one 1つのワーカがクラッシュしたら当該ワーカを再起動する 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう \n- 1つのワーカがクラッシュしたら当該ワーカを再起動する\n- 各々のワーカが独立している、互いが関係していない、あるいは、ワーカが再起動して状態が消えても隣のワーカに影響を与えない場合につかう\n- one_for_all 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する 各々のワーカが互いに強く依存している場合につかう \n- 1つのワーカがクラッシュしたらすべてのワーカをクラッシュさせて再起動する\n- 各々のワーカが互いに強く依存している場合につかう\n- rest_for_one 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する 各々のワーカがチェーン状態に依存している場合につかう \n- 1つのワーカがクラッシュした当該ワーカのら子ワーカたちをクラッシュさせて再起動する\n- 各々のワーカがチェーン状態に依存している場合につかう\n- simple_one_for_one one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している \n- one_for_one はワーカのリストを起動した順で保持している一方 、simple_one_for_one はワーカへの定義を dict で保持している\n- 再起動制限 MaxTime 秒以内に MaxRestart 回起動したら、スーパバイザは再起動をやめて自身をシャットダウンする \n- MaxTime 秒以内に MaxRestart 回起動したら、スーパバイザは再起動をやめて自身をシャットダウンする\n- ワーカ (子プロセス) 構成要素 ChildId StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する Shutdown 終了期限 Type 子プロセスの種類 ワーカ スーパバイザ Modules コールバックモジュールのリスト \n- 構成要素 ChildId StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する Shutdown 終了期限 Type 子プロセスの種類 ワーカ スーパバイザ Modules コールバックモジュールのリスト \n- ChildId\n- StartFunc スーパバイザの起動方法をつたえるためのタプル {M, F, A} \n- スーパバイザの起動方法をつたえるためのタプル {M, F, A}\n- Restart 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する \n- 再起動戦略 permanent 常に再起動 temporary 再起動しない transient 正常終了の場合は再起動しない 異常終了の場合は再起動する \n- permanent 常に再起動 \n- 常に再起動\n- temporary 再起動しない \n- 再起動しない\n- transient 正常終了の場合は再起動しない 異常終了の場合は再起動する \n- 正常終了の場合は再起動しない\n- 異常終了の場合は再起動する\n- Shutdown 終了期限 \n- 終了期限\n- Type 子プロセスの種類 ワーカ スーパバイザ \n- 子プロセスの種類 ワーカ スーパバイザ \n- ワーカ\n- スーパバイザ\n- Modules コールバックモジュールのリスト \n- コールバックモジュールのリスト   > 21 プロセスプールをつくる21 プロセスプールをつくる \n\n今回はプロセスプール管理アプリケーションをOTPを使ってつくる。   > 要件要件 \n\n- サーバを最大でN個の並列接続に制限\n- アプリケーションによって開かれるファイルの数を制限\n- サブシステムに優先順位を与える\n- 不定期なアクセス負荷に対してキューにタスクを貯めることで、可用性を高める   > 実装実装 \n\n機能 \n\n- アプリケーション 起動 停止 \n- 起動\n- 停止\n- 特定のプロセスプール 起動 停止 \n- 起動\n- 停止\n- プール内のタスク プールに余裕がある場合 実行 タスクが実行されたら呼び出し元は解放 できる限りタスクを非同期に実行 プールに余裕がない場合 起動できないと告げる タスクがキューの中にある間は呼び出し元のプロセスを待たせておく タスクをキューに貯める \n- プールに余裕がある場合 実行 タスクが実行されたら呼び出し元は解放 できる限りタスクを非同期に実行 \n- 実行\n- タスクが実行されたら呼び出し元は解放\n- できる限りタスクを非同期に実行\n- プールに余裕がない場合 起動できないと告げる タスクがキューの中にある間は呼び出し元のプロセスを待たせておく タスクをキューに貯める \n- 起動できないと告げる\n- タスクがキューの中にある間は呼び出し元のプロセスを待たせておく\n- タスクをキューに貯める \n\n状態 \n\n- 静的な状態 下記から容易に取得 設定ファイル 他のプロセス アプリケーションを再起動しているスーパーバイザ \n- 下記から容易に取得 設定ファイル 他のプロセス アプリケーションを再起動しているスーパーバイザ \n- 設定ファイル\n- 他のプロセス\n- アプリケーションを再起動しているスーパーバイザ\n- 動的な状態 再計算できるデータから取得 状態の種類 初期からの状態 現在までの状態 変換すべき状態 \n- 再計算できるデータから取得\n- 状態の種類 初期からの状態 現在までの状態 変換すべき状態 \n- 初期からの状態\n- 現在までの状態\n- 変換すべき状態\n- 再計算できない動的なデータ 下記から取得 ユーザの入力 生のデータ 逐次的な外部イベント など 保存方法 データベースに登録 \n- 下記から取得 ユーザの入力 生のデータ 逐次的な外部イベント など \n- ユーザの入力\n- 生のデータ\n- 逐次的な外部イベント\n- など\n- 保存方法 データベースに登録 \n- データベースに登録    > 25 ホットコードローディング25 ホットコードローディング \n\n- 今回はホットコードローディング（更新）についてかんがえる。\n- ホットコードローディングはホットスワップの1種でElixir/Erlangの信頼性につながっている。\n- ホットコードローディングは systools により複数の appup から relup として構成されている。   > リリースの更新リリースの更新 \n\nバージョンがあがるほどリリースの更新は煩雑になっていく。 \n\n- OTPアプリケーションを書く (ver. 1.0.0) それらをリリースにする \n- それらをリリースにする\n- 1つ以上のOTPアプリケーションのバージョンを更新する (ver. 1.1.0) そのアプリケーションの古いバージョンから新しいバージョンへの遷移を行うために、何を変更すべきかを説明した appup ファイルを作成する \n- そのアプリケーションの古いバージョンから新しいバージョンへの遷移を行うために、何を変更すべきかを説明した appup ファイルを作成する\n- 新しいアプリケーションで新しいリリースを作る (ver. 1.2.0) appup ファイルをこれらのリリースから生成する 新しいアプリケーションを稼働しているErlangシェルにインストールする \n- appup ファイルをこれらのリリースから生成する\n- 新しいアプリケーションを稼働しているErlangシェルにインストールする \n\nリリース作業として以下の通り。relup 構成ツールとして、Erlangは relx 、Elixirは distillery がある。 \n\n- 巻き戻しできるようアップグレードとダウングレード双方を appup ファイルに記述\n- モジュールによるリリース構成を config ファイルに記述\n- systools:make_relup で relup を作成\n- release_hanlder によって更新   appup \n\n%% {NewVersion, %% [{VersionUpgradingFrom, [Instructions]}] %% [{VersionDownGradingTo, [Instructions]}]}. {\"1.1.0\", [{\"1.0.0\", [{add_module, pq_quest}, {load_module, pq_enemy}, {load_module, pq_events}, {update, pq_player, {advanced, []}, [pq_quest, pq_events]}]}], [{\"1.0.0\", [{update, pq_player, {advanced, []}}, {delete_module, pq_quest}, {load_module, pq_enemy}, {load_module, pq_events}]}]}. {\"1.0.1\", [{\"1.0.0\", [{load_module, sockserv_serv}]}], [{\"1.0.0\", [{load_module, sockserv_serv}]}]}.     > 27 EUnit27 EUnit \n\n- 今回は単体テストEUnitについてかんがえる。   > EUnitの特徴EUnitの特徴 \n\n- eunit:test(モジュール名, [verbose]) で実行\n- postfixがtestの関数 _test() に対してテストをおこなう\n- モジュールの内外ともにテストコードをかける\n- モジュール外に書いた場合プライベート関数に対するテストはできなくなる\n- テスト用モジュールはpostfixがtestsとなる _tests.erl    > EUnitの関数EUnitの関数 \n\n- 表現系 テスト foo_test -> ?assert(is_number(ops:add(1, 2))), ?assertEqual(4, ops:add(2, 2)). テストジェネレータ foo_test_ -> [test_them_1(), test_them_2, ?_assertError(badarith, 1/0)]. フィクスチャー setup {setup, Setup, Instantiator} {setup, Setup, Cleanup, Instantiator} {setup, Where, Setup, Instantiator} {setup, Where, Setup, Cleanup, Instantiator} foreach {foreach, Setup, [Instantiator]} {foreach, Setup, Cleanup, [Instantiator]} {foreach, Where, Setup, [Instantiator]} {foreach, Where, Setup, Cleanup, [Instantiator]} instantiator制御 {spawn, TestSet} - 並行処理 {timeout, (時間 秒), TestSet} - 時間指定処理 {inorder, TestSet} - 逐次処理 {inparallel, TestSet} - 並列処理 コメント {Comment, Fixture} \n- テスト foo_test -> ?assert(is_number(ops:add(1, 2))), ?assertEqual(4, ops:add(2, 2)). \n- foo_test -> ?assert(is_number(ops:add(1, 2))), ?assertEqual(4, ops:add(2, 2)).\n- テストジェネレータ foo_test_ -> [test_them_1(), test_them_2, ?_assertError(badarith, 1/0)]. \n- foo_test_ -> [test_them_1(), test_them_2, ?_assertError(badarith, 1/0)].\n- フィクスチャー setup {setup, Setup, Instantiator} {setup, Setup, Cleanup, Instantiator} {setup, Where, Setup, Instantiator} {setup, Where, Setup, Cleanup, Instantiator} foreach {foreach, Setup, [Instantiator]} {foreach, Setup, Cleanup, [Instantiator]} {foreach, Where, Setup, [Instantiator]} {foreach, Where, Setup, Cleanup, [Instantiator]} instantiator制御 {spawn, TestSet} - 並行処理 {timeout, (時間 秒), TestSet} - 時間指定処理 {inorder, TestSet} - 逐次処理 {inparallel, TestSet} - 並列処理 コメント {Comment, Fixture} \n- setup {setup, Setup, Instantiator} {setup, Setup, Cleanup, Instantiator} {setup, Where, Setup, Instantiator} {setup, Where, Setup, Cleanup, Instantiator} \n- {setup, Setup, Instantiator}\n- {setup, Setup, Cleanup, Instantiator}\n- {setup, Where, Setup, Instantiator}\n- {setup, Where, Setup, Cleanup, Instantiator}\n- foreach {foreach, Setup, [Instantiator]} {foreach, Setup, Cleanup, [Instantiator]} {foreach, Where, Setup, [Instantiator]} {foreach, Where, Setup, Cleanup, [Instantiator]} \n- {foreach, Setup, [Instantiator]}\n- {foreach, Setup, Cleanup, [Instantiator]}\n- {foreach, Where, Setup, [Instantiator]}\n- {foreach, Where, Setup, Cleanup, [Instantiator]}\n- instantiator制御 {spawn, TestSet} - 並行処理 {timeout, (時間 秒), TestSet} - 時間指定処理 {inorder, TestSet} - 逐次処理 {inparallel, TestSet} - 並列処理 \n- {spawn, TestSet} - 並行処理\n- {timeout, (時間 秒), TestSet} - 時間指定処理\n- {inorder, TestSet} - 逐次処理\n- {inparallel, TestSet} - 並列処理\n- コメント {Comment, Fixture} \n- {Comment, Fixture}\n- アサーション系 ?assert(expression) ?assertNot(expression) ?assertEqual(A, B) ?assertMatch(Pattern, Expression) ?assertError(Pattern, Expression) ?assertThrow(Pattern, Expression) ?assertExit(Pattern, Expression) ?assertException(Class, Pattern, Expression) \n- ?assert(expression)\n- ?assertNot(expression)\n- ?assertEqual(A, B)\n- ?assertMatch(Pattern, Expression)\n- ?assertError(Pattern, Expression)\n- ?assertThrow(Pattern, Expression)\n- ?assertExit(Pattern, Expression)\n- ?assertException(Class, Pattern, Expression) \n\nフィクスチャー (foreach) をつかったテストジェネレータ   erlang \n\n-define(setup(F), {setup, fun start/0, fun stop/1, F}). %% 関数some2について some2_test_() -> [{\"SetupData1を適切に評価できること\", {foreach, ?setup(fun (SetupData1) -> [some_instantiator1(SetupData1), some_instantiator2(SetupData1), ... some_instantiatorN(SetupData1)] end}}, {\"SetupData2を並列処理で適切に評価できること\", {foreach, ?setup(fun (SetupData2) -> {inparallel, [some_instantiator1(SetupData2), some_instantiator2(SetupData2), ... some_instantiatorN(SetupData2)]} end)}}].   \n\n並列・並行でテストする際の注意点 \n\n- 名前をa、b、cのようにハードコードすると、並列で走らせている際、名前の衝突が起きる可能性がある。可能な限り名前はハードコードせずに make_ref() によって一意の値をつかうこと。   > 28 インメモリーデータベース ETS28 インメモリーデータベース ETS   > ETSの特徴ETSの特徴 \n\n- データへの並列平行なアクセスが可能 ただし、安全性と並行性が低下する可能性がある ETSのデフォルト使用数は1400 erl -env ERL_MAX_ETS_TABLES Number で設定 \n- ただし、安全性と並行性が低下する可能性がある\n- ETSのデフォルト使用数は1400 erl -env ERL_MAX_ETS_TABLES Number で設定 \n- erl -env ERL_MAX_ETS_TABLES Number で設定   > ETSのテーブル種類ETSのテーブル種類 \n\n- set 標準 \n- 標準\n- ordered_set テーブルデータのソート機能あり ユースケース: 範囲指定してデータ取得する (ただし、アクセス時間が遅くなる O(log N)) \n- テーブルデータのソート機能あり\n- ユースケース: 範囲指定してデータ取得する (ただし、アクセス時間が遅くなる O(log N))\n- bag 同一キーのタプル（レコード）を保持可能 \n- 同一キーのタプル（レコード）を保持可能\n- duplicate_bag 同一内容のタプル（レコード）を保持可能 \n- 同一内容のタプル（レコード）を保持可能\n- 共通機能 テーブル所有権 ETSテーブル起動関数であらたにコールしたプロセスがそのテーブルの所有者 権限 protected level 所有者 read, write その他 read public level 所有者 read, write その他 read, write private level 所有者 read, write その他 n/a テーブルの移譲 ETSテーブルはプロセスが死ぬと消滅する 移譲の種類 都度指定する移譲 プロセスが死んだ場合の自動移譲 \n- テーブル所有権 ETSテーブル起動関数であらたにコールしたプロセスがそのテーブルの所有者 権限 protected level 所有者 read, write その他 read public level 所有者 read, write その他 read, write private level 所有者 read, write その他 n/a \n- ETSテーブル起動関数であらたにコールしたプロセスがそのテーブルの所有者\n- 権限 protected level 所有者 read, write その他 read public level 所有者 read, write その他 read, write private level 所有者 read, write その他 n/a \n- protected level 所有者 read, write その他 read \n- 所有者 read, write\n- その他 read\n- public level 所有者 read, write その他 read, write \n- 所有者 read, write\n- その他 read, write\n- private level 所有者 read, write その他 n/a \n- 所有者 read, write\n- その他 n/a\n- テーブルの移譲 ETSテーブルはプロセスが死ぬと消滅する 移譲の種類 都度指定する移譲 プロセスが死んだ場合の自動移譲 \n- ETSテーブルはプロセスが死ぬと消滅する\n- 移譲の種類 都度指定する移譲 プロセスが死んだ場合の自動移譲 \n- 都度指定する移譲\n- プロセスが死んだ場合の自動移譲   > ETSの関数ETSの関数 \n\n- テーブル作成・削除 ets:new/2 \n- ets:new/2\n- データ挿入・参照 ets:insert(Table, ObjectOrObjects) ets:lookup(Table, Key) \n- ets:insert(Table, ObjectOrObjects)\n- ets:lookup(Table, Key)\n- その他 ets:delete(Table, Key) ets:match(Table, MatchClause) ets:match_object(Table, MatchClause) ets:fun2ms(MatchSpecClause) \n- ets:delete(Table, Key)\n- ets:match(Table, MatchClause)\n- ets:match_object(Table, MatchClause)\n- ets:fun2ms(MatchSpecClause) \n\nsetテーブルでnamed_tableオプションをつける場合   erlang \n\n21> ets:new(ingredients, [set, named_table]). ingredients 22> ets:insert(ingredients, {bacon, great}). true 23> ets:lookup(ingredients, bacon). [{bacon,great}] 24> ets:insert(ingredients, [{bacon, awesome}, {cabbage, alright}]). true 25> ets:lookup(ingredients, bacon). [{bacon,awesome}] 26> ets:lookup(ingredients, cabbage). [{cabbage,alright}] 27> ets:delete(ingredients, cabbage). true 28> ets:delete(ingredients, cabbage). true 29> ets:lookup(ingredients, cabbage). [] 32> ets:insert_new(ingredients, {tomato, hey}). true 33> ets:insert_new(ingredients, {tomato, hey}). false   \n\nbagテーブルでnamed_tableオプションをつけない場合   erlang \n\n34> TabId = ets:new(ingredients, [bag]). 16401 35> ets:insert(TabId, {bacon, delicious}). true 36> ets:insert(TabId, {bacon, fat}). true 37> ets:insert(TabId, {bacon, fat}). true 38> ets:lookup(TabId, bacon). [{bacon,delicious},{bacon,fat}]   \n\nordered_setターブルで、named_tableオプションをつける場合   erlang \n\n42> ets:new(ingredients, [ordered_set, named_table]). ingredients 43> ets:insert(ingredients, [{ketchup, \"not much\"}, {mustard, \"a lot\"}, {cheese, \"yes\", \"goat\"}, {patty, \"moose\"}, {onions, \"a lot\", \"caramelized\"}]). true 44> Res1 = ets:first(ingredients). cheese 45> Res2 = ets:next(ingredients, Res1). ketchup 46> Res3 = ets:next(ingredients, Res2). mustard 47> ets:last(ingredients). patty 48> ets:prev(ingredients, ets:last(ingredients)). onions   \n\nnamed_tableオプションつきbagテーブルでパターンマッチをする   erlang \n\n53> ets:new(table, [named_table, bag]). table 54> ets:insert(table, [{items, a, b, c, d}, {items, a, b, c, a}, {cat, brown, soft, loveable, selfish}, {friends, [jem, jeff, etc]}, {items, 1, 2, 3, 1}]). true 55> ets:match(table, {items, '$1', '$2', '_', '$1'}). [[a,b],[1,2]] 56> ets:match(table, {items, '$114', '$212', '_', '$6'}). [[d,a,b],[a,a,b],[1,1,2]] 57> ets:match_object(table, {items, '$1', '$2', '_', '$1'}). [{items,a,b,c,a},{items,1,2,3,1}] 58> ets:delete(table). true     > 29 分散システム EPMD29 分散システム EPMD \n\n- 今回は分散システム Erlang Port Mapper Daemon (EPMD) についてかんがえる。今回の章がSLAにもっとも関係しているといえそうである。ほかの言語・フレームワークが「分散コンピューティングの落とし穴」「CAP定理」にどのように対応している比較すると、Erlangの特徴がより見えてくるだろう。   > 分散システムEPMDの特徴分散システムEPMDの特徴 \n\n前提 \n\n- 分散システムによるFault toleranceについて ソフトウェアの稼働状況と対ハードウェア障害リスク マシン1台 リスク対策できない マシン複数台 アプリケーションが正しく構築されない場合、リスク対策できない \n- ソフトウェアの稼働状況と対ハードウェア障害リスク マシン1台 リスク対策できない マシン複数台 アプリケーションが正しく構築されない場合、リスク対策できない \n- マシン1台 リスク対策できない \n- リスク対策できない\n- マシン複数台 アプリケーションが正しく構築されない場合、リスク対策できない \n- アプリケーションが正しく構築されない場合、リスク対策できない\n- 「分散コンピューティングの落とし穴」へのErlangの対応 ネットワークは信頼できる Erlangの対応 非同期通信モード（リンクやモニタ）により、メッセージを送信に正常な場合に必ず返信するように設計 ただし、ノード間でリンクやモニタを張った際にネットワーク障害起きた場合、リンクやモニタが一斉にトリガーされシステムに予期しない負荷をかけることになる レイテンシはゼロである Erlangの対応 タイムアウト、リンク、モニタ、非同期パターンにより遅延を想定し設計 帯域幅は無限である Erlangの対応 大きなメッセージを送らない ネットワークはセキュアである Erlangの対応 Erlangはネットワークの安全性を確認しないため 異なるデータセンター間で自動的にクラスタ化しない あるいは、SSLに切り替える 安全なチャンネル越しにトンネルする ノード間の通信プロトコルを再実装する ネットワーク構成は変化せず一定である Erlangの対応 アプリケーションでネットワーク構成（トポロジー）を管理しない 管理者は1人である Erlangの対応 デバッグツールによる個別障害対応 ノード監視ツールによるシステム運用状況の共有 実装プロトコルやAPIのバージョン管理 転送コストはゼロである Erlangの対応 Erlangはほかのノードに渡されるメッセージを圧縮しないため 送るメッセージを小さくする あるいは、独自の通信レイヤを実装する ネットワークは均質である Erlangの対応 Erlangノードと同じプロトコル形式にして通信 Cノード BERT BERT-RPC \n- ネットワークは信頼できる Erlangの対応 非同期通信モード（リンクやモニタ）により、メッセージを送信に正常な場合に必ず返信するように設計 ただし、ノード間でリンクやモニタを張った際にネットワーク障害起きた場合、リンクやモニタが一斉にトリガーされシステムに予期しない負荷をかけることになる \n- Erlangの対応 非同期通信モード（リンクやモニタ）により、メッセージを送信に正常な場合に必ず返信するように設計 ただし、ノード間でリンクやモニタを張った際にネットワーク障害起きた場合、リンクやモニタが一斉にトリガーされシステムに予期しない負荷をかけることになる \n- 非同期通信モード（リンクやモニタ）により、メッセージを送信に正常な場合に必ず返信するように設計\n- ただし、ノード間でリンクやモニタを張った際にネットワーク障害起きた場合、リンクやモニタが一斉にトリガーされシステムに予期しない負荷をかけることになる\n- レイテンシはゼロである Erlangの対応 タイムアウト、リンク、モニタ、非同期パターンにより遅延を想定し設計 \n- Erlangの対応 タイムアウト、リンク、モニタ、非同期パターンにより遅延を想定し設計 \n- タイムアウト、リンク、モニタ、非同期パターンにより遅延を想定し設計\n- 帯域幅は無限である Erlangの対応 大きなメッセージを送らない \n- Erlangの対応 大きなメッセージを送らない \n- 大きなメッセージを送らない\n- ネットワークはセキュアである Erlangの対応 Erlangはネットワークの安全性を確認しないため 異なるデータセンター間で自動的にクラスタ化しない あるいは、SSLに切り替える 安全なチャンネル越しにトンネルする ノード間の通信プロトコルを再実装する \n- Erlangの対応 Erlangはネットワークの安全性を確認しないため 異なるデータセンター間で自動的にクラスタ化しない あるいは、SSLに切り替える 安全なチャンネル越しにトンネルする ノード間の通信プロトコルを再実装する \n- Erlangはネットワークの安全性を確認しないため 異なるデータセンター間で自動的にクラスタ化しない あるいは、SSLに切り替える 安全なチャンネル越しにトンネルする ノード間の通信プロトコルを再実装する \n- 異なるデータセンター間で自動的にクラスタ化しない\n- あるいは、SSLに切り替える\n- 安全なチャンネル越しにトンネルする\n- ノード間の通信プロトコルを再実装する\n- ネットワーク構成は変化せず一定である Erlangの対応 アプリケーションでネットワーク構成（トポロジー）を管理しない \n- Erlangの対応 アプリケーションでネットワーク構成（トポロジー）を管理しない \n- アプリケーションでネットワーク構成（トポロジー）を管理しない\n- 管理者は1人である Erlangの対応 デバッグツールによる個別障害対応 ノード監視ツールによるシステム運用状況の共有 実装プロトコルやAPIのバージョン管理 \n- Erlangの対応 デバッグツールによる個別障害対応 ノード監視ツールによるシステム運用状況の共有 実装プロトコルやAPIのバージョン管理 \n- デバッグツールによる個別障害対応\n- ノード監視ツールによるシステム運用状況の共有\n- 実装プロトコルやAPIのバージョン管理\n- 転送コストはゼロである Erlangの対応 Erlangはほかのノードに渡されるメッセージを圧縮しないため 送るメッセージを小さくする あるいは、独自の通信レイヤを実装する \n- Erlangの対応 Erlangはほかのノードに渡されるメッセージを圧縮しないため 送るメッセージを小さくする あるいは、独自の通信レイヤを実装する \n- Erlangはほかのノードに渡されるメッセージを圧縮しないため 送るメッセージを小さくする あるいは、独自の通信レイヤを実装する \n- 送るメッセージを小さくする\n- あるいは、独自の通信レイヤを実装する\n- ネットワークは均質である Erlangの対応 Erlangノードと同じプロトコル形式にして通信 Cノード BERT BERT-RPC \n- Erlangの対応 Erlangノードと同じプロトコル形式にして通信 Cノード BERT BERT-RPC \n- Erlangノードと同じプロトコル形式にして通信 Cノード BERT BERT-RPC \n- Cノード\n- BERT\n- BERT-RPC\n- 障害（ノードの応答不能）への対応 下記の中から原因を特定するが確実には対応できない ハードウェア障害 アプリケーションクラッシュ ネットワーク分断 輻輳 遮断 ゾンビ化するということ ネットワーク分断が起きている間アプリケーションが生きていた場合 当該ノードで保持していたデータがクラスタ間で保持していたデータと整合性がとれず、欠損扱いになる（一貫性の欠如） 当該ノードからレスポンスが返ってこないため生きているか死んでいるかわからない（可用性の欠如） CAP（Consistency, Availability, Partition Tolerance）定理 ノード間において、同時に下記3つの要素を保証することはできない 一貫性 Consistency すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらかを受け取れること 可用性 Availability システム要求に応答できること（SPOFがない） 分断耐性 Partition tolerance ネットワーク分断時でもシステムを継続して運用できること 組合せ、採用条件、採用ケース CA 採用条件 ネットワークが絶対に落ちない場合 ネットワークが1つの塊として動作している場合 データの読み書きが多い場合 採用ケース RDBMS NFS AP 採用条件 ネットワーク分断が起きやすい場合 SPOFがない場合 ネットワーク分断時データ変更不可だと問題がある場合 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 採用ケース Amazon SimpleDB Apache Cassandra DNS HTTPキャッシュ CP 採用条件 ネットワーク分断が起きやすい場合 SPOFがある場合 ネットワーク分断時データ変更不可でも問題ない場合 採用ケース Mnesia Apache HBase \n- 下記の中から原因を特定するが確実には対応できない ハードウェア障害 アプリケーションクラッシュ ネットワーク分断 輻輳 遮断 \n- ハードウェア障害\n- アプリケーションクラッシュ\n- ネットワーク分断 輻輳 遮断 \n- 輻輳\n- 遮断\n- ゾンビ化するということ ネットワーク分断が起きている間アプリケーションが生きていた場合 当該ノードで保持していたデータがクラスタ間で保持していたデータと整合性がとれず、欠損扱いになる（一貫性の欠如） 当該ノードからレスポンスが返ってこないため生きているか死んでいるかわからない（可用性の欠如） \n- ネットワーク分断が起きている間アプリケーションが生きていた場合 当該ノードで保持していたデータがクラスタ間で保持していたデータと整合性がとれず、欠損扱いになる（一貫性の欠如） 当該ノードからレスポンスが返ってこないため生きているか死んでいるかわからない（可用性の欠如） \n- 当該ノードで保持していたデータがクラスタ間で保持していたデータと整合性がとれず、欠損扱いになる（一貫性の欠如）\n- 当該ノードからレスポンスが返ってこないため生きているか死んでいるかわからない（可用性の欠如）\n- CAP（Consistency, Availability, Partition Tolerance）定理 ノード間において、同時に下記3つの要素を保証することはできない 一貫性 Consistency すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらかを受け取れること 可用性 Availability システム要求に応答できること（SPOFがない） 分断耐性 Partition tolerance ネットワーク分断時でもシステムを継続して運用できること 組合せ、採用条件、採用ケース CA 採用条件 ネットワークが絶対に落ちない場合 ネットワークが1つの塊として動作している場合 データの読み書きが多い場合 採用ケース RDBMS NFS AP 採用条件 ネットワーク分断が起きやすい場合 SPOFがない場合 ネットワーク分断時データ変更不可だと問題がある場合 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 採用ケース Amazon SimpleDB Apache Cassandra DNS HTTPキャッシュ CP 採用条件 ネットワーク分断が起きやすい場合 SPOFがある場合 ネットワーク分断時データ変更不可でも問題ない場合 採用ケース Mnesia Apache HBase \n- ノード間において、同時に下記3つの要素を保証することはできない 一貫性 Consistency すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらかを受け取れること 可用性 Availability システム要求に応答できること（SPOFがない） 分断耐性 Partition tolerance ネットワーク分断時でもシステムを継続して運用できること \n- 一貫性 Consistency すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらかを受け取れること \n- すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらかを受け取れること\n- 可用性 Availability システム要求に応答できること（SPOFがない） \n- システム要求に応答できること（SPOFがない）\n- 分断耐性 Partition tolerance ネットワーク分断時でもシステムを継続して運用できること \n- ネットワーク分断時でもシステムを継続して運用できること\n- 組合せ、採用条件、採用ケース CA 採用条件 ネットワークが絶対に落ちない場合 ネットワークが1つの塊として動作している場合 データの読み書きが多い場合 採用ケース RDBMS NFS AP 採用条件 ネットワーク分断が起きやすい場合 SPOFがない場合 ネットワーク分断時データ変更不可だと問題がある場合 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 採用ケース Amazon SimpleDB Apache Cassandra DNS HTTPキャッシュ CP 採用条件 ネットワーク分断が起きやすい場合 SPOFがある場合 ネットワーク分断時データ変更不可でも問題ない場合 採用ケース Mnesia Apache HBase \n- CA 採用条件 ネットワークが絶対に落ちない場合 ネットワークが1つの塊として動作している場合 データの読み書きが多い場合 採用ケース RDBMS NFS \n- 採用条件 ネットワークが絶対に落ちない場合 ネットワークが1つの塊として動作している場合 データの読み書きが多い場合 \n- ネットワークが絶対に落ちない場合\n- ネットワークが1つの塊として動作している場合\n- データの読み書きが多い場合\n- 採用ケース RDBMS NFS \n- RDBMS\n- NFS\n- AP 採用条件 ネットワーク分断が起きやすい場合 SPOFがない場合 ネットワーク分断時データ変更不可だと問題がある場合 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 採用ケース Amazon SimpleDB Apache Cassandra DNS HTTPキャッシュ \n- 採用条件 ネットワーク分断が起きやすい場合 SPOFがない場合 ネットワーク分断時データ変更不可だと問題がある場合 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 \n- ネットワーク分断が起きやすい場合\n- SPOFがない場合\n- ネットワーク分断時データ変更不可だと問題がある場合\n- 結果整合性を適用可能な場合 時間ベース 個別にコンフリクト解消 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 \n- 時間ベース\n- 個別にコンフリクト解消\n- 全ノードによる合意 合意割合による調整 問い合わせ対象による調整 \n- 合意割合による調整\n- 問い合わせ対象による調整\n- 採用ケース Amazon SimpleDB Apache Cassandra DNS HTTPキャッシュ \n- Amazon SimpleDB\n- Apache Cassandra\n- DNS\n- HTTPキャッシュ\n- CP 採用条件 ネットワーク分断が起きやすい場合 SPOFがある場合 ネットワーク分断時データ変更不可でも問題ない場合 採用ケース Mnesia Apache HBase \n- 採用条件 ネットワーク分断が起きやすい場合 SPOFがある場合 ネットワーク分断時データ変更不可でも問題ない場合 \n- ネットワーク分断が起きやすい場合\n- SPOFがある場合\n- ネットワーク分断時データ変更不可でも問題ない場合\n- 採用ケース Mnesia Apache HBase \n- Mnesia\n- Apache HBase \n\nErlangが提供する道具 \n\n- ノードとEPMD 特徴 ノードとはErlang VMのインスタンスのこと 各ノードはEPMDに接続されている 新しいノードは自動的にErlangクラスタに接続され、各ノードに接続される 接続されているノードでも完全に独立している 各ノードが固有に保持しているもの プロセスレジストリ ETSテーブル 読み込んだモジュール EPMDはErlangクラスタの一部として、各コンピューター上で稼働する EPMDは名前サーバとして機能する Pros Fault tolerance Cons 1ノードにつき1エフェメラルポートが必要になるため、Scalingに制限がある 対処として、ノードのグループを小さなクラスタに分割 \n- 特徴 ノードとはErlang VMのインスタンスのこと 各ノードはEPMDに接続されている 新しいノードは自動的にErlangクラスタに接続され、各ノードに接続される 接続されているノードでも完全に独立している 各ノードが固有に保持しているもの プロセスレジストリ ETSテーブル 読み込んだモジュール EPMDはErlangクラスタの一部として、各コンピューター上で稼働する EPMDは名前サーバとして機能する \n- ノードとはErlang VMのインスタンスのこと\n- 各ノードはEPMDに接続されている 新しいノードは自動的にErlangクラスタに接続され、各ノードに接続される \n- 新しいノードは自動的にErlangクラスタに接続され、各ノードに接続される\n- 接続されているノードでも完全に独立している 各ノードが固有に保持しているもの プロセスレジストリ ETSテーブル 読み込んだモジュール \n- 各ノードが固有に保持しているもの プロセスレジストリ ETSテーブル 読み込んだモジュール \n- プロセスレジストリ\n- ETSテーブル\n- 読み込んだモジュール\n- EPMDはErlangクラスタの一部として、各コンピューター上で稼働する\n- EPMDは名前サーバとして機能する\n- Pros Fault tolerance \n- Fault tolerance\n- Cons 1ノードにつき1エフェメラルポートが必要になるため、Scalingに制限がある 対処として、ノードのグループを小さなクラスタに分割 \n- 1ノードにつき1エフェメラルポートが必要になるため、Scalingに制限がある 対処として、ノードのグループを小さなクラスタに分割 \n- 対処として、ノードのグループを小さなクラスタに分割\n- シリアライズ、デシリアライズ\n- マルチプロセス\n- ネットワークの障害監視 \n\nErlangクラスタを設定する \n\n- ノードの名前解決 長い名前 aaa.bbb.cccのような完全修飾ドメイン名 DNSリゾルバによって解決 erl -name LongName 短い名前 ピリオドがないホスト名 ホストファイルやDNSエントリによって解決 erl -sname ShortName 注意点 1台のコンピューター上でErlangノードを設定する際は通常短い名前をつかう 長い名前と短い名前、双方でのやり取りはできない \n- 長い名前 aaa.bbb.cccのような完全修飾ドメイン名 DNSリゾルバによって解決 erl -name LongName \n- aaa.bbb.cccのような完全修飾ドメイン名\n- DNSリゾルバによって解決\n- erl -name LongName\n- 短い名前 ピリオドがないホスト名 ホストファイルやDNSエントリによって解決 erl -sname ShortName \n- ピリオドがないホスト名\n- ホストファイルやDNSエントリによって解決\n- erl -sname ShortName\n- 注意点 1台のコンピューター上でErlangノードを設定する際は通常短い名前をつかう 長い名前と短い名前、双方でのやり取りはできない \n- 1台のコンピューター上でErlangノードを設定する際は通常短い名前をつかう\n- 長い名前と短い名前、双方でのやり取りはできない\n- 関数 net_kernel:connect_node/1 - ノード接続 ノード名参照 node/0 - 現在のノード名を参照 nodes/0 - 接続ノード参照 リンクとモニタ link - ノードをまたいだリンク erlang:monitor/2 - ノードをまたいだモニタ（ネットワーク分断時に一斉に活性化し負荷が増加する可能性あり） erlang:monitor_node/2 - ノードを指定したモニタ 遠隔操作 spawn/2 spawn/4 spawn_link/2 spawn_link/4 \n- net_kernel:connect_node/1 - ノード接続\n- ノード名参照 node/0 - 現在のノード名を参照 nodes/0 - 接続ノード参照 \n- node/0 - 現在のノード名を参照\n- nodes/0 - 接続ノード参照\n- リンクとモニタ link - ノードをまたいだリンク erlang:monitor/2 - ノードをまたいだモニタ（ネットワーク分断時に一斉に活性化し負荷が増加する可能性あり） erlang:monitor_node/2 - ノードを指定したモニタ \n- link - ノードをまたいだリンク\n- erlang:monitor/2 - ノードをまたいだモニタ（ネットワーク分断時に一斉に活性化し負荷が増加する可能性あり）\n- erlang:monitor_node/2 - ノードを指定したモニタ\n- 遠隔操作 spawn/2 spawn/4 spawn_link/2 spawn_link/4 \n- spawn/2\n- spawn/4\n- spawn_link/2\n- spawn_link/4\n- クラスタのUIDトークンとしてのCookie 関数 erl -sname ShortName -setcookie CookieName erlang:get_cookei/0 erlang:set_cookei/2 \n- 関数 erl -sname ShortName -setcookie CookieName erlang:get_cookei/0 erlang:set_cookei/2 \n- erl -sname ShortName -setcookie CookieName\n- erlang:get_cookei/0\n- erlang:set_cookei/2\n- 隠しノード クラスタを介してノード接続すると、クラスタ間で予期しないメッセージ通信がおこなわれる可能性があるため、それを防止する策としてクラスタを介さず接続可能な隠しノード機能がある 関数 erlang:send(Dest, Message, [noconnect]) - クラスタを介さずにノードに接続 erl -sname ShortName -hidden - クラスタを介さずに隠しノードに接続 nodes(hidden) - 隠しノードを参照 \n- クラスタを介してノード接続すると、クラスタ間で予期しないメッセージ通信がおこなわれる可能性があるため、それを防止する策としてクラスタを介さず接続可能な隠しノード機能がある\n- 関数 erlang:send(Dest, Message, [noconnect]) - クラスタを介さずにノードに接続 erl -sname ShortName -hidden - クラスタを介さずに隠しノードに接続 nodes(hidden) - 隠しノードを参照 \n- erlang:send(Dest, Message, [noconnect]) - クラスタを介さずにノードに接続\n- erl -sname ShortName -hidden - クラスタを介さずに隠しノードに接続\n- nodes(hidden) - 隠しノードを参照\n- ポート範囲指定 EPMDのポート番号は 4369 設定方法 erl -name LongName -kernel inet_dist_listen_min 9100 -kernel inet_dist_listen_max 9115 erl -name LongName -config ports ports.config: [{kernel, [{inet_dist_listen_min, 9100}, {inet_dist_listen_max, 9115}]}]. \n- EPMDのポート番号は 4369 \n- 設定方法 erl -name LongName -kernel inet_dist_listen_min 9100 -kernel inet_dist_listen_max 9115 erl -name LongName -config ports ports.config: [{kernel, [{inet_dist_listen_min, 9100}, {inet_dist_listen_max, 9115}]}]. \n- erl -name LongName -kernel inet_dist_listen_min 9100 -kernel inet_dist_listen_max 9115\n- erl -name LongName -config ports ports.config: [{kernel, [{inet_dist_listen_min, 9100}, {inet_dist_listen_max, 9115}]}]. \n- ports.config: [{kernel, [{inet_dist_listen_min, 9100}, {inet_dist_listen_max, 9115}]}]. \n- 分散用モジュール net_kernel start([Name, Type, HeartbeatInMilliseconds]) - インスタンスを一時的にノード化 set_net_ticktime(Milliseconds) - Ticktime（ハートビートを4倍した時間、ノードの死亡判定時間）を設定変更 global - プロセスレジストリの代替 register_name(Name, Pid) - gloabl登録し名前変更 unregister_name(Name, Pid) - globalから名前解除 re_register_name(Name, Pid) - 参照先の喪失を防ぎながらglobal登録し名前変更 whereis_name(Name) - PID探索 send(Name, Message) - メッセージ送信 random_exit_name/3 - ランダムにプロセスをkillする random_notify_name/3 - 2つのプロセスのうちいかすプロセスをランダムに1つ選び、globalから解除されるプロセスに {global_name_conflict, Name} というメッセージを送信 notify_all_name/3 - 指定したPIDプロセスをglobalから解除し、 {global_name_conflict, Name, OtherPid} というメッセージを送信、コンフリクト解消を促す rpc call(Node, Module, Function, Args[, Timout]) async_call(Node, Mod, Fun, Args[, Timout]) yield(AsyncPid) nb_yield(AsyncPid[, Timeout]) - ポーリング、ロングポーリング cast(Node, Mod, Fun, Args) - 返値なしのコール multicall(Nodes, Mod, Fun, Args) - 複数ノードへのコール eval_everywhere(Nodes, Mod, Fun, Args) - 複数ノードへの命令（コールとほぼ同じ） \n- net_kernel start([Name, Type, HeartbeatInMilliseconds]) - インスタンスを一時的にノード化 set_net_ticktime(Milliseconds) - Ticktime（ハートビートを4倍した時間、ノードの死亡判定時間）を設定変更 \n- start([Name, Type, HeartbeatInMilliseconds]) - インスタンスを一時的にノード化\n- set_net_ticktime(Milliseconds) - Ticktime（ハートビートを4倍した時間、ノードの死亡判定時間）を設定変更\n- global - プロセスレジストリの代替 register_name(Name, Pid) - gloabl登録し名前変更 unregister_name(Name, Pid) - globalから名前解除 re_register_name(Name, Pid) - 参照先の喪失を防ぎながらglobal登録し名前変更 whereis_name(Name) - PID探索 send(Name, Message) - メッセージ送信 random_exit_name/3 - ランダムにプロセスをkillする random_notify_name/3 - 2つのプロセスのうちいかすプロセスをランダムに1つ選び、globalから解除されるプロセスに {global_name_conflict, Name} というメッセージを送信 notify_all_name/3 - 指定したPIDプロセスをglobalから解除し、 {global_name_conflict, Name, OtherPid} というメッセージを送信、コンフリクト解消を促す \n- register_name(Name, Pid) - gloabl登録し名前変更\n- unregister_name(Name, Pid) - globalから名前解除\n- re_register_name(Name, Pid) - 参照先の喪失を防ぎながらglobal登録し名前変更\n- whereis_name(Name) - PID探索\n- send(Name, Message) - メッセージ送信\n- random_exit_name/3 - ランダムにプロセスをkillする\n- random_notify_name/3 - 2つのプロセスのうちいかすプロセスをランダムに1つ選び、globalから解除されるプロセスに {global_name_conflict, Name} というメッセージを送信\n- notify_all_name/3 - 指定したPIDプロセスをglobalから解除し、 {global_name_conflict, Name, OtherPid} というメッセージを送信、コンフリクト解消を促す\n- rpc call(Node, Module, Function, Args[, Timout]) async_call(Node, Mod, Fun, Args[, Timout]) yield(AsyncPid) nb_yield(AsyncPid[, Timeout]) - ポーリング、ロングポーリング cast(Node, Mod, Fun, Args) - 返値なしのコール multicall(Nodes, Mod, Fun, Args) - 複数ノードへのコール eval_everywhere(Nodes, Mod, Fun, Args) - 複数ノードへの命令（コールとほぼ同じ） \n- call(Node, Module, Function, Args[, Timout])\n- async_call(Node, Mod, Fun, Args[, Timout])\n- yield(AsyncPid)\n- nb_yield(AsyncPid[, Timeout]) - ポーリング、ロングポーリング\n- cast(Node, Mod, Fun, Args) - 返値なしのコール\n- multicall(Nodes, Mod, Fun, Args) - 複数ノードへのコール\n- eval_everywhere(Nodes, Mod, Fun, Args) - 複数ノードへの命令（コールとほぼ同じ）   > 30 分散OTP30 分散OTP \n\n- 前回の分散の章でnine ninesのなぞが見えてきた。今回はそれを補完する分散OTPについてかんがえる。   > 分散アプリケーションの特徴分散アプリケーションの特徴 \n\n構成 \n\n- 標準アプリケーション アプリケーションコントローラ（ノード） アプリケーションマスタ スーパーバイザ \n- アプリケーションコントローラ（ノード） アプリケーションマスタ スーパーバイザ \n- アプリケーションマスタ スーパーバイザ \n- スーパーバイザ\n- 分散アプリケーション アプリケーションコントローラ（ノード） アプリケーションマスタ スーパーバイザ \n- アプリケーションコントローラ（ノード） アプリケーションマスタ スーパーバイザ \n- アプリケーションマスタ スーパーバイザ \n- スーパーバイザ \n\nライフサイクル \n\n- 標準アプリケーション 1. 読込中2. 起動中3. 停止中4. 解放中 \n- 分散アプリケーション 1. 読込中2. 起動中 稼働中の分散ノードが死んだら稼働中ステータスに移行 3. 稼働中の分散ノードが死んだら稼働中ステータスに移行4. 稼働中 稼働中ステータスは1つのノードのみ 5. 稼働中ステータスは1つのノードのみ6. 停止中7. 解放中  \n\n再起動戦略 \n\n- 特徴 ハードウェア障害を前提にしたCAシステムでよくとられます ネットワーク分断を前提にしたCPシステムの場合は採用を熟慮すること \n- ハードウェア障害を前提にしたCAシステムでよくとられます\n- ネットワーク分断を前提にしたCPシステムの場合は採用を熟慮すること\n- 2つの戦略 フェイルオーバー アプリケーション停止後、別の場所で再起動する戦略 メインとバックアップを入れ替える方法 複数台サーバを立ち上げて相互に負荷を補完しあう方法 テイクオーバー アプリケーション復活後、バックアップからメインに移行する戦略 \n- フェイルオーバー アプリケーション停止後、別の場所で再起動する戦略 メインとバックアップを入れ替える方法 複数台サーバを立ち上げて相互に負荷を補完しあう方法 \n- アプリケーション停止後、別の場所で再起動する戦略 メインとバックアップを入れ替える方法 複数台サーバを立ち上げて相互に負荷を補完しあう方法 \n- メインとバックアップを入れ替える方法\n- 複数台サーバを立ち上げて相互に負荷を補完しあう方法\n- テイクオーバー アプリケーション復活後、バックアップからメインに移行する戦略 \n- アプリケーション復活後、バックアップからメインに移行する戦略   > 32 Mnesia32 Mnesia   > Mnesiaの特徴Mnesiaの特徴 \n\n- Pros CPシステム（NoSQL） トランザクション機能 (ACID) ネットワーク分断につよい ただし、10ノード前後が実用上の限界と考えられている \n- CPシステム（NoSQL） トランザクション機能 (ACID) ネットワーク分断につよい ただし、10ノード前後が実用上の限界と考えられている \n- トランザクション機能 (ACID)\n- ネットワーク分断につよい ただし、10ノード前後が実用上の限界と考えられている \n- ただし、10ノード前後が実用上の限界と考えられている\n- Cons 各テーブルにつき2Gの容量制限 Table Frangmentation機能で回避可能 厳密なシステム要求に応答することはむずかしい 数テラバイトの大きなデータをあつかうのに向いていない 組込型制限がない \n- 各テーブルにつき2Gの容量制限 Table Frangmentation機能で回避可能 \n- Table Frangmentation機能で回避可能\n- 厳密なシステム要求に応答することはむずかしい\n- 数テラバイトの大きなデータをあつかうのに向いていない\n- 組込型制限がない \n\n適切なユースケース \n\n- 下記条件をみたした場合 ノード数、データ量双方を見積もることが可能 ETS/DETS（タプル）形式でアクセス可能 \n- ノード数、データ量双方を見積もることが可能\n- ETS/DETS（タプル）形式でアクセス可能 \n\nテーブルオプション \n\n- 保存方法 ram_copies - データをETS（メモリ）にのみ保存、32ビットマシンで4Gの容量制限 disc_only_copies - データをDETSにのみ保存、2Gの容量制限 disc_copies - データをETSとDETS双方に保存、DETSの2G容量制限はない、通常はこちらはつかう \n- ram_copies - データをETS（メモリ）にのみ保存、32ビットマシンで4Gの容量制限\n- disc_only_copies - データをDETSにのみ保存、2Gの容量制限\n- disc_copies - データをETSとDETS双方に保存、DETSの2G容量制限はない、通常はこちらはつかう\n- テーブル種類 set bag ordered_set \n- set\n- bag\n- ordered_set \n\nCLI \n\n- erl -name LongName -mnesia dir path/to/db - dir 変数でスキーマ保存場所を指定 \n\n関数 \n\n- mnesia create_schema(ListOfNodes) create_table(TableName, Option) オプション {attributes, List} - テーブルのカラム名 {disc_copies, NodeList} {disc_only_copies, NodeList} {ram_copies, NodeList} - テーブルの保存場所 {index, ListOfIntegers} - インデックスをはる {record_name, Atom} - テーブルの別名（非推奨） {type, Type} - テーブル種類 (set, ordered_set, bag) {local_content, Boolean} - デフォルト false。true にすると、多数のノード上に共有されない固有のローカルテーブルを作成する wait_for_tables - テーブル読込完了まで待機 activity(AccessContext, Fun[, Args]) - クエリの実行方法を指定 AccessContextの種類 transaction - 非同期トランザクション、トランザクションの完了を待つわけではないので正確ではない sync_transaction - 同期トランザクション async_dirty - 非同期のロックなし処理 sync_dirty - 同期のロックなし処理 ets - MnesiaをつかわずETSテーブルで処理 write delete read match_object select \n- create_schema(ListOfNodes)\n- create_table(TableName, Option) オプション {attributes, List} - テーブルのカラム名 {disc_copies, NodeList} {disc_only_copies, NodeList} {ram_copies, NodeList} - テーブルの保存場所 {index, ListOfIntegers} - インデックスをはる {record_name, Atom} - テーブルの別名（非推奨） {type, Type} - テーブル種類 (set, ordered_set, bag) {local_content, Boolean} - デフォルト false。true にすると、多数のノード上に共有されない固有のローカルテーブルを作成する \n- オプション {attributes, List} - テーブルのカラム名 {disc_copies, NodeList} {disc_only_copies, NodeList} {ram_copies, NodeList} - テーブルの保存場所 {index, ListOfIntegers} - インデックスをはる {record_name, Atom} - テーブルの別名（非推奨） {type, Type} - テーブル種類 (set, ordered_set, bag) {local_content, Boolean} - デフォルト false。true にすると、多数のノード上に共有されない固有のローカルテーブルを作成する \n- {attributes, List} - テーブルのカラム名\n- {disc_copies, NodeList} {disc_only_copies, NodeList} {ram_copies, NodeList} - テーブルの保存場所\n- {index, ListOfIntegers} - インデックスをはる\n- {record_name, Atom} - テーブルの別名（非推奨）\n- {type, Type} - テーブル種類 (set, ordered_set, bag)\n- {local_content, Boolean} - デフォルト false。true にすると、多数のノード上に共有されない固有のローカルテーブルを作成する\n- wait_for_tables - テーブル読込完了まで待機\n- activity(AccessContext, Fun[, Args]) - クエリの実行方法を指定 AccessContextの種類 transaction - 非同期トランザクション、トランザクションの完了を待つわけではないので正確ではない sync_transaction - 同期トランザクション async_dirty - 非同期のロックなし処理 sync_dirty - 同期のロックなし処理 ets - MnesiaをつかわずETSテーブルで処理 \n- AccessContextの種類 transaction - 非同期トランザクション、トランザクションの完了を待つわけではないので正確ではない sync_transaction - 同期トランザクション async_dirty - 非同期のロックなし処理 sync_dirty - 同期のロックなし処理 ets - MnesiaをつかわずETSテーブルで処理 \n- transaction - 非同期トランザクション、トランザクションの完了を待つわけではないので正確ではない\n- sync_transaction - 同期トランザクション\n- async_dirty - 非同期のロックなし処理\n- sync_dirty - 同期のロックなし処理\n- ets - MnesiaをつかわずETSテーブルで処理\n- write\n- delete\n- read\n- match_object\n- select\n- application set_env(mnesia, dir, \"path/to/db\") - スキーマ保存場所を指定 \n- set_env(mnesia, dir, \"path/to/db\") - スキーマ保存場所を指定 \n\nクエリリスト内包表記 \n\n- qlc q(Fun, Generator) - クエリハンドル eval(QueryHandle) - 評価 fold(Fun, Dict, QueryHandle) \n- q(Fun, Generator) - クエリハンドル\n- eval(QueryHandle) - 評価\n- fold(Fun, Dict, QueryHandle)   > 33 Dialyzer33 Dialyzer \n\n今回は静的型チェッカーDialyzerについてかんがえる。   > Dialyzerの特徴Dialyzerの特徴 \n\nCLI \n\n- PLT (Persistent Lookup Table 永続的探索表) dialyzer --build_plt --apps erts kernel stdlib mnesia sasl common_test eunit - PLT作成 dialyzer --add_to_plt --apps reltool - PLT追加 \n- dialyzer --build_plt --apps erts kernel stdlib mnesia sasl common_test eunit - PLT作成\n- dialyzer --add_to_plt --apps reltool - PLT追加\n- 型チェック dialyzer foo/src/bar.erl - ファイルを解析 dialyzer -r foo/src bar/src --src - ディレクトリ指定してerlファイルを解析 \n- dialyzer foo/src/bar.erl - ファイルを解析\n- dialyzer -r foo/src bar/src --src - ディレクトリ指定してerlファイルを解析 \n\nErlangの型 \n\n- シングルトン型 - それ自体が型を示すオブジェクト 'some atom - アトム 42 - 整数 [] - 空リスト {} - 空タプル <<>> - 空バイナリ \n- 'some atom - アトム\n- 42 - 整数\n- [] - 空リスト\n- {} - 空タプル\n- <<>> - 空バイナリ\n- BIF型 any() none() pid() port() reference() atom() atom() binary() <<_:Integer>> - 特定サイズのバイナリ <<_:*Integer>> - 特定のユニットサイズで長さは指定されていないバイナリ <<_:Integer, _:_*OtherInteger>> - 上記2つの組み合わせ、バイナリの最小の長さを指定する形式 integer() N..M - 整数の範囲 non_neg_integer() pos_integer() - ゼロより大きい自然数 neg_integer() - 負の整数 float() fun() - あらゆる種類の関数 fun((...) -> Type) - 引数のアリティが決まっていない、特定の肩を返す無名関数 fun(() -> Type) fun((Type1, Type2, ..., TypeN) -> Type) [Type()] - 特定の型を持つリスト [Type(), ...] - 特定の型を持つリスト、またリストが空でないことを示す tuple() {Type1, Type2, ..., TypeN} - 全要素の型とサイズがわかっているタプル \n- any()\n- none()\n- pid()\n- port()\n- reference()\n- atom()\n- atom()\n- binary()\n- <<_:Integer>> - 特定サイズのバイナリ\n- <<_:*Integer>> - 特定のユニットサイズで長さは指定されていないバイナリ\n- <<_:Integer, _:_*OtherInteger>> - 上記2つの組み合わせ、バイナリの最小の長さを指定する形式\n- integer()\n- N..M - 整数の範囲\n- non_neg_integer()\n- pos_integer() - ゼロより大きい自然数\n- neg_integer() - 負の整数\n- float()\n- fun() - あらゆる種類の関数\n- fun((...) -> Type) - 引数のアリティが決まっていない、特定の肩を返す無名関数\n- fun(() -> Type)\n- fun((Type1, Type2, ..., TypeN) -> Type)\n- [Type()] - 特定の型を持つリスト\n- [Type(), ...] - 特定の型を持つリスト、またリストが空でないことを示す\n- tuple()\n- {Type1, Type2, ..., TypeN} - 全要素の型とサイズがわかっているタプル\n- エイリアス型 term() boolean() - 'true' | 'false' byte() - 0..255 char() - 0..16#10ffff number() - integer() | float() maybe_improper_list() - maybe_improper_list(any(), any()) maybe_improper_list(T) - maybe_improper_list(T, any()) string() - [char()] iolist() - maybe_improper_list(char() | binary() | iolist(), binary() | []) module() - atom() timeout() - non_neg_integer() node() - アトム no_return() - none() \n- term()\n- boolean() - 'true' | 'false' \n- byte() - 0..255 \n- char() - 0..16#10ffff \n- number() - integer() | float() \n- maybe_improper_list() - maybe_improper_list(any(), any()) \n- maybe_improper_list(T) - maybe_improper_list(T, any()) \n- string() - [char()] \n- iolist() - maybe_improper_list(char() | binary() | iolist(), binary() | []) \n- module() - atom() \n- timeout() - non_neg_integer() \n- node() - アトム\n- no_return() - none()  \n\n判定できない例と対策   erlang \n\n-module(cards). -export([kind/1, main/0]). -type suit() :: spades | clubs | hearts | diamonds. -type value() :: 1..10 | j | q | k. -type card() :: {suit(), value()}. -spec kind(card()) -> 'face' | 'number'. % 注釈をくわえることでdialyzerに警告させる kind({_, A}) when A >= 1, A =< 10 -> number; kind(_) -> face. main() -> number = kind({spades, 7}), face = kind({hearts, k}), number = kind({rubies, 4}), % タプルの中の型が違う  face = kind({clubs, q}).     erlang \n\n-module(convert). -export([main/0]). %% 注釈をつけないとdialyzerは下記のように判定する % -spec convert(list() | tuple()) -> list() | tuple(). -spec convert(tuple()) -> list(); (list()) -> tuple(). main() -> [_, _] = convert({a, b}), {_, _} = convert([a, b]), [_, _] = convert([a, b]), {_, _} = convert({a, b}). %% private convert(Tup) when is_tuple(Tup) -> tuple_to_list(Tup); convert(L=[_|_]) -> list_to_tuple(L)."},"name":"[2017-04-29]LYSE本を読む","tags":["erlang","elixir"],"childPublishedDate":{"published_on":"2017-04-29T00:00:00.000Z","published_on_unix":1493424000}}}]}},"pageContext":{"number":50}},"staticQueryHashes":[]}