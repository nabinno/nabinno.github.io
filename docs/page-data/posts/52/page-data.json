{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/52","result":{"data":{"esaPost":{"number":52,"relative_category":"blog/backend","fields":{"title":"HerokuとGAEのCIをDockerとパイプラインから構成されたWerckerで管理する","excerpt":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。   > PROBLEMPROBLEM \n\n- パフォーマンス改善のための開発環境がいけてない\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい   > SOLUTIONSOLUTION \n\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。 \n\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。 \n\n1. Dockerで環境を管理。 今回は対応していないですが、GAEのコンテナ（gcr.io/google_appengine/ruby:xxx）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\n2. 異なるサービス間のネットワークをWerckerが生成する環境変数で管理。 Dockerのネットワーク設定の煩雑さを解消します。\n3. タスクをワークフローとしてパイプラインで条件付け管理。 パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。 \n\n次に、Werckerのふるまいを定義するwercker.ymlは、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。    > devパイプラインdevパイプライン \n\ndevパイプラインは wercker dev コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。   yaml \n\nbox: ruby:2.3.1 services: - postgres:9.6.1 - redis:3.0.3 dev: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - internal/watch: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec reload: true     > buildパイプラインbuildパイプライン \n\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。   yaml \n\nbuild: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - script: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec     > deploy-stageパイプラインdeploy-stageパイプライン \n\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。 \n\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。   yaml \n\ndeploy-stage-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - nabinno/heroku-install: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: Fork Application - destroy application code: | heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME - script: name: Fork Application - fork code: | heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME - script: name: Fork Application - setup addons of rediscloud code: | heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME - script: name: Fork Application -change dynos code: | heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME - script: name: Fork Application - change environment variables code: | _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}') heroku config:set \\ S3_BUCKET=$S3_BUCKET \\ HEROKU_APP=$HEROKU_APP_NAME \\ REDISCLOUD_URL=$_rediscloud_url \\ --app $HEROKU_APP_NAME - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-herokuパイプラインdeploy-prod-herokuパイプライン \n\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。   yaml \n\ndeploy-prod-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-gaeパイプラインdeploy-prod-gaeパイプライン \n\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。 \n\nGAEのデプロイは癖があって、gcloud app deployコマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、asset_syncを使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、gcloudのデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は ./public ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。 \n\nGAEのコンテナの中身は、gcloud beta app gen-config --runtime=ruby --custom で出力されるDockerfileを参照ください。   yaml \n\ndeploy-prod-gae: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: DB Migrate code: | RAILS_ENV=production \\ DATABASE_URL=${DATABASE_URL} \\ bundle exec rake db:create db:migrate --trace - script: name: Install gcloud code: | curl https://sdk.cloud.google.com | bash source ~/.bashrc - script: name: Authenticate gcloud code: | gcloud config set project utagaki-v2 openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json gcloud auth activate-service-account --key-file ./gcloud.json - script: name: Deploy app to Google App Engine code: | gcloud app deploy ./app.yaml --promote --stop-previous-version after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > post-deployパイプラインpost-deployパイプライン \n\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に git tag をつけています。   yaml \n\npost-deploy: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git remote add origin git@github.com:nabinno/utagaki.git git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > WRAPUPWRAPUP \n\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。 \n\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png"},"wip":false,"body_md":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。\r\n\r\n# PROBLEM\r\n- パフォーマンス改善のための開発環境がいけてない\r\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい\r\n\r\n# SOLUTION\r\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。\r\n\r\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。\r\n\r\n1. **Dockerで環境を管理。** 今回は対応していないですが、GAEのコンテナ（`gcr.io/google_appengine/ruby:xxx`）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\r\n2. **異なるサービス間のネットワークをWerckerが生成する環境変数で管理。** Dockerのネットワーク設定の煩雑さを解消します。\r\n3. **タスクをワークフローとしてパイプラインで条件付け管理。** パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。\r\n\r\n次に、Werckerのふるまいを定義する`wercker.yml`は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。\r\n\r\n<img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\">\r\n\r\n## devパイプライン\r\ndevパイプラインは `wercker dev` コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。\r\n\r\n``` yaml\r\nbox: ruby:2.3.1\r\nservices:\r\n  - postgres:9.6.1\r\n  - redis:3.0.3\r\n\r\ndev:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - internal/watch:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n        reload: true\r\n```\r\n\r\n## buildパイプライン\r\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。\r\n\r\n``` yaml\r\nbuild:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - script:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n```\r\n\r\n## deploy-stageパイプライン\r\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。\r\n\r\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。\r\n\r\n``` yaml\r\ndeploy-stage-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - nabinno/heroku-install:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - destroy application\r\n        code: |\r\n          heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - fork\r\n        code: |\r\n          heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - setup addons of rediscloud\r\n        code: |\r\n          heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application -change dynos\r\n        code: |\r\n          heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - change environment variables\r\n        code: |\r\n          _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')\r\n          heroku config:set \\\r\n            S3_BUCKET=$S3_BUCKET \\\r\n            HEROKU_APP=$HEROKU_APP_NAME \\\r\n            REDISCLOUD_URL=$_rediscloud_url \\\r\n            --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-herokuパイプライン\r\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。\r\n\r\n``` yaml\r\ndeploy-prod-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n        install-toolbelt: true\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-gaeパイプライン\r\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。\r\n\r\nGAEのデプロイは癖があって、`gcloud app deploy`コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、`asset_sync`を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、`gcloud`のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は `./public` ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。\r\n\r\nGAEのコンテナの中身は、`gcloud beta app gen-config --runtime=ruby --custom` で出力されるDockerfileを参照ください。\r\n\r\n``` yaml\r\ndeploy-prod-gae:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          RAILS_ENV=production \\\r\n            DATABASE_URL=${DATABASE_URL} \\\r\n            bundle exec rake db:create db:migrate --trace\r\n    - script:\r\n        name: Install gcloud\r\n        code: |\r\n          curl https://sdk.cloud.google.com | bash\r\n          source ~/.bashrc\r\n    - script:\r\n        name: Authenticate gcloud\r\n        code: |\r\n          gcloud config set project utagaki-v2\r\n          openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json\r\n          gcloud auth activate-service-account --key-file ./gcloud.json\r\n    - script:\r\n        name: Deploy app to Google App Engine\r\n        code: |\r\n          gcloud app deploy ./app.yaml --promote --stop-previous-version\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## post-deployパイプライン\r\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に `git tag` をつけています。\r\n\r\n``` yaml\r\npost-deploy:\r\n  steps:\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git remote add origin git@github.com:nabinno/utagaki.git\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n# WRAPUP\r\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。\r\n\r\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","body_html":"<p data-sourcepos=\"1:1-1:204\">Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。</p>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-6:0\">\n<li data-sourcepos=\"4:1-4:71\">パフォーマンス改善のための開発環境がいけてない</li>\n<li data-sourcepos=\"5:1-6:0\">別PaaSへ移行するための開発環境が汎用化できてない、つらい</li>\n</ul>\n<h1 data-sourcepos=\"7:1-7:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"8:1-8:272\">というわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。</p>\n<p data-sourcepos=\"10:1-10:154\">まず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。</p>\n<ol data-sourcepos=\"12:1-15:0\">\n<li data-sourcepos=\"12:1-12:296\">\n<strong>Dockerで環境を管理。</strong> 今回は対応していないですが、GAEのコンテナ（<code>gcr.io/google_appengine/ruby:xxx</code>）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。</li>\n<li data-sourcepos=\"13:1-13:168\">\n<strong>異なるサービス間のネットワークをWerckerが生成する環境変数で管理。</strong> Dockerのネットワーク設定の煩雑さを解消します。</li>\n<li data-sourcepos=\"14:1-15:0\">\n<strong>タスクをワークフローとしてパイプラインで条件付け管理。</strong> パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。</li>\n</ol>\n<p data-sourcepos=\"16:1-16:233\">次に、Werckerのふるまいを定義する<code>wercker.yml</code>は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\"></a>\n<h2 data-sourcepos=\"20:1-20:24\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"devパイプライン\" name=\"dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"devパイプライン\"> &gt; devパイプライン</span></a>devパイプライン</h2>\n<p data-sourcepos=\"21:1-21:465\">devパイプラインは <code>wercker dev</code> コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。</p>\n<div class=\"code-block\" data-sourcepos=\"23:1-46:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">box</span><span class=\"pi\">:</span> <span class=\"s\">ruby:2.3.1</span>\n<span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">postgres:9.6.1</span>\n  <span class=\"pi\">-</span> <span class=\"s\">redis:3.0.3</span>\n\n<span class=\"na\">dev</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"s\">internal/watch</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n        <span class=\"na\">reload</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"48:1-48:26\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"buildパイプライン\" name=\"build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"buildパイプライン\"> &gt; buildパイプライン</span></a>buildパイプライン</h2>\n<p data-sourcepos=\"49:1-49:203\">buildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。</p>\n<div class=\"code-block\" data-sourcepos=\"51:1-75:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">build</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"77:1-77:33\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"deploy-stageパイプライン\" name=\"deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-stageパイプライン\"> &gt; deploy-stageパイプライン</span></a>deploy-stageパイプライン</h2>\n<p data-sourcepos=\"78:1-78:331\">deploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。</p>\n<p data-sourcepos=\"80:1-80:130\">他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。</p>\n<div class=\"code-block\" data-sourcepos=\"82:1-164:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-stage-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"s\">nabinno/heroku-install</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - destroy application</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - fork</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - setup addons of rediscloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application -change dynos</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - change environment variables</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')</span>\n          <span class=\"s\">heroku config:set \\</span>\n            <span class=\"s\">S3_BUCKET=$S3_BUCKET \\</span>\n            <span class=\"s\">HEROKU_APP=$HEROKU_APP_NAME \\</span>\n            <span class=\"s\">REDISCLOUD_URL=$_rediscloud_url \\</span>\n            <span class=\"s\">--app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"166:1-166:39\" id=\"2-4-0\" name=\"2-4-0\">\n<a class=\"anchor\" id=\"deploy-prod-herokuパイプライン\" name=\"deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-4-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-herokuパイプライン\"> &gt; deploy-prod-herokuパイプライン</span></a>deploy-prod-herokuパイプライン</h2>\n<p data-sourcepos=\"167:1-167:150\">deploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。</p>\n<div class=\"code-block\" data-sourcepos=\"169:1-231:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n        <span class=\"na\">install-toolbelt</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"233:1-233:36\" id=\"2-5-0\" name=\"2-5-0\">\n<a class=\"anchor\" id=\"deploy-prod-gaeパイプライン\" name=\"deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-5-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-gaeパイプライン\"> &gt; deploy-prod-gaeパイプライン</span></a>deploy-prod-gaeパイプライン</h2>\n<p data-sourcepos=\"234:1-234:186\">deploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。</p>\n<p data-sourcepos=\"236:1-236:787\">GAEのデプロイは癖があって、<code>gcloud app deploy</code>コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、<code>asset_sync</code>を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、<code>gcloud</code>のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は <code>./public</code> ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。</p>\n<p data-sourcepos=\"238:1-238:138\">GAEのコンテナの中身は、<code>gcloud beta app gen-config --runtime=ruby --custom</code> で出力されるDockerfileを参照ください。</p>\n<div class=\"code-block\" data-sourcepos=\"240:1-281:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-gae</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production \\</span>\n            <span class=\"s\">DATABASE_URL=${DATABASE_URL} \\</span>\n            <span class=\"s\">bundle exec rake db:create db:migrate --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">curl https://sdk.cloud.google.com | bash</span>\n          <span class=\"s\">source ~/.bashrc</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Authenticate gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud config set project utagaki-v2</span>\n          <span class=\"s\">openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json</span>\n          <span class=\"s\">gcloud auth activate-service-account --key-file ./gcloud.json</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Deploy app to Google App Engine</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud app deploy ./app.yaml --promote --stop-previous-version</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"283:1-283:32\" id=\"2-6-0\" name=\"2-6-0\">\n<a class=\"anchor\" id=\"post-deployパイプライン\" name=\"post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-6-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"post-deployパイプライン\"> &gt; post-deployパイプライン</span></a>post-deployパイプライン</h2>\n<p data-sourcepos=\"284:1-284:142\">post-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に <code>git tag</code> をつけています。</p>\n<div class=\"code-block\" data-sourcepos=\"286:1-308:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">post-deploy</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git remote add origin git@github.com:nabinno/utagaki.git</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"310:1-310:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"311:1-311:276\">こうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。</p>\n<p data-sourcepos=\"313:1-313:104\">手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。</p>\n","tags":["wercker","docker","heroku","google-app-engine"],"updated_at":"2021-01-16T12:13:04+09:00","childPublishedDate":{"published_on":"2017-02-07T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":68,"relative_category":"blog/organization","fields":{"title":"飲み会に参加するための機材","excerpt":"以前チーム内でリモート懇親会を画策したのですが、食材の調達や経費精算など手間が多すぎて断念しました。ただ、その言い訳は実は本質的ではなく、実際に後ろ向きにさせていたのは「しゃべりながら食べるのがつらい」ということにありました。今回はそれを解決した機材を紹介します。   > PROBLEMPROBLEM \n\n- リモート飲みがつらい 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい 音声が悪すぎて相手にメッセージが伝わらない 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい \n- 有線ヘッドホンだとPCの前に張り付きになりつらい\n- 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい\n- というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい\n- 音声が悪すぎて相手にメッセージが伝わらない\n- 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない\n- 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 最初は楽しいがすぐ飽きる   > SOLUTIONSOLUTION \n\nというわけで、自分がこの1年試行錯誤した末に辿り着いた飲み会参加の機材スタックを共有します。   > オーディオインターフェイスオーディオインターフェイス \n\nオーディオインターフェイスはマイクやギターの音をパソコンに取り込むアナログ・デジタル変換と、取り込んだ音を再生するデジタル・アナログ変換の機能を提供します。 \n\nボイスメモ程度なら必要ないですが、フルリモートで頻繁に会議をしている機会が多いと音質とレイテンシーに多分な影響を与えます。オーディオインターフェイスがない場合、入力時にノイズが乗ったり、出力時に音質が劣化します。また、レイテンシーがひどくなったり音がゆがんだり、下手をするとPCに負荷がかかりフリーズします... \n\n会議を頻繁にする人はとりあえず手に入れたい機材。Steinberg UR22Cが人気です。 \n\n- Steinberg UR22C   > マイクマイク \n\n演説やスピーチ用にダイナミックマイクが使われていますが、オンラインミーティングで使う場合は聞き取りづらいので、何はともあれコンデンサーマイクを使うべきです。 \n\nコンデンサーマイクと言っても、いろいろあります。特にマイクの振動板（ダイアフラム）が大型か小型かで音質の印象が変わるので注意が必要です。私は下記の表のように利用シーンごとに使い分けています。    - 説明 利用シーン     スモールダイアフラム 現実主義。色のない、ニュートラルな音色を提供 ファシリテート   ラージダイアフラム 浪漫主義。音源をより大きく、愛らしいものに変換 発表、音楽活動    \n\nなお、HHKB等の打鍵音が大きいキーボードを利用している方や仕事スペースと家庭スペースとの距離が近い方は、いずれにしてもスモールダイアフラムがお薦めです。スモールダイアフラムはマイクから口元を少しでもずらすと音が入力されずらくなくなるため、期待した音質を提供することが出来ます。 \n\n製品としてはShure Beta87Aが人気です。また、購入する際はマイクスタンドとマイクスポンジもセットで検討すると良いです。マイクの位置を固定し風よけを設置した方が安定した音質に繋がります。 \n\n- Shure Beta87A   > ヘッドホンヘッドホン \n\n食事を取りながら相手の話を聞くには通常のヘッドホンだと食べ物を咀嚼するのに苦労します。口を開けたり閉めたりする際、顎とともにヘッドホンが上下に動くため相手の声が聞き取りづらくなります。 \n\n耳の穴に接しない骨伝導ヘッドホンは、食べ物を咀嚼する際の顎の動きに左右されることがないです。テレワークのヘッドホン多用が外耳炎を引き起こしているという話もあるので、そういう意味で骨伝導ヘッドホンは健康を保つ上でも重要な機材となります。 \n\nまた、使用していて分かったのですが、普段の食事の中でも使うことが出来るので、隙間時間に気軽にメディアに接しやすくなります。例えば、家族と一緒の部屋にいる中、食事を取りながらAWSのWebinarを聞くことができます。 \n\n製品としては業界を牽引しているAfterShokzのAeropexが人気です。今回はオーディオインターフェイスを利用しているので、音質をさらに高めるためにトランスリミッターと組み合わせましょう。 \n\n- AfterShokz Aeropex\n- トランスリミッター TaoTronics aptX-LL   > ビデオビデオ \n\nソーシャルメディアでよく登場するビデオ画像は、表情アップの図（ず）が前面に押し出された絵が一般的ですが、地（じ）の表現が薄く解釈余地がないものが多いです。表情が豊かな方は良いのですが、全員がそういうわけではないので地（じ）の生活の部分に焦点を当てた方が実態に合っています。 \n\n例えば、対面での会話の中では身につけている服装や持ち物等のアトリビュートに焦点が当たりますよね。「その身につけているアクセサリーは何?」「机の上に置いてあるその本、面白そうだね」という会話を思い出してください。 \n\nそういう意味で広角レンズを搭載したアクションカムは望ましい選択です。今時のアクションカムは高解像で鮮やかに表現してくれますし、外にいなくても部屋の中で十分面白い絵になります。 \n\nアクションカムは何でも良いのですが、私は普段「撮れラン」で使っているSony HDR-AS3000をミーティングの際に使っています。 \n\n- Sony HDR-AS3000   > WRAPUPWRAPUP \n\n今回紹介した機材に出会うまで紆余曲折ありましたが、揃えてみて満足しています。 \n\n飲み会でなくても良いですが、機材を揃えた方でいろいろ試してみたい方は一緒に雑談してみませんか。30分雑談会というのを開催しているので、いつでもお気軽にお声がけください。お目にかかれるのを楽しみにしています。 \n\n- 30分雑談会"},"name":"飲み会に参加するための機材","tags":["drinkup","team-building"],"childPublishedDate":{"published_on":"2021-01-29T04:04:17.000Z","published_on_unix":1611893057}}},{"node":{"number":66,"relative_category":"blog","fields":{"title":"On Blahfe","excerpt":"txt \n\n（小学校の作文より） ぼくは、二年の時、友達と自転車で、じゅくから帰ってくるとちゅう、トラックに足をふまれてしまいました。おほりの近くの道路でトラックが来たから、よけようとした時、ころんで足を道路にだしてしまったのです。 いたみは感じなかったのに、なぜか泣いてしまい、トラックのおじさんたちが「けがはなかったかい」と心配してくれました。それでも、ぼくが泣いてるもんだから、病院に行って、レントゲンで見てもらいました。全然いじょうはなかったそうです。 その時、ぼくはほっとして、これからは自分で安全を守ろうと、決心しました。ただ、三年になってしまうと、安全を守ろうなんていう決心は、とっくに忘れてしまいました。 三年の五月になって、お父さんと兄弟と友達で郡山ダムまでサイクリングに行きました。行くときは、よかったんだけど、帰りの時、坂で足をすべらして、自転車のスポークの中につま先をはめてしまいました。その勢いで、自転車が、一回転してしまいました。 たまたま車が通って、中の農家の人が「どうしたんだい」と、話しかけてくれました。ぼくは、足の方のいたさで、話すこともできませんでした。それから、農家の人が、心配して、家までつれていってくれました。 家に帰ると、安心して、泣いてしまいました。それから、病院に行ってレントゲンをとって見ると、お医者さんがだいじょうぶといっていました。とってもよかったです。 また、ぼくは、自分で安全を守ろうと、心に決めました。     > サイト構成サイト構成 \n\nある方曰く、痛みとは人の根源だそうで。小学校の作文ではないですが、私がいつも気にしてるテーマです。 \n\n- 退屈\n- 寂しさ\n- 肉体の痛み\n- 健康喪失の恐れ\n- 金銭ストレス\n- 虚しさ \n\nこのブログでは個人的な課題解決をPROBLEM-SOLUTIONという2つのセクションで構成しています。PROBLEMは上記テーマのどれかが当てはまります。SOLUTIONはその時たまたま私がとった手法になります。基本職業に近いものが選ばれますが、そうでない場合もあります。"},"name":"[2017-01-31]On Blahfe","tags":["blahfe"],"childPublishedDate":{"published_on":"2017-01-31T00:00:00.000Z","published_on_unix":1485820800}}},{"node":{"number":50,"relative_category":"blog/health","fields":{"title":"30代からの胸郭変形（漏斗胸）手術","excerpt":"30代を超えたあたりから禄軟骨が硬化してきたため心臓、肺を圧迫するようになりました。日常生活では特に階段の上りに支障が出てきたのでその原因として従来の胸郭変形を疑ったわけです。今回はその治療（手術）にあたりました。   > PROBLEMPROBLEM \n\n- 重度の胸郭変形（漏斗胸）をかかえているため内臓への負荷がもとよりある。ヘイラーインデックス（後述）が健常者の3倍。\n- 30代を超えたあたりから肋軟骨が硬化してきたため心臓、肺を圧迫するようになった。   > TLDRTLDR \n\n漏斗胸患者の状況を医師から聞いたのですが、その話を考慮すると、1万人くらいは似たような課題をかかえる人がいるのではと思います。本記事はあくまで患者の備忘なので、医療的な内容は 専門医に聞いてください。 \n\n漏斗胸患者の状況 \n\n- ナス法は2000年代に入ってから徐々に一般に知られるようなった\n- ナス法は10代のうちに受けるのが体力的・経済的にも適切\n- 日本人1000-300人に1人が漏斗胸患者の可能性がある\n- 漏斗胸患者の8-9割は男性である   > SOLUTIONSOLUTION \n\nというわけで、今まで放置していた胸郭を矯正する手術（ナス法）を先日行いました。まだ経過観察中ですが、様態も安定してきたので、備忘のために今までおこなった対策を記します。30代でこの手術をする人の情報があまりなかったので試行錯誤です。 \n\n私の記憶がたしかなら、ナス法は2000年代に入ってから徐々に一般に知られるようなり、今では美容目的の手術としても扱われています。それまでの胸郭変形の手術は、胸を切開して骨を切りとりその骨を表裏反転させるなど大掛かりなものでした。 \n\nその内容は歯の矯正と原理はおなじで矯正器具を患部周辺にとりつけて時間をかけて適正に形を整えていくというもの。ただし、矯正器具を骨の内側にとりつけるため、歯の強制よりも時間と痛みを多くともなうものです。 \n\n- 治療期間でみると、歯の矯正が4-6か月、胸の矯正が2-3年かかります。\n- 痛みの度合いでみると、強度の医療麻薬・鎮痛剤にお世話になる期間が歯の矯正では7日ほど、胸の矯正では40日ほど。また、鎮痛剤が不要になっても、施術部位の皮膚組成が治るまで、前者は2週間ほど噛むことが制限され、後者は90日ほど運動（胸郭をつかう運動のこと：例えば、満員電車への乗車、タクシー乗車、ジョギング、サイクリングなど）が制限されます。\n- 治療リスクは、歯の矯正が口内炎、歯髄炎である一方、胸の矯正が心臓の損傷、無気肺、肺水腫など。 \n\nさて、費用とタスク、そして手術後みえてきた課題（リハビリ）を以下に記します。   > 費用費用 \n\nまずは費用。手術・入院費用は健康保険適用で10万ほど。これは入院保険に加入していれば気にする必要はないです。 \n\nただ、日常生活を送れるようになるまで4-6か月を有するので、収入分の金額を念頭にいれる必要があります。   > タスク、退院までの工程タスク、退院までの工程 \n\n次にタスク。下記5段階を順にみていきます。調べはじめて退院まで早くて6か月はみておいた方がいいです。 \n\n1. ヘイラーインデックスを測る\n2. 入院保険にはいる\n3. 診察をうける、手術の打診\n4. 手術、入院\n5. 退院   > 1. ヘイラーインデックスを測る1. ヘイラーインデックスを測る \n\n初診の頃は知りませんでしたが、重度かどうかの判断はヘイラーインデックス（インデックス）を見ます。下記の式で簡単にインデックスを算出できます。本来であればCTで詳細をみて導き出すものですが、それほど複雑ではないのでまずは診察に行くかの判断材料として概算を出しておくと良いでしょう。 \n\nヘイラーインデックス = 肋骨の内側の距離 / 胸骨と背骨の距離  \n\nインデックスは通常は2.5ポイントぐらいでその値から離れるほど重症となります。重度の場合はさっと診察して、手術かどうかの判断を求められることがあるので準備に越したことはないです。  \n\n参考までにWikipediaに掲載されているヘイラーインデックス算出画像をみます。画像で出されたインデックスは3.59ポイント (25.1cm / 7.0cm)で、心臓が圧迫されている様子が見て取れます。 \n\nちなみに私は8.7～9.0ポイントで、第4胸骨（第6-7肋軟骨）と背骨の距離が通常の4分1ほど（3 cm）の状態、肺と心臓が押しつぶされていました。 \n\n個人の実感ですが、胸郭変形は整形上の問題もあるが、年齢をかさねるにつれて硬化する肋軟骨にあります。変形した骨が内臓への負荷をじょじょに増進し、気づいたら循環器系の機能低下、それにともなう免疫力低下につながる可能性があります。医師によると漏斗胸の患者には肺炎・心臓病が多く見られるが、その関係解明はこれからの課題だそうです。   > 2. 入院保険にはいる2. 入院保険にはいる \n\n入院保険について、すでに入っているなら必要ないです。胸郭変形の手術は健康保険適用なので通常の民間保険であれば同様に適用されるはずです。私はネットで安いところ、期間縛りでトータル20万（月2千）くらいの保険商品を購入しました。 \n\nまた、術後の合併症などで想定外に入院・手術費がかさむ可能性があるので、手術が確定したら市区町村の高額医療費制度を利用すると良いでしょう。   > 3. 診察をうける、手術の打診3. 診察をうける、手術の打診 \n\nまだ、町のクリニックと形成外科との連携がとられるほどナス法手術が業界に浸透してないため、かかりつけの医師より紹介状をもらえる可能性は低いです（2017年時点）。従って、ネットで執刀数や論文提出数など勘案して信頼できる医師を選定します。ナス法が受けられる医療施設はこちらから探し出せます。外科には自分の体調不良とその原因を棚卸するため、診察してもらいに来たとでも言うと伝わるでしょう。 \n\n診察ではX線、CTをとって、ヘイラーインデックスの状態と患部の状態をくらべて施術判断がされます。初回ではCT、X線のみ。2回目にあらためて専任の医師より判断されます。医師の判断は一瞬で、施術リスクの重説と施術有無の打診がされ、スケジュール調整となります。   > 4. 入院、手術4. 入院、手術 \n\n手術を受けるようになっても入院までは普段と変わらない生活が送れます。それ以降は入院関連の慣習、業務フローを知らないと生活上でいろいろと不都合が生じるでしょう。 \n\n入院初日。入院手続きで連帯保証人が複数人必要と何人かの事務方に言われます。ただ、この情報は、患者が死亡した際の身柄引き取り先や医療費滞納が起きることを想定して病院が事前に知りたいだけで、法的にグレーな慣習です。マストではないので情報提供を断っても強く追及してこないです。 \n\n手術前日。貴重品を持てない、荷物を持てないという制約がかかります。警備体制が整ってていない病院は防犯が弱いのであえて金庫をおかない上、貴重品を預かりません。手術時患者は貴重品をもつことができないので、実質貴重品なしで入院することになります。しかし、手ぶらでは入院手続きできないので1人身で入院するには工夫が必要です。 \n\n術後。突然ICUで目が覚めます。そして、6本カテーテルが体に刺さっていて医療麻薬・鎮痛剤投与のルーチンが始まります。ICUから通常病棟への移管は受け入れ態勢によって変動します。術前に麻酔をうたれる辺りまでは記憶にあるが、それ以降のことはまったく覚えていないので混乱する時期です。 \n\n病棟移管後。ネット利用禁止。こちらはは昔からの慣習で建前上禁止になっているにすぎず、スマホの普及とともに黙認、あるいは容認するようになっています。ただ、手術前日の荷物をもてないという制約があることと、術後2週間は動くのがままならない状態なので1人身で入院すると外界と接続ができなくなります。   > 閑話休題 入院時の様子閑話休題 入院時の様子 \n\nここでちょうど入院時の様子がTwitterに残っていたので、抜粋します。入院直後、手術前、手術後、退院間近の心境の変化がみてとれます。 \n\n入院直後\n 手術がおもったよりも大変そうと気づきます。 \n\nnabinno, 02:26 PM October 01, 2016: かるい手術と思ったらICUに入ることになってる // from Twitter for Android [Tokyo, JP]  \n\n手術前\n 手術まで暇なのでPowerShellをいじりはじめます。 \n\nnabinno, 05:41 PM October 01, 2016: Hum > $($(curl http://www.yahoo.co.jp).Images | foreach {$_.src}) ` | sort ` | uniq ` | foreach { ` curl -Uri $_ -OutFile \"$(pwd)\\$(basename $_)\" ` } // from Twitter Web Client [Tokyo, JP]  \n\n手術後\n 麻酔の痛みがきれてナーバスになります。 \n\nnabinno, 04:06 PM October 08, 2016: ナースコールは enqueue/dequue もされてるがワーカーがかなりの頻度 でこける。夜になると汚いログがはかれるのは #医療OS の仕様だろうか ... // from Twitter for Android [Tokyo, JP]  \n\n気持ちを落ち着かせるためにEmacsをさわります。 \n\nnabinno, 09:01 PM October 11, 2016: 可能なかぎり Emacs で #Xamarin さわりたいので、CentOS 上に samba 立てた。 // from Twitter Web Client [Tokyo, JP]   \n\nBashOnWindowsで無茶をやり、少し落ち着きます。 \n\nnabinno, 09:18 PM October 11, 2016: #BashOnWindows の Emacs から #Xamarin さわったら 関連ファイルが消 されたり権限が変更されたりしたのだった ... // from twmode [Tokyo, JP]  \n\n術後ずっと寝たきりでしたが、なんとか動けるようになりました。 \n\nnabinno, 06:50 AM October 18, 2016: 胸郭手術時の 🛏 起床と就寝をマスターした // from Twitter Web Client [Tokyo, JP]   \n\n激痛のためノートPCがもてない体になっていました。 \n\nnabinno, 08:35 PM October 20, 2016: ノート PC は肉体的にまだ持てない ... // from twmode [Tokyo, JP]  \n\n退院間近\n アクティブトラッカーで客観的にみるよう心がけます。 \n\nnabinno, 05:22 PM October 21, 2016: #MicrosoftBand #HealthVault #MyFitnessPal で記録つけていて、ふと 医療機器がからだに入ってることにきづいた。他人事じゃないいんだけ ど、おもしろいなあ。 // from twmode [Tokyo, JP]    > 5. 退院5. 退院 \n\n退院は主治医が判断します、病棟の見回り医師ではないです。そして、たいてい腕のたつ主治医は多忙なので1週間に1度しか顔を出しません。なので、その時の様態次第で退院がどんどん後ろにずれていくので注意が必要です。 \n\n退院の条件 \n\n- 肺の状態、肺の膨らみ\n- 歩行の有無\n- 起床の有無\n- 退院したいという意志 \n\n入院中は上記の条件をクリアできるようこころがけることです、無為に過ごすと退院が遅れます。   > 手術後のリハビリ手術後のリハビリ   > 1か月後 ひたすら静養1か月後 ひたすら静養 \n\n退院直後の時期は風邪をひくと肺炎になる可能性が高まるので、2点注意します。 \n\nまずは内科。退院前に外科から出される鎮痛剤が強力なので薬の組み合わせには注意します。特に内科で出される風邪薬自体にも鎮痛剤が入っており、同時に飲むと神経系に支障をきたすことがあります。内科医には、咳をしたら胸に激痛が走るため鎮痛剤を利用している旨をつたえ、抗生剤、鎮咳剤、去痰剤の薬を処方してもらうようにしましょう。 \n\nまた、肺炎の気がありX線検査する場合、内科医にバーが邪魔をして検査がむずかしい状況にあることを共有します。内科医によっては、外科医が処方・処置した鎮痛剤とバーが自分の仕事を邪魔していると考える人もいます。 \n\n次に、免疫力。できるだけ免疫力が高まるように工夫しましょう。 \n\n食事。MyFitnessPal（Under Armour）のような栄養を主としたアクティビティトラッカーで不足栄養を観察し、まずは機能食品などで不足栄養を補います。私は皮膚の組成に関係しそうなマルチビタミン、ビタミンC、タンパク質を積極的にとっていました。余裕が出てきたらスーパー食材、外食チェーンHPの栄養表をみて、実際に食事し体調を観察します。体調はWithing BodyとMS Bandでトラックすることで管理が楽でした。 \n\n運動。運動はウォーキング程度に控えるよう医師から注意されます。従って、この期間はスクワットなど胸郭や脇の傷周囲の皮膚組織に動きつけない運動で落ちた筋力を回復させる程度にしましょう。また、無理のないストレッチで胸郭にうめこまれたバー周辺の皮膚を徐々に伸ばす、あたしい皮膚組織をつくるよう心掛けます。室内での自重トレーニングよりもジムのトレーニングマシンで、リハビリという視点で負荷を調整しながら無理なくおこなうと良いでしょう。実際にトレーニングする前に医師からリハビリスタッフを紹介してもらうのも手だと思います。 \n\n3つの運動 \n\n- 有酸素運動。ウォーキングで循環器系をきたえます。退院後でも起床など胸郭をうごかすのがむずかしい状態なので、まずウォーキングが普通にできるようにのぞみます。慣れてきたら距離をのばして5km、10kmとのばすと良いでしょう。足の負担を気にするようだったらAsics DynaFlyteのような、機能性を追求したランニングシューズの検討をすすめます。\n- 無酸素運動。無理のない筋トレで筋骨格をきたえる、皮膚を生成します。退院直後は腹筋、三角筋はバー周囲の皮膚が生成されていないので痛みとともに力を出すことがむずかしいです。従って、僧帽筋、大胸筋あたりから皮膚の生成を促すようにします。また、有酸素運動を無理なく行えるように下腿三頭筋（ふくろはぎ）や大腿四頭筋を積極的に動かします。余裕が出てきたら筋肉とトレーニングマシンの対応表を参考にすると良いでしょう。\n- ストレッチ。ヨガで皮膚の生成を促します。退院直後はヨガをする余裕はないが、軽いウォーキングや筋トレをはじめたあたりで、バウンドエンジェル、チャイルドポーズ、ハッピーベイビーポーズなど軽めなものを混ぜると良いでしょう。参考までにポーズ集があります。 \n\nまた、入院時に手術用コンプレッションウェアのタイツを着ることになりますが、退院後はスポーツ用コンプレッションウェアをシャツ、タイツともに着ると良いでしょう。手術時もそうですが、退院後も適度な負荷を皮膚に与えることで交感神経の活性化を促します。 \n\n私はできませんでしたが、免疫力向上は準備するのに時間がかかるので入院・手術前から取り組んでおくと良いでしょう。   > 3か月後どうなったか3か月後どうなったか \n\n下記にリハビリの経過を示すため体組成の一部を記します。    体組成 入院前 退院後1か月 退院後2か月 退院後3か月     胸囲 (cm) 68.5 80.8 82.7 82.9   体重 (kg) 51.0 46.6 49.6 50.8   筋肉 (kg) - 39.3 41.4 42.4   脂肪 (kg) - 4.9 5.8 5.9    \n\n退院後1か月目は胸囲が劇的に変わった一方で、体重が低下しています。ノートパソコンを持てないほどだったので筋力も同様に低下しているものと推測されます。退院後2か月目はリハビリを始めた効果が順当に出てどの体組成値も回復しています。そして、3か月目あたりで本来の値にもどっている様子がうかがえます。 \n\n3か月目以降はほぼ手術前、あるいはそれ以上の生活の質を担保できるので、バーを抜く最終手術の3年後を見越して無理なくリハビリをつづけると良いでしょう。   > WRAPUPWRAPUP \n\n当処の予想通り、心臓、肺の圧迫はなくなりました。仕事が出来なくなる期間等含む手術のトータルコストと今後のリスクを考えると実施して良かったです。3年後に抜去手術が控えているので、それが完了し経過観察が完全に終わった後、改めて感想を記します。"},"name":"[2017-02-06]30代からの胸郭変形（漏斗胸）手術","tags":["pectus-excavatum","bash-on-windows","emacs","powershell"],"childPublishedDate":{"published_on":"2017-02-06T00:00:00.000Z","published_on_unix":1486339200}}}]}},"pageContext":{"number":52}},"staticQueryHashes":[]}