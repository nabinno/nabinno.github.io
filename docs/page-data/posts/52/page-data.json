{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/52","result":{"data":{"esaPost":{"number":52,"relative_category":"blog/backend","fields":{"title":"HerokuとGAEのCIをDockerとパイプラインから構成されたWerckerで管理する","excerpt":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。   > PROBLEMPROBLEM \n\n- パフォーマンス改善のための開発環境がいけてない\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい   > SOLUTIONSOLUTION \n\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。 \n\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。 \n\n1. Dockerで環境を管理。 今回は対応していないですが、GAEのコンテナ（gcr.io/google_appengine/ruby:xxx）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\n2. 異なるサービス間のネットワークをWerckerが生成する環境変数で管理。 Dockerのネットワーク設定の煩雑さを解消します。\n3. タスクをワークフローとしてパイプラインで条件付け管理。 パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。 \n\n次に、Werckerのふるまいを定義するwercker.ymlは、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。    > devパイプラインdevパイプライン \n\ndevパイプラインは wercker dev コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。   yaml \n\nbox: ruby:2.3.1 services: - postgres:9.6.1 - redis:3.0.3 dev: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - internal/watch: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec reload: true     > buildパイプラインbuildパイプライン \n\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。   yaml \n\nbuild: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - script: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec     > deploy-stageパイプラインdeploy-stageパイプライン \n\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。 \n\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。   yaml \n\ndeploy-stage-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - nabinno/heroku-install: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: Fork Application - destroy application code: | heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME - script: name: Fork Application - fork code: | heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME - script: name: Fork Application - setup addons of rediscloud code: | heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME - script: name: Fork Application -change dynos code: | heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME - script: name: Fork Application - change environment variables code: | _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}') heroku config:set \\ S3_BUCKET=$S3_BUCKET \\ HEROKU_APP=$HEROKU_APP_NAME \\ REDISCLOUD_URL=$_rediscloud_url \\ --app $HEROKU_APP_NAME - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-herokuパイプラインdeploy-prod-herokuパイプライン \n\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。   yaml \n\ndeploy-prod-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-gaeパイプラインdeploy-prod-gaeパイプライン \n\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。 \n\nGAEのデプロイは癖があって、gcloud app deployコマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、asset_syncを使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、gcloudのデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は ./public ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。 \n\nGAEのコンテナの中身は、gcloud beta app gen-config --runtime=ruby --custom で出力されるDockerfileを参照ください。   yaml \n\ndeploy-prod-gae: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: DB Migrate code: | RAILS_ENV=production \\ DATABASE_URL=${DATABASE_URL} \\ bundle exec rake db:create db:migrate --trace - script: name: Install gcloud code: | curl https://sdk.cloud.google.com | bash source ~/.bashrc - script: name: Authenticate gcloud code: | gcloud config set project utagaki-v2 openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json gcloud auth activate-service-account --key-file ./gcloud.json - script: name: Deploy app to Google App Engine code: | gcloud app deploy ./app.yaml --promote --stop-previous-version after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > post-deployパイプラインpost-deployパイプライン \n\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に git tag をつけています。   yaml \n\npost-deploy: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git remote add origin git@github.com:nabinno/utagaki.git git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > WRAPUPWRAPUP \n\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。 \n\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png"},"wip":false,"body_md":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。\r\n\r\n# PROBLEM\r\n- パフォーマンス改善のための開発環境がいけてない\r\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい\r\n\r\n# SOLUTION\r\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。\r\n\r\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。\r\n\r\n1. **Dockerで環境を管理。** 今回は対応していないですが、GAEのコンテナ（`gcr.io/google_appengine/ruby:xxx`）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\r\n2. **異なるサービス間のネットワークをWerckerが生成する環境変数で管理。** Dockerのネットワーク設定の煩雑さを解消します。\r\n3. **タスクをワークフローとしてパイプラインで条件付け管理。** パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。\r\n\r\n次に、Werckerのふるまいを定義する`wercker.yml`は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。\r\n\r\n<img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\">\r\n\r\n## devパイプライン\r\ndevパイプラインは `wercker dev` コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。\r\n\r\n``` yaml\r\nbox: ruby:2.3.1\r\nservices:\r\n  - postgres:9.6.1\r\n  - redis:3.0.3\r\n\r\ndev:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - internal/watch:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n        reload: true\r\n```\r\n\r\n## buildパイプライン\r\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。\r\n\r\n``` yaml\r\nbuild:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - script:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n```\r\n\r\n## deploy-stageパイプライン\r\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。\r\n\r\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。\r\n\r\n``` yaml\r\ndeploy-stage-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - nabinno/heroku-install:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - destroy application\r\n        code: |\r\n          heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - fork\r\n        code: |\r\n          heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - setup addons of rediscloud\r\n        code: |\r\n          heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application -change dynos\r\n        code: |\r\n          heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - change environment variables\r\n        code: |\r\n          _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')\r\n          heroku config:set \\\r\n            S3_BUCKET=$S3_BUCKET \\\r\n            HEROKU_APP=$HEROKU_APP_NAME \\\r\n            REDISCLOUD_URL=$_rediscloud_url \\\r\n            --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-herokuパイプライン\r\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。\r\n\r\n``` yaml\r\ndeploy-prod-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n        install-toolbelt: true\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-gaeパイプライン\r\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。\r\n\r\nGAEのデプロイは癖があって、`gcloud app deploy`コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、`asset_sync`を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、`gcloud`のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は `./public` ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。\r\n\r\nGAEのコンテナの中身は、`gcloud beta app gen-config --runtime=ruby --custom` で出力されるDockerfileを参照ください。\r\n\r\n``` yaml\r\ndeploy-prod-gae:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          RAILS_ENV=production \\\r\n            DATABASE_URL=${DATABASE_URL} \\\r\n            bundle exec rake db:create db:migrate --trace\r\n    - script:\r\n        name: Install gcloud\r\n        code: |\r\n          curl https://sdk.cloud.google.com | bash\r\n          source ~/.bashrc\r\n    - script:\r\n        name: Authenticate gcloud\r\n        code: |\r\n          gcloud config set project utagaki-v2\r\n          openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json\r\n          gcloud auth activate-service-account --key-file ./gcloud.json\r\n    - script:\r\n        name: Deploy app to Google App Engine\r\n        code: |\r\n          gcloud app deploy ./app.yaml --promote --stop-previous-version\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## post-deployパイプライン\r\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に `git tag` をつけています。\r\n\r\n``` yaml\r\npost-deploy:\r\n  steps:\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git remote add origin git@github.com:nabinno/utagaki.git\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n# WRAPUP\r\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。\r\n\r\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","body_html":"<p data-sourcepos=\"1:1-1:204\">Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。</p>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-6:0\">\n<li data-sourcepos=\"4:1-4:71\">パフォーマンス改善のための開発環境がいけてない</li>\n<li data-sourcepos=\"5:1-6:0\">別PaaSへ移行するための開発環境が汎用化できてない、つらい</li>\n</ul>\n<h1 data-sourcepos=\"7:1-7:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"8:1-8:272\">というわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。</p>\n<p data-sourcepos=\"10:1-10:154\">まず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。</p>\n<ol data-sourcepos=\"12:1-15:0\">\n<li data-sourcepos=\"12:1-12:296\">\n<strong>Dockerで環境を管理。</strong> 今回は対応していないですが、GAEのコンテナ（<code>gcr.io/google_appengine/ruby:xxx</code>）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。</li>\n<li data-sourcepos=\"13:1-13:168\">\n<strong>異なるサービス間のネットワークをWerckerが生成する環境変数で管理。</strong> Dockerのネットワーク設定の煩雑さを解消します。</li>\n<li data-sourcepos=\"14:1-15:0\">\n<strong>タスクをワークフローとしてパイプラインで条件付け管理。</strong> パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。</li>\n</ol>\n<p data-sourcepos=\"16:1-16:233\">次に、Werckerのふるまいを定義する<code>wercker.yml</code>は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\"></a>\n<h2 data-sourcepos=\"20:1-20:24\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"devパイプライン\" name=\"dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"devパイプライン\"> &gt; devパイプライン</span></a>devパイプライン</h2>\n<p data-sourcepos=\"21:1-21:465\">devパイプラインは <code>wercker dev</code> コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。</p>\n<div class=\"code-block\" data-sourcepos=\"23:1-46:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">box</span><span class=\"pi\">:</span> <span class=\"s\">ruby:2.3.1</span>\n<span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">postgres:9.6.1</span>\n  <span class=\"pi\">-</span> <span class=\"s\">redis:3.0.3</span>\n\n<span class=\"na\">dev</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"s\">internal/watch</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n        <span class=\"na\">reload</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"48:1-48:26\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"buildパイプライン\" name=\"build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"buildパイプライン\"> &gt; buildパイプライン</span></a>buildパイプライン</h2>\n<p data-sourcepos=\"49:1-49:203\">buildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。</p>\n<div class=\"code-block\" data-sourcepos=\"51:1-75:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">build</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"77:1-77:33\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"deploy-stageパイプライン\" name=\"deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-stageパイプライン\"> &gt; deploy-stageパイプライン</span></a>deploy-stageパイプライン</h2>\n<p data-sourcepos=\"78:1-78:331\">deploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。</p>\n<p data-sourcepos=\"80:1-80:130\">他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。</p>\n<div class=\"code-block\" data-sourcepos=\"82:1-164:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-stage-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"s\">nabinno/heroku-install</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - destroy application</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - fork</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - setup addons of rediscloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application -change dynos</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - change environment variables</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')</span>\n          <span class=\"s\">heroku config:set \\</span>\n            <span class=\"s\">S3_BUCKET=$S3_BUCKET \\</span>\n            <span class=\"s\">HEROKU_APP=$HEROKU_APP_NAME \\</span>\n            <span class=\"s\">REDISCLOUD_URL=$_rediscloud_url \\</span>\n            <span class=\"s\">--app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"166:1-166:39\" id=\"2-4-0\" name=\"2-4-0\">\n<a class=\"anchor\" id=\"deploy-prod-herokuパイプライン\" name=\"deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-4-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-herokuパイプライン\"> &gt; deploy-prod-herokuパイプライン</span></a>deploy-prod-herokuパイプライン</h2>\n<p data-sourcepos=\"167:1-167:150\">deploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。</p>\n<div class=\"code-block\" data-sourcepos=\"169:1-231:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n        <span class=\"na\">install-toolbelt</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"233:1-233:36\" id=\"2-5-0\" name=\"2-5-0\">\n<a class=\"anchor\" id=\"deploy-prod-gaeパイプライン\" name=\"deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-5-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-gaeパイプライン\"> &gt; deploy-prod-gaeパイプライン</span></a>deploy-prod-gaeパイプライン</h2>\n<p data-sourcepos=\"234:1-234:186\">deploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。</p>\n<p data-sourcepos=\"236:1-236:787\">GAEのデプロイは癖があって、<code>gcloud app deploy</code>コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、<code>asset_sync</code>を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、<code>gcloud</code>のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は <code>./public</code> ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。</p>\n<p data-sourcepos=\"238:1-238:138\">GAEのコンテナの中身は、<code>gcloud beta app gen-config --runtime=ruby --custom</code> で出力されるDockerfileを参照ください。</p>\n<div class=\"code-block\" data-sourcepos=\"240:1-281:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-gae</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production \\</span>\n            <span class=\"s\">DATABASE_URL=${DATABASE_URL} \\</span>\n            <span class=\"s\">bundle exec rake db:create db:migrate --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">curl https://sdk.cloud.google.com | bash</span>\n          <span class=\"s\">source ~/.bashrc</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Authenticate gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud config set project utagaki-v2</span>\n          <span class=\"s\">openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json</span>\n          <span class=\"s\">gcloud auth activate-service-account --key-file ./gcloud.json</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Deploy app to Google App Engine</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud app deploy ./app.yaml --promote --stop-previous-version</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"283:1-283:32\" id=\"2-6-0\" name=\"2-6-0\">\n<a class=\"anchor\" id=\"post-deployパイプライン\" name=\"post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-6-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"post-deployパイプライン\"> &gt; post-deployパイプライン</span></a>post-deployパイプライン</h2>\n<p data-sourcepos=\"284:1-284:142\">post-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に <code>git tag</code> をつけています。</p>\n<div class=\"code-block\" data-sourcepos=\"286:1-308:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">post-deploy</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git remote add origin git@github.com:nabinno/utagaki.git</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"310:1-310:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"311:1-311:276\">こうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。</p>\n<p data-sourcepos=\"313:1-313:104\">手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。</p>\n","tags":["wercker","docker","heroku","google-app-engine"],"updated_at":"2021-01-16T12:13:04+09:00","childPublishedDate":{"published_on":"2017-02-07T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":60,"relative_category":"blog/backend","fields":{"title":"連載 Rails2Phoenix 2 認証機能を実装する","excerpt":"連載「Rails2Phoenix」になります、前回は「UmbrellaプロジェクトをHerokuにデプロイする 」でした。今回は前回課題としてあがった認証機能の実装を試みたいと思います。   > PROBLEMPROBLEM \n\n- サービスについて 拡張にともない技術スタックがふえるのを抑えたい スケーラビリティのためのコストを抑えたい パフォーマンスをあげたい \n- 拡張にともない技術スタックがふえるのを抑えたい\n- スケーラビリティのためのコストを抑えたい\n- パフォーマンスをあげたい   > SOLUTIONSOLUTION \n\nというわけで、現在つかっているRailsをPhoenixに変更することにしました。方針は以下の通りで、今回はRails/Deviseの認証機能をPhoenixで実装する流れを取り上げます。 \n\n方針 \n\n- Railsから徐々にPhoenixに移行できるように いままでとおなじPaaS（Heroku） いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく いままでとおなじDB 移行完了までDBマイグレーションをしない \n- いままでとおなじPaaS（Heroku）\n- いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく \n- ブランチ戦略は phoenix/base をベースに\n- 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく\n- いままでとおなじDB 移行完了までDBマイグレーションをしない \n- 移行完了までDBマイグレーションをしない\n- Phoenixは今後の拡張性をかんがえてUmbrellaプロジェクトで   > Guardianを実装するGuardianを実装する \n\nまず、参考にしたのはBlackodeのguardian_authです。ただ、Guardianのバージョンがふるいので1.0へのマイグレーション記事をもとにアレンジしてあります。認証に関係しそうな構成は下記の通り。 \n\nロジック \n\n- MyApp.Account\n- MyApp.Account.Registration\n- MyApp.Account.User\n- MyApp.Auth.Guardian\n- MyApp.Auth.ErrorHandler\n- MyApp.Auth.Pipeline\n- MyApp.Auth.AfterPipeline\n- MyApp.Auth.Session \n\nコントローラ \n\n- MyAppWeb.RegistrationController\n- MyAppWeb.SessionController   > シリアライザとエラーハンドラの設定シリアライザとエラーハンドラの設定 \n\nGuardian1.0から直接ではなくモジュールを介して参照するようになりました。下記のように各モジュールを用意してコンフィグに割り当てます。   elixir \n\n# apps/my_app/lib/my_app/auth/guardian.ex defmodule MyApp.Auth.Guardian do use Guardian, otp_app: :my_app alias MyApp.Account def subject_for_token(resource, _claims), do: {:ok, to_string(resource.id)} def subject_for_token(_, _), do: {:error, :reason_for_error} def resource_from_claims(claims), do: {:ok, Account.get_user!(claims[\"sub\"])} def resource_from_claims(_claims), do: {:error, :reason_for_error} end     elixir \n\n# apps/my_app/lib/my_app/auth/error_handler.ex defmodule MyApp.Auth.ErrorHandler do import Plug.Conn def auth_error(conn, {type, _reason}, _opts) do body = Poison.encode!(%{message: to_string(type)}) send_resp(conn, 401, body) end end     elixir \n\n# apps/my_app/config/config.exs config :my_app, MyApp.Auth.Guardian, issuer: \"MyApp\", ttl: {30, :days}, allowed_drift: 2000, # optionals allowed_algos: [\"HS512\"], verify_module: MyApp.Auth.Guardian.JWT, verify_issuer: true, secret_key: System.get_env(\"GUARDIAN_SECRET\") || \"secret_key\"     > ルーターの設定ルーターの設定 \n\n認証のパイプラインは、認証中と認証後のものを用意しコンフィグとルーターに割り当てます。 \n\nルータースコープ内のパイプラインくみあわせについて、ここでは未ログインスコープには認証前・認証中パイプライン、ログイン済スコープには認証前・認証中・認証後パイプラインを適用しています。こうすることでどのスコープにも認証リソースをロードすることができ、かつ、認証も担保することができるようになります。具体的にいうと、ルート / などの同一URLで未ログインスコープとログイン済スコープの切り替えができるようになります。   elixir \n\n# apps/my_app/lib/my_app/auth/pipeline.ex defmodule MyApp.Auth.Pipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.VerifySession, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.VerifyHeader, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.LoadResource, allow_blank: true) end     elixir \n\n# apps/my_app/lib/my_app/auth/after_pipeline.ex defmodule MyApp.Auth.AfterPipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.EnsureAuthenticated) end     elixir \n\n# apps/my_app/lib/my_app_web/router.ex defmodule MyAppWeb.Router do use MyAppWeb, :router pipeline :browser do plug(:accepts, [\"html\"]) plug(:fetch_session) plug(:fetch_flash) plug(:protect_from_forgery) plug(:put_secure_browser_headers) end pipeline :browser_auth do plug(MyApp.Auth.Pipeline) end pipeline :browser_auth_after do plug(MyApp.Auth.AfterPipeline) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth]) post(\"/registration\", RegistrationController, :create) get(\"/login\", SessionController, :new) post(\"/login\", SessionController, :create) get(\"/logout\", SessionController, :delete) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth, :browser_auth_after]) get(\"/edit\", RegistrationController, :edit) put(\"/edit\", RegistrationController, :update) get(\"/users\", UserController, :index) resources \"/\", UserController, only: [:show, :delete], param: \"username\" end end     elixir \n\n# apps/my_app/config/config.exs config :MyApp, MyApp.Auth.Pipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler config :MyApp, MyApp.Auth.AferPipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler     > 登録登録 \n\n登録は登録用のロジック（ユーザーモデルと登録サービス）とコントローラを用意します。 \n\nこのあたりはDevise/Railsとあまり変わりません。他のアクション「新規パスワード発行」「メールアドレス確認」等も同様の構成をとろうと思っています。   elixir \n\n# apps/my_app/lib/my_app_web/controller/registration_controller.ex def create(conn, user_params) do changeset = User.registration_changeset(%User{}, user_params) case Registration.create(changeset, Repo) do {:ok, user} -> conn |> MyApp.Auth.login(user) |> put_flash(:info, \"Your account was created successfully\") |> redirect(to: page_path(conn, :home)) {:error, changeset} -> conn |> put_flash(:error, \"Unable to create account: Try again\") |> render(MyAppWeb.PageView, \"home.html\", changeset: changeset) end end     elixir \n\n# apps/my_app/lib/my_app/auth/auth.ex def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end     elixir \n\n# apps/my_app/lib/my_app/account/registration.ex def create(changeset, repo) do changeset |> repo.insert() end     > ログイン・ログアウトログイン・ログアウト \n\nログイン・ログアウトはセッション用のサービスとコントローラで実装します。   elixir \n\n# apps/my_app/lib/my_app_web/controller/session_controller.ex @doc \"Logged in [POST /login]\" def create(conn, %{\"email\" => email, \"password\" => password}) do case Session.authenticate_user(email, password) do {:ok, user} -> conn |> Session.login(user) |> put_flash(:info, \"Logged in successfully\") |> redirect(to: page_path(conn, :home)) {:error, _reason} -> conn |> put_flash(:error, \"Wrong username/password\") |> render(\"new.html\") end end @doc \"Logged out [DELETE /logout]\" def delete(conn, _params) do conn |> Session.logout() |> put_flash(:info, \"Logged out successfully.\") |> redirect(to: \"/\") end     elixir \n\n# apps/my_app/lib/my_app/auth/session.ex defmodule MyApp.Auth.Session do import Ecto.Query import Plug.Conn import Comeonin.Bcrypt, only: [checkpw: 2, dummy_checkpw: 0] alias MyApp.Repo alias MyApp.Auth.Guardian alias MyApp.Account.User def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end def logout(conn), do: Guardian.Plug.sign_out(conn) def authenticate_user(email, given_password) do query = Ecto.Query.from(u in User, where: u.email == ^email) Repo.one(query) |> check_password(given_password) end def current_user(conn), do: Guardian.Plug.current_resource(conn, []) def logged_in?(conn), do: Guardian.Plug.authenticated?(conn, []) defp check_password(nil, _), do: {:error, \"Incorrect username or password\"} defp check_password(user, given_password) do case Comeonin.Bcrypt.checkpw(given_password, user.encrypted_password) do true -> {:ok, user} false -> {:error, \"Incorrect email or password\"} end end end   \n\nDevise/Railsのビューヘルパーはビューマクロで適用します。   elixir \n\n# apps/my_app/lib/my_app_web.ex def view do quote do # .. import Okuribi.Auth.Session, only: [current_user: 1, logged_in?: 1] end end   \n\nあるいは、put_assigns関数をはやしてコントローラマクロに適用します。   elixir \n\n# apps/my_app/lib/my_app/auth/session.ex def put_assigns(%{private: %{phoenix_action: action}} = conn, settings) do current_resource = Guardian.Plug.current_resource(conn) settings = if current_resource, do: settings[:sign_in][action] || [], else: settings[:sign_out][action] || [] conn |> assign(:current_user, current_resource) |> assign(:page_title, settings[:page_title]) |> assign(:page_description, settings[:page_description]) end     elixir \n\n# apps/my_app/lib/my_app_web.ex def controller do quote do # .. import Okuribi.Auth, only: [put_assigns: 2] end end   \n\nassignsひとつでアクセスできるので、下記のようにコントローラでまとめて指定することでRailsのActionView::Helpers::CaptureHelper#provideの代わりに使えます。   elixir \n\n# apps/my_app/lib/my_app_web/controller/*_controller.ex @page %{ sign_in: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_in.page_title\"), page_description: \"\" } }, sign_out: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_out.page_title\"), page_description: \"\" } } } plug(:put_assigns, @page when action in [:home])     > その他その他 \n\nRailsのビューをPhoenixのテンプレートに移植するには下記の変換を地道に行っていきます。 \n\n- Rails ActionView::Helpers::FormHelper#form_for(record, options={}, &block) ActionView::Helpers::FormHelper#text_field(object_name, method, options={}) ActionView::Helpers::FormHelper#file_field(object_name, method, options={}) ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={}) ActionView::Helpers::FormHelper#password_field(object_name, method, options={}) ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={}) ActionView::Helpers::FormBuilder#submit(value=nil, options={}) ActionView::Helpers::TranslationHelper#t \n- ActionView::Helpers::FormHelper#form_for(record, options={}, &block)\n- ActionView::Helpers::FormHelper#text_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#file_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#password_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={})\n- ActionView::Helpers::FormBuilder#submit(value=nil, options={})\n- ActionView::Helpers::TranslationHelper#t\n- Phoenix Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun) Phoenix.HTML.Form.text_input(form, field, opts \\\\ []) Phoenix.HTML.Form.file_input(form, field, opts \\\\ []) Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ []) Phoenix.HTML.Form.password_input(form, field, opts \\\\ []) Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ []) Phoenix.HTML.Form.submit(opts, opts \\\\ []) Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{}) \n- Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun)\n- Phoenix.HTML.Form.text_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.file_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.password_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ [])\n- Phoenix.HTML.Form.submit(opts, opts \\\\ [])\n- Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{})   > WRAPUPWRAPUP \n\n前回もそうですが、コードのマイグレーションはまあ地味な作業ですよね。とまれ、認証機能を実装できたので良しとしましょう。"},"name":"[2018-05-20]連載 Rails2Phoenix 2 認証機能を実装する","tags":["phoenix-framework","elixir","ruby-on-rails","ruby","wercker","heroku","authentication","guardian"],"childPublishedDate":{"published_on":"2018-05-20T00:00:00.000Z","published_on_unix":1526774400}}},{"node":{"number":59,"relative_category":"blog/backend","fields":{"title":"連載 Rails2Phoenix 1 UmbrellaプロジェクトをHerokuにデプロイする","excerpt":"使い慣れたRailsのプロジェクトを拡張したいのですが、その都度技術スタックを増やす必要があり、この点をどうにかクリアしたいと考えています。連載「Rails2Phoenix」になります、今回はフレームワークをElixir製のPhoenix Frameworkへと変更を試みました。   > PROBLEMPROBLEM \n\n- サービスについて 拡張にともない技術スタックがふえるのを抑えたい スケーラビリティのためのコストを抑えたい パフォーマンスをあげたい \n- 拡張にともない技術スタックがふえるのを抑えたい\n- スケーラビリティのためのコストを抑えたい\n- パフォーマンスをあげたい   > SOLUTIONSOLUTION \n\nというわけで、現在つかっているRailsをPhoenixに変更することにしました。方針は以下の通りで、今回はRailsから移行中のPhoenix UmbrellaプロジェクトをHerokuにデプロイする流れをとりあげます。 \n\n方針 \n\n- Railsから徐々にPhoenixに移行できるように いままでとおなじPaaS（Heroku） いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく いままでとおなじDB 移行完了までDBマイグレーションをしない \n- いままでとおなじPaaS（Heroku）\n- いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく \n- ブランチ戦略は phoenix/base をベースに\n- 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく\n- いままでとおなじDB 移行完了までDBマイグレーションをしない \n- 移行完了までDBマイグレーションをしない\n- Phoenixは今後の拡張性をかんがえてUmbrellaプロジェクトで   > HerokuへのデプロイのながれHerokuへのデプロイのながれ \n\n基本的にドキュメント通り。   > Phoenixアプリケーションを作成Phoenixアプリケーションを作成 \n\nまず、こんな感じでPhoenixの骨組みをつくります。Phoenix関連のファイル apps/, deps/, config/config.exs, mix.exs, mix.lock が追加されます。   sh \n\n> cd rails_project > mix new . --umbrella > (cd ./apps && mix phx.new phoenix_app)   \n\n次に、既存のRailsでつくられたスキーマをPhoenixに移植します。Ripperをつかうとはかどります。ちなみに手動でスキーマをつくりたい場合は、CLI mix phx.gen.schema --no-migration Blog.Post blog_posts title:string で作成します。   rb \n\n# lib/tasks/convert_to_phoenix.rake # こちらはスキーマ移植タスクをPhoenix1.3用に改めたもの require 'ripper' require 'erb' require 'fileutils' namespace :db do namespace :schema do desc 'Convert schema from Rails to Phoenix' task convert_to_phoenix: :environment do ConvertSchemaForPhoenixService.call end end end class ConvertSchemaForPhoenixService class << self def call FileUtils.mkdir_p(File.join('tmp', 'models')) extract_activerecord_define_block( Ripper.sexp( Rails.root .join('db', 'schema.rb') .read ) ).select(&method(:create_table_block?)) .map(&method(:configuration)) .each do |conf| project_name = 'PhoenixApp' table_name = conf[:table_name] table_columns = conf[:table_columns].reject(&method(:reject_condition)) .map do |c| case c[:column_type] when 'text' then c[:column_type] = ':string' when 'datetime' then c[:column_type] = ':naive_datetime' when 'inet' then c[:column_type] = 'EctoNetwork.INET' else c[:column_type] = \":#{c[:column_type]}\" end c end File.write( File.join('tmp', 'models', \"#{conf[:table_name].singularize}.ex\"), template.result(binding) ) end end private def extract_activerecord_define_block(sexp) sexp.dig(1, 0, 2, 2) end def create_table_block?(activerecord_define_block_element_sexp) activerecord_define_block_element_sexp.dig(1, 1, 1) == 'create_table' rescue false end def extract_table_name(create_table_block_sexp) create_table_block_sexp.dig(1, 2, 1, 0, 1, 1, 1) end def extract_table_columns(create_table_block_sexp) create_table_block_sexp.dig(2, 2) end def extract_column_type(table_column_sexp) table_column_sexp.dig(3, 1) end def extract_column_name(table_column_sexp) # Return value of `t.index` is array like ['user_id']. if table_column_sexp.dig(4, 1, 0, 0) == :array return table_column_sexp.dig(4, 1, 0, 1).map { |e| e.dig(1, 1, 1) } end table_column_sexp.dig(4, 1, 0, 1, 1, 1) end def extract_column_option(table_column_sexp) # If is not `column_option`, then `table_column_sexp.dig(4, 1, 1, # 1)` method return nil. Set blank array ([]) for avoiding nil. table_column_sexp.dig(4, 1, 1, 1) || [] end def extract_option_key(column_option_sexp) # Remove colon for avoiding `null:`. column_option_sexp.dig(1, 1).gsub(/:\\z/, '') end def extract_option_value(column_option_sexp) if column_option_sexp.dig(2, 0) == :array return Array(column_option_sexp.dig(2, 1)).map { |e| e.dig(1, 1, 1) } end element = column_option_sexp.dig(2, 1) if element.class != Array return element end case element.dig(0) when :kw then element.dig(1) when :string_content then element.dig(1, 1) || '' end end def template ERB.new(<<'__EOD__', nil, '-') defmodule <%= project_name %>.<%= table_name.classify %> do use Ecto.Schema import Ecto.Changeset alias <%= project_name %>.<%= table_name.classify %> schema \"<%= table_name %>\" do<% table_columns.each do |c| %> field :<%= c[:column_name] -%>, <%= c[:column_type] -%> <% end %> timestamps inserted_at: :created_at end @doc false def changeset(%<%= table_name.classify %>{} = <%= table_name.singularize %>, attrs) do <%= table_name.singularize %> |> cast(attrs, [<%= table_columns.map { |c| \":\" << c[:column_name] }.join(\", \") -%>]) # |> validate_required([<%= table_columns.map { |c| \":\" << c[:column_name] }.join(\", \") -%>]) end end __EOD__ end def configuration(table) { table_name: extract_table_name(table), table_columns: extract_table_columns(table).map do |c| { column_name: extract_column_name(c), column_type: extract_column_type(c), column_option: Hash[extract_column_option(c).map { |o| [extract_option_key(o), extract_option_value(o)] }] } end } end def reject_condition(column) column[:column_name] =~ /\\A(created|updated)_at\\z/ || column[:column_type] == 'index' end end end     sh \n\n> rails db:schema:convert_to_phoenix   \n\n最後に、既存DBへはこんな感じで接続します。   config \n\n# rails_project/apps/phoenix_app/config/dev.exs config :phoenix_app, PhoenixApp.Repo, adapter: Ecto.Adapters.Postgres, url: System.get_env(\"DATABASE_URL\"), pool_size: 10, ssl: true     sh \n\n> (cd ./apps/phoenix_app/assets && npm install) > mix deps.get > mix phx.server     > デプロイのパイプラインを追加デプロイのパイプラインを追加 \n\nさて、既存のCI（Wercker）も更新しましょう。今回はPhoenix関連ブランチが更新された場合にのみ、関連パイプラインを走らせるように下記のように変更しました。 \n\nBEFORE \n\n- build (all branch) deploy.prod (master branch) \n- deploy.prod (master branch) \n\nAFTER \n\n- build (all branch) deploy.prod (master branch) deploy.phoenix.prod (phoenix/base branch) \n- deploy.prod (master branch)\n- deploy.phoenix.prod (phoenix/base branch)   yaml \n\n# wercker.yml deploy-phoenix-prod-heroku: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > Herokuアプリケーションを作成Herokuアプリケーションを作成 \n\n基本ドキュメントの説明通りです。Phoenix Umbrellaプロジェクトの注意点としては、ディレクトリの差異くらいでそれ以外は同じです。つまり、これ rails_project/config/prod.exs をこう rails_project/apps/phoenix_app/config/prod.exs 変更します。 \n\n1. Herokuアプリにビルドパックを適用   sh \n\n> heroku create --buildpack https://github.com/HashNuke/heroku-buildpack-elixir.git > heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git   \n\n2. 起動設定を準備   config \n\n# rails_project/elixir_buildpack.config erlang_version=19.1 elixir_version=1.4.2 always_rebuild=false pre_compile=\"pwd\" post_compile=\"pwd\" runtime_path=/app config_vars_to_export=(DATABASE_URL) config_vars_to_export=(DATABASE_POOL_SIZE)     config \n\n# rails_project/phoenix_static_buildpack.config phoenix_relative_path=apps/phoenix_app     config \n\n# rails_project/Procfile web: MIX_ENV=prod mix phx.server   \n\n3. 環境変数を適用 \n\nデータベース関連。   config \n\n# rails_project/apps/phoenix_app/config/prod.exs config :phoenix_app, PhoenixApp.Repo, adapter: Ecto.Adapters.Postgres, url: System.get_env(\"DATABASE_URL\"), pool_size: String.to_integer(System.get_env(\"DATABASE_POOL_SIZE\") || 10), ssl: true     sh \n\nheroku config:set DATABASE_URL=foo heroku config:set DATABASE_POOL_SIZE=bar   \n\nクレデンシャル関連。   sh \n\n> heroku config:set HEROKU_API_KEY=$(heroku auth:token) > heroku config:set SECRET_KEY_BASE=$(mix phx.gen.secret)     > WRAPUPWRAPUP \n\n大枠は想定通りすんなり進めることが出来ましたが、課題もいくつか出てきました。まずは認証機能。こちらは次回のテーマで取り上げようと思いますが、Railsの認証ライブラリほど充実していないので自前でいくつか用意する必要がありそうです。次にビジネスロジック。これは元のRailsの実装が悪かったので致し方ないのですが、移植するのに時間がかかりそうです。先にRails側を整理してから進めた方が良いかもしれません。"},"name":"[2018-01-08]連載 Rails2Phoenix 1 UmbrellaプロジェクトをHerokuにデプロイする","tags":["phoenix-framework","elixir","ruby-on-rails","ruby","wercker","heroku"],"childPublishedDate":{"published_on":"2018-01-08T00:00:00.000Z","published_on_unix":1515369600}}},{"node":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- 今回作ったコード https://github.com/nabinno/esa.red    > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、 docs.red-lang.org とRed by Exampleをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装しました。 \n\n- 実装した糖衣構文 nabinno/red-elixir  \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。"},"name":"[2019-03-31]イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","tags":["red","esa"],"childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z","published_on_unix":1553990400}}}]}},"pageContext":{"number":52}},"staticQueryHashes":[]}