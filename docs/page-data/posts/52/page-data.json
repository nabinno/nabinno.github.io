{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/52","result":{"data":{"esaPost":{"number":52,"relative_category":"blog/backend","fields":{"title":"HerokuとGAEのCIをDockerとパイプラインから構成されたWerckerで管理する","excerpt":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。   > PROBLEMPROBLEM \n\n- パフォーマンス改善のための開発環境がいけてない\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい   > SOLUTIONSOLUTION \n\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。 \n\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。 \n\n1. Dockerで環境を管理。 今回は対応していないですが、GAEのコンテナ（gcr.io/google_appengine/ruby:xxx）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\n2. 異なるサービス間のネットワークをWerckerが生成する環境変数で管理。 Dockerのネットワーク設定の煩雑さを解消します。\n3. タスクをワークフローとしてパイプラインで条件付け管理。 パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。 \n\n次に、Werckerのふるまいを定義するwercker.ymlは、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。    > devパイプラインdevパイプライン \n\ndevパイプラインは wercker dev コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。   yaml \n\nbox: ruby:2.3.1 services: - postgres:9.6.1 - redis:3.0.3 dev: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - internal/watch: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec reload: true     > buildパイプラインbuildパイプライン \n\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。   yaml \n\nbuild: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - script: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec     > deploy-stageパイプラインdeploy-stageパイプライン \n\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。 \n\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。   yaml \n\ndeploy-stage-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - nabinno/heroku-install: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: Fork Application - destroy application code: | heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME - script: name: Fork Application - fork code: | heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME - script: name: Fork Application - setup addons of rediscloud code: | heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME - script: name: Fork Application -change dynos code: | heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME - script: name: Fork Application - change environment variables code: | _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}') heroku config:set \\ S3_BUCKET=$S3_BUCKET \\ HEROKU_APP=$HEROKU_APP_NAME \\ REDISCLOUD_URL=$_rediscloud_url \\ --app $HEROKU_APP_NAME - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-herokuパイプラインdeploy-prod-herokuパイプライン \n\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。   yaml \n\ndeploy-prod-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-gaeパイプラインdeploy-prod-gaeパイプライン \n\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。 \n\nGAEのデプロイは癖があって、gcloud app deployコマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、asset_syncを使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、gcloudのデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は ./public ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。 \n\nGAEのコンテナの中身は、gcloud beta app gen-config --runtime=ruby --custom で出力されるDockerfileを参照ください。   yaml \n\ndeploy-prod-gae: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: DB Migrate code: | RAILS_ENV=production \\ DATABASE_URL=${DATABASE_URL} \\ bundle exec rake db:create db:migrate --trace - script: name: Install gcloud code: | curl https://sdk.cloud.google.com | bash source ~/.bashrc - script: name: Authenticate gcloud code: | gcloud config set project utagaki-v2 openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json gcloud auth activate-service-account --key-file ./gcloud.json - script: name: Deploy app to Google App Engine code: | gcloud app deploy ./app.yaml --promote --stop-previous-version after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > post-deployパイプラインpost-deployパイプライン \n\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に git tag をつけています。   yaml \n\npost-deploy: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git remote add origin git@github.com:nabinno/utagaki.git git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > WRAPUPWRAPUP \n\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。 \n\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png"},"wip":false,"body_md":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。\r\n\r\n# PROBLEM\r\n- パフォーマンス改善のための開発環境がいけてない\r\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい\r\n\r\n# SOLUTION\r\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。\r\n\r\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。\r\n\r\n1. **Dockerで環境を管理。** 今回は対応していないですが、GAEのコンテナ（`gcr.io/google_appengine/ruby:xxx`）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\r\n2. **異なるサービス間のネットワークをWerckerが生成する環境変数で管理。** Dockerのネットワーク設定の煩雑さを解消します。\r\n3. **タスクをワークフローとしてパイプラインで条件付け管理。** パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。\r\n\r\n次に、Werckerのふるまいを定義する`wercker.yml`は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。\r\n\r\n<img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\">\r\n\r\n## devパイプライン\r\ndevパイプラインは `wercker dev` コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。\r\n\r\n``` yaml\r\nbox: ruby:2.3.1\r\nservices:\r\n  - postgres:9.6.1\r\n  - redis:3.0.3\r\n\r\ndev:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - internal/watch:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n        reload: true\r\n```\r\n\r\n## buildパイプライン\r\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。\r\n\r\n``` yaml\r\nbuild:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - script:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n```\r\n\r\n## deploy-stageパイプライン\r\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。\r\n\r\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。\r\n\r\n``` yaml\r\ndeploy-stage-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - nabinno/heroku-install:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - destroy application\r\n        code: |\r\n          heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - fork\r\n        code: |\r\n          heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - setup addons of rediscloud\r\n        code: |\r\n          heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application -change dynos\r\n        code: |\r\n          heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - change environment variables\r\n        code: |\r\n          _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')\r\n          heroku config:set \\\r\n            S3_BUCKET=$S3_BUCKET \\\r\n            HEROKU_APP=$HEROKU_APP_NAME \\\r\n            REDISCLOUD_URL=$_rediscloud_url \\\r\n            --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-herokuパイプライン\r\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。\r\n\r\n``` yaml\r\ndeploy-prod-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n        install-toolbelt: true\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-gaeパイプライン\r\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。\r\n\r\nGAEのデプロイは癖があって、`gcloud app deploy`コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、`asset_sync`を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、`gcloud`のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は `./public` ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。\r\n\r\nGAEのコンテナの中身は、`gcloud beta app gen-config --runtime=ruby --custom` で出力されるDockerfileを参照ください。\r\n\r\n``` yaml\r\ndeploy-prod-gae:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          RAILS_ENV=production \\\r\n            DATABASE_URL=${DATABASE_URL} \\\r\n            bundle exec rake db:create db:migrate --trace\r\n    - script:\r\n        name: Install gcloud\r\n        code: |\r\n          curl https://sdk.cloud.google.com | bash\r\n          source ~/.bashrc\r\n    - script:\r\n        name: Authenticate gcloud\r\n        code: |\r\n          gcloud config set project utagaki-v2\r\n          openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json\r\n          gcloud auth activate-service-account --key-file ./gcloud.json\r\n    - script:\r\n        name: Deploy app to Google App Engine\r\n        code: |\r\n          gcloud app deploy ./app.yaml --promote --stop-previous-version\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## post-deployパイプライン\r\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に `git tag` をつけています。\r\n\r\n``` yaml\r\npost-deploy:\r\n  steps:\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git remote add origin git@github.com:nabinno/utagaki.git\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n# WRAPUP\r\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。\r\n\r\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","body_html":"<p data-sourcepos=\"1:1-1:204\">Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。</p>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-6:0\">\n<li data-sourcepos=\"4:1-4:71\">パフォーマンス改善のための開発環境がいけてない</li>\n<li data-sourcepos=\"5:1-6:0\">別PaaSへ移行するための開発環境が汎用化できてない、つらい</li>\n</ul>\n<h1 data-sourcepos=\"7:1-7:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"8:1-8:272\">というわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。</p>\n<p data-sourcepos=\"10:1-10:154\">まず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。</p>\n<ol data-sourcepos=\"12:1-15:0\">\n<li data-sourcepos=\"12:1-12:296\">\n<strong>Dockerで環境を管理。</strong> 今回は対応していないですが、GAEのコンテナ（<code>gcr.io/google_appengine/ruby:xxx</code>）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。</li>\n<li data-sourcepos=\"13:1-13:168\">\n<strong>異なるサービス間のネットワークをWerckerが生成する環境変数で管理。</strong> Dockerのネットワーク設定の煩雑さを解消します。</li>\n<li data-sourcepos=\"14:1-15:0\">\n<strong>タスクをワークフローとしてパイプラインで条件付け管理。</strong> パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。</li>\n</ol>\n<p data-sourcepos=\"16:1-16:233\">次に、Werckerのふるまいを定義する<code>wercker.yml</code>は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\"></a>\n<h2 data-sourcepos=\"20:1-20:24\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"devパイプライン\" name=\"dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"devパイプライン\"> &gt; devパイプライン</span></a>devパイプライン</h2>\n<p data-sourcepos=\"21:1-21:465\">devパイプラインは <code>wercker dev</code> コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。</p>\n<div class=\"code-block\" data-sourcepos=\"23:1-46:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">box</span><span class=\"pi\">:</span> <span class=\"s\">ruby:2.3.1</span>\n<span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">postgres:9.6.1</span>\n  <span class=\"pi\">-</span> <span class=\"s\">redis:3.0.3</span>\n\n<span class=\"na\">dev</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"s\">internal/watch</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n        <span class=\"na\">reload</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"48:1-48:26\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"buildパイプライン\" name=\"build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"buildパイプライン\"> &gt; buildパイプライン</span></a>buildパイプライン</h2>\n<p data-sourcepos=\"49:1-49:203\">buildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。</p>\n<div class=\"code-block\" data-sourcepos=\"51:1-75:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">build</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"77:1-77:33\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"deploy-stageパイプライン\" name=\"deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-stageパイプライン\"> &gt; deploy-stageパイプライン</span></a>deploy-stageパイプライン</h2>\n<p data-sourcepos=\"78:1-78:331\">deploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。</p>\n<p data-sourcepos=\"80:1-80:130\">他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。</p>\n<div class=\"code-block\" data-sourcepos=\"82:1-164:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-stage-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"s\">nabinno/heroku-install</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - destroy application</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - fork</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - setup addons of rediscloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application -change dynos</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - change environment variables</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')</span>\n          <span class=\"s\">heroku config:set \\</span>\n            <span class=\"s\">S3_BUCKET=$S3_BUCKET \\</span>\n            <span class=\"s\">HEROKU_APP=$HEROKU_APP_NAME \\</span>\n            <span class=\"s\">REDISCLOUD_URL=$_rediscloud_url \\</span>\n            <span class=\"s\">--app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"166:1-166:39\" id=\"2-4-0\" name=\"2-4-0\">\n<a class=\"anchor\" id=\"deploy-prod-herokuパイプライン\" name=\"deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-4-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-herokuパイプライン\"> &gt; deploy-prod-herokuパイプライン</span></a>deploy-prod-herokuパイプライン</h2>\n<p data-sourcepos=\"167:1-167:150\">deploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。</p>\n<div class=\"code-block\" data-sourcepos=\"169:1-231:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n        <span class=\"na\">install-toolbelt</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"233:1-233:36\" id=\"2-5-0\" name=\"2-5-0\">\n<a class=\"anchor\" id=\"deploy-prod-gaeパイプライン\" name=\"deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-5-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-gaeパイプライン\"> &gt; deploy-prod-gaeパイプライン</span></a>deploy-prod-gaeパイプライン</h2>\n<p data-sourcepos=\"234:1-234:186\">deploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。</p>\n<p data-sourcepos=\"236:1-236:787\">GAEのデプロイは癖があって、<code>gcloud app deploy</code>コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、<code>asset_sync</code>を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、<code>gcloud</code>のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は <code>./public</code> ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。</p>\n<p data-sourcepos=\"238:1-238:138\">GAEのコンテナの中身は、<code>gcloud beta app gen-config --runtime=ruby --custom</code> で出力されるDockerfileを参照ください。</p>\n<div class=\"code-block\" data-sourcepos=\"240:1-281:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-gae</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production \\</span>\n            <span class=\"s\">DATABASE_URL=${DATABASE_URL} \\</span>\n            <span class=\"s\">bundle exec rake db:create db:migrate --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">curl https://sdk.cloud.google.com | bash</span>\n          <span class=\"s\">source ~/.bashrc</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Authenticate gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud config set project utagaki-v2</span>\n          <span class=\"s\">openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json</span>\n          <span class=\"s\">gcloud auth activate-service-account --key-file ./gcloud.json</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Deploy app to Google App Engine</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud app deploy ./app.yaml --promote --stop-previous-version</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"283:1-283:32\" id=\"2-6-0\" name=\"2-6-0\">\n<a class=\"anchor\" id=\"post-deployパイプライン\" name=\"post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-6-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"post-deployパイプライン\"> &gt; post-deployパイプライン</span></a>post-deployパイプライン</h2>\n<p data-sourcepos=\"284:1-284:142\">post-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に <code>git tag</code> をつけています。</p>\n<div class=\"code-block\" data-sourcepos=\"286:1-308:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">post-deploy</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git remote add origin git@github.com:nabinno/utagaki.git</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"310:1-310:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"311:1-311:276\">こうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。</p>\n<p data-sourcepos=\"313:1-313:104\">手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。</p>\n","tags":["wercker","docker","heroku","google-app-engine"],"updated_at":"2021-01-16T12:13:04+09:00","childPublishedDate":{"published_on":"2017-02-07T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":80,"relative_category":"blog/backend","fields":{"title":"AWS Organizationsを別のAWSアカウントに移行する","excerpt":"最近のAWSはCDKの発表に代表されるようにインフラ以外の開発者が触りやすい環境が整ってきています。ただ、こうした機能やリソースを存分に享受するにはIAM管理だけでは不足しており、AWSアカウントの管理方針を大枠で整理する必要が出てきました。今回は深く考えずに使っていたOrganizationsを整理する際にはまったポイントを記していきます。    > PROBLEMPROBLEM \n\n- 初期の頃につくったAWSアカウントにコンソリ請求の便利さからとりあえずOrganizations機能をつけてみた その後、当該アカウントに異なるワークロードのリソースを加えすぎてスケールしづらい構成になってきた 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- その後、当該アカウントに異なるワークロードのリソースを加えすぎてスケールしづらい構成になってきた 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた\n- セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた   > SOLUTIONSOLUTION \n\nというわけで、一旦Organizations機能を解除して新しく作成したAWS管理アカウントに移行していくことにしました。一つ一つの作業は単純なのですが意外と時間がかかることが分かったので備忘として残しておきます。 \n\nOrganizationsのOU構成はサムネイル画像のBEFORE/AFTERの通りです。 \n\nBEFORE：Organization Unitの構成は全然考えずとりあえず追加していました。 \n\n- Foo - AWS Organizationsのオーナーアカウントであり、異なるワークロードや環境が混在しているアカウント\n- Bar - お試し用アカウント1\n- Buzz - お試し用アカウント2 \n\nAFTER：こちらの記事「Best Practices for Organizational Units with AWS Organizations | AWS Management & Governance Blog」を参考に構成しました。 \n\n- Foundation Management - AWS Organizationsのオーナーアカウント Security Infrastructure \n- Management - AWS Organizationsのオーナーアカウント\n- Security\n- Infrastructure\n- Workload Prod Foo Stg FooStg Integ FooInteg \n- Prod Foo \n- Foo\n- Stg FooStg \n- FooStg\n- Integ FooInteg \n- FooInteg\n- Sandbox BarSandbox BuzzSandbox \n- BarSandbox\n- BuzzSandbox   > Organizationsを別アカウントに移行する方法Organizationsを別アカウントに移行する方法 \n\nやったことはこちらの記事「2 つの AWS Organizations 間でアカウントを移動する」の通りですが、いくつかはまるポイントが書かれていないのでそちらも合わせて記します。まず注意点として3つあります。 \n\n一つ目は、Organizationsの移行期間中は請求の種類が3種類になる可能性があります。具体的には「古いOrganizationsによるコンソリ請求」「スタンドアロンのAWSアカウントによる請求」「新しいOrganizationsによるコンソリ請求」です。会社組織としてAWSを利用している場合は経理側との連携が必要になってくるでしょう。 \n\n二つ目は、古いOrganizationsから追加作成されたメンバーアカウントには請求情報の追加と電話番号の認証を行う必要があります。前者の請求情報の追加はそれほど手間ではないのですが、後者の電話番号の認証はAWSサポートを介すため1アカウントごとに3日から1週間ほど時間がかかります。詳細の対応方法はこちらの記事「組織からのメンバーアカウントのリンク解除のエラーを解決する」を参照下さい。 \n\n三つ目は、新しいOrganizationsでは先に制限緩和を行っておきましょう。新しいOrganizationsを作成する際はおそらく古いOrganizationsの時よりもにメンバーアカウントが増えることと思います。特にベストプラクティスのOrganization Unitでアカウントを分けていくとあっという間にデフォルト制限の10を超える可能性が高いです。 \n\n次に移行手順ですが、上記の注意点をクリアしたらほぼ単純作業になります。 \n\n1. 古いOrganizationからメンバーアカウントを削除\n2. 新しいOrganizationからメンバーアカウントに招待を送信\n3. メンバーアカウントで新しいOrganizationへの招待を受け入れる\n4. （全てのメンバーアカウントを削除し終わった後に）古いOrganizationsを削除\n5. 古いOrganizationsの管理アカウントをメンバーアカウントとして新しい Organization に招待   > WRAPUPWRAPUP \n\n昨今のAWSの動きを見ると、インフラ以外の開発者にもAWSを気軽に使えるようになってきており、Organizations機能を使うこと前提にサービスが展開されているようです。なのでこうした恩恵をうけるためにもOrganizationsのベストプラクティスに則ったアカウント構成にする必要があります。 \n\n一応の注意点としては、Organizationsが便利だからといってOrganizationsからメンバーアカウントを追加することは止めた方がいいです。Organizations移行の注意点から分かる通り、Organizationsから追加されたメンバーアカウントには請求情報追加も電話番号認証も行われません。いざ別のOrganizationsに移行する際に想定外の手間と時間をかけないよう、常にスタンドアロンでAWSアカウントを作成するようにしましょう。 \n\nさて、Organizationsの勘所が見えてきたら次はAWS SSOという便利な機能が待っています。AWSを楽しみましょう。"},"name":"AWS Organizationsを別のAWSアカウントに移行する","tags":["aws-organizations"],"childPublishedDate":{"published_on":"2021-05-13T11:39:28.000Z","published_on_unix":1620905968}}},{"node":{"number":55,"relative_category":"blog/backend","fields":{"title":"PositiveSSLをHerokuに適用する","excerpt":"年に1回のSSL更新のイベントです。毎年同じことをすれば良いかというとそうでもなく、販社と卸の都合でSSLの購入方法が微妙に変わります。とは言え、毎年一から調べ直すのも手間なので備忘として記しておきます。   > PROBLEMPROBLEM \n\n- HerokuのSSLの期限がきた   > SOLUTIONSOLUTION \n\n- というわけで、いつも使っているSSL販売代理店SSLs.com（NameCheap社）でPositiveSSL（運用Comodo社）を購入しHerokuに適用します。   > HOWTOHOWTO \n\n1. 証明書を購入する SSL販売代理店であればどこでもいいのですが、昔から使っているので \n2. SSL販売代理店であればどこでもいいのですが、昔から使っているので\n3. 秘密鍵と署名リクエストをつくる 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key 署名リクエスト openssl req -new -key server.key -out server.csr ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました \n4. 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 \n5. 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key \n6. 署名リクエスト openssl req -new -key server.key -out server.csr \n7. ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました\n8. 証明書発行を申請する SSL販売代理店より署名リクエストserver.csrと関連情報を送信します \n9. SSL販売代理店より署名リクエストserver.csrと関連情報を送信します\n10. ドメイン保持の証明をする PositiveSSLの運用会社Comodoに対しドメイン保持の証明します 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります \n11. PositiveSSLの運用会社Comodoに対しドメイン保持の証明します\n12. 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります\n13. Heroku用の証明書をつくる 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n14. 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます\n15. Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n16. Herokuに証明書を適用する 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n17. 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key \n18. heroku addons:add ssl:endpoint\n19. heroku certs:add server.crt server.key\n20. 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n21. heroku certs:update server.crt server.key   > WRAPUPWRAPUP \n\nこのあたりが自動化されれば良いと思いつつ、自動化されたらこのあたりを調べるモチベーションがなくなるので年に一回のリハビリイベントとして位置づけておきます、はい。"},"name":"[2017-04-23]PositiveSSLをHerokuに適用する","tags":[],"childPublishedDate":{"published_on":"2017-04-23T00:00:00.000Z","published_on_unix":1492905600}}},{"node":{"number":47,"relative_category":"blog/organization","fields":{"title":"マネジメントとは何か","excerpt":"組織が大きくなってくると自然と自らの手ではどうしようもできなくなり、マネジメント業務を各メンバーに委譲する必要が出てきます。そうは言っても個別のタスク指示はすんなり出来ても、「よしなにやって」つまり「周辺の整理（マネジメント）も含めて上手くタスクを回せるように調整して」と言う指示は一言では伝えきれません。マネジメント職同士のやりとりなら問題ないのですが、これからマネジメント領域に入っていって欲しいメンバーの場合はどう連携すれば良いのでしょうか。未完ではありますが、今回はマネジメントそのものについて整理しました。   > PROBLEMPROBLEM \n\n- チームメンバーにマネジメントを理解して欲しい けれど、マネジメントに関する書籍が多く、一言でこれを読めと伝えるのが難しい 一方、一言では言い表せないが、一目でなら表せるものが自分の中に出来上がっている 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- けれど、マネジメントに関する書籍が多く、一言でこれを読めと伝えるのが難しい\n- 一方、一言では言い表せないが、一目でなら表せるものが自分の中に出来上がっている 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- ただ、そのことについて書かれた書籍を見たことがない   > SOLUTIONSOLUTION \n\nというわけで、自分の頭の中に出来上がったマネジメントのフレームワークについて改めて整理することにしました。 \n\n私はそのフレームワークを「GRPR（グルーパー）マネジメントサイクル」と呼んでいます。GRPRはゴール（G）、リソース（R）、プロセス（P）、ルール（R）の頭文字の組み合わせです。私はこのGRPRを grouper（熱帯や温帯の海域に分布する魚のハタの意）の略字に見立てることで、マネジメントサイクルをハタの形に重ねて覚えています。下記がそのサイクルです。どうです、ハタに見えませんか? \n\n \n\nこのフレームワークはどの職種にも応用ができ、今までいくつかの職種の中でマネジメントを行ってきましたが、どれも無理なく実施できました。そして、これは各種マネジメント関連の書籍を整理する際の枠組みとしても使えます。この当たりを冗長に書こうとすると切りがないのでここでは完結に記す予定です。 \n\nでは、具体的に各要素を見ていきましょう。   > ゴールゴール \n\n計画と意思決定を行います。これはSMARTに則り戦略的かつ具体的に測定可能で達成可能、関連性のある期限あるものが良いです。下記のようなMBOで設定する目標が分かりやすい例です。 \n\n目標例 \n\n- デザインコーディネーション 組織パターン \n- 組織パターン\n- サービスカタログ   > 変化前のリソースとプロセス変化前のリソースとプロセス \n\nゴールを決めた後にその方向に動き出すための現状把握を行います。対象にはリソースとプロセスがありますが、それらは人も含みます。まずリソースについて、人の場合は意志の状態と価値観の確認を行い、人以外の場合は当該リソースのステータスを確認します。 \n\n- マインドフルネス、アンガーマネジメント、心理的安全性\n- キャリアアンカー \n\nプロセスについては各業務フロー、システムフローを確認します。 \n\n- CMMI   > 変化後のリソースとプロセス変化後のリソースとプロセス \n\n現状を把握した後に目指すべきリソースとプロセスが決まったらそちらに変更を促します。所謂 指示と動機付けを元にした「変更管理」を行います。これはリーダーシップという切り口で語られることが多いマネジメント領域です。   > ルールルール \n\n最後にリソースやプロセスの現状や変化を観察し評価します。この評価によってルールを定め、次のゴールへと段階を上げていきます。なお、ルールはリソースやプロセスに制限をかけるものではありますが、長期的に見た際に安全に業務を回すためのガードレールの役割を果たします。 \n\n例えば、ルールには下記のようなものがあります。 \n\n- 業務運用方針\n- 各パブリッククラウドのIAM設定・運用の方針\n- AWS Control Tower   > WRAPUPWRAPUP \n\n最低限の部分をまとめてみました。まずはメンバーからのフィードバックをもらいつつ今後も気になるところを追加していく予定です。"},"name":"マネジメントとは何か","tags":["team-building"],"childPublishedDate":{"published_on":"2021-03-31T22:39:35.000Z","published_on_unix":1617230375}}}]}},"pageContext":{"number":52}},"staticQueryHashes":[]}