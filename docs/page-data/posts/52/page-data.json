{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/52","result":{"data":{"esaPost":{"number":52,"relative_category":"blog/backend","fields":{"title":"HerokuとGAEのCIをDockerとパイプラインから構成されたWerckerで管理する","excerpt":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。   > PROBLEMPROBLEM \n\n- パフォーマンス改善のための開発環境がいけてない\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい   > SOLUTIONSOLUTION \n\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。 \n\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。 \n\n1. Dockerで環境を管理。 今回は対応していないですが、GAEのコンテナ（gcr.io/google_appengine/ruby:xxx）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\n2. 異なるサービス間のネットワークをWerckerが生成する環境変数で管理。 Dockerのネットワーク設定の煩雑さを解消します。\n3. タスクをワークフローとしてパイプラインで条件付け管理。 パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。 \n\n次に、Werckerのふるまいを定義するwercker.ymlは、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。    > devパイプラインdevパイプライン \n\ndevパイプラインは wercker dev コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。   yaml \n\nbox: ruby:2.3.1 services: - postgres:9.6.1 - redis:3.0.3 dev: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - internal/watch: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec reload: true     > buildパイプラインbuildパイプライン \n\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。   yaml \n\nbuild: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: Setup database code: | RAILS_ENV=test bundle exec rake db:create db:migrate - script: name: Run rspec code: | RAILS_ENV=test bundle exec rake spec     > deploy-stageパイプラインdeploy-stageパイプライン \n\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。 \n\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。   yaml \n\ndeploy-stage-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - nabinno/heroku-install: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: Fork Application - destroy application code: | heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME - script: name: Fork Application - fork code: | heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME - script: name: Fork Application - setup addons of rediscloud code: | heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME - script: name: Fork Application -change dynos code: | heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME - script: name: Fork Application - change environment variables code: | _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}') heroku config:set \\ S3_BUCKET=$S3_BUCKET \\ HEROKU_APP=$HEROKU_APP_NAME \\ REDISCLOUD_URL=$_rediscloud_url \\ --app $HEROKU_APP_NAME - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-herokuパイプラインdeploy-prod-herokuパイプライン \n\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。   yaml \n\ndeploy-prod-heroku: steps: - bundle-install - script: name: Install NodeJS code: | apt-get update apt-get install -y nodejs - script: name: Assets Precompile - restore assets cache code: | [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true mkdir -p $WERCKER_SOURCE_DIR/tmp/cache [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true - script: name: Assets Precompile - main process code: | RAILS_ENV=production bundle exec rake assets:precompile --trace - script: name: Assets Precompile - store assets cache code: | mkdir -p $WERCKER_CACHE_DIR/public/assets cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Assets Precompile - git commit code: | { git add public/assets/.sprockets-manifest-*.json git commit -m 'Run `rake assets:precompile` on Wercker.' } || { echo 'Skip: keep precompiled assets manifest.' } - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true - script: name: DB Migrate code: | heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > deploy-prod-gaeパイプラインdeploy-prod-gaeパイプライン \n\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。 \n\nGAEのデプロイは癖があって、gcloud app deployコマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、asset_syncを使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、gcloudのデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は ./public ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。 \n\nGAEのコンテナの中身は、gcloud beta app gen-config --runtime=ruby --custom で出力されるDockerfileを参照ください。   yaml \n\ndeploy-prod-gae: steps: - bundle-install - script: name: Install ImageMagick code: | apt-get update apt-get install -y nodejs imagemagick - script: name: Echo Ruby information code: | env echo \"ruby version $(ruby --version) running!\" echo \"from location $(which ruby)\" echo -p \"gem list: $(gem list)\" - script: name: DB Migrate code: | RAILS_ENV=production \\ DATABASE_URL=${DATABASE_URL} \\ bundle exec rake db:create db:migrate --trace - script: name: Install gcloud code: | curl https://sdk.cloud.google.com | bash source ~/.bashrc - script: name: Authenticate gcloud code: | gcloud config set project utagaki-v2 openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json gcloud auth activate-service-account --key-file ./gcloud.json - script: name: Deploy app to Google App Engine code: | gcloud app deploy ./app.yaml --promote --stop-previous-version after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > post-deployパイプラインpost-deployパイプライン \n\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に git tag をつけています。   yaml \n\npost-deploy: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git remote add origin git@github.com:nabinno/utagaki.git git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > WRAPUPWRAPUP \n\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。 \n\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png"},"wip":false,"body_md":"Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。\r\n\r\n# PROBLEM\r\n- パフォーマンス改善のための開発環境がいけてない\r\n- 別PaaSへ移行するための開発環境が汎用化できてない、つらい\r\n\r\n# SOLUTION\r\nというわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。\r\n\r\nまず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。\r\n\r\n1. **Dockerで環境を管理。** 今回は対応していないですが、GAEのコンテナ（`gcr.io/google_appengine/ruby:xxx`）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。\r\n2. **異なるサービス間のネットワークをWerckerが生成する環境変数で管理。** Dockerのネットワーク設定の煩雑さを解消します。\r\n3. **タスクをワークフローとしてパイプラインで条件付け管理。** パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。\r\n\r\n次に、Werckerのふるまいを定義する`wercker.yml`は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。\r\n\r\n<img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\">\r\n\r\n## devパイプライン\r\ndevパイプラインは `wercker dev` コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。\r\n\r\n``` yaml\r\nbox: ruby:2.3.1\r\nservices:\r\n  - postgres:9.6.1\r\n  - redis:3.0.3\r\n\r\ndev:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - internal/watch:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n        reload: true\r\n```\r\n\r\n## buildパイプライン\r\nbuildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。\r\n\r\n``` yaml\r\nbuild:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: Setup database\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake db:create db:migrate\r\n    - script:\r\n        name: Run rspec\r\n        code: |\r\n          RAILS_ENV=test bundle exec rake spec\r\n```\r\n\r\n## deploy-stageパイプライン\r\ndeploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。\r\n\r\n他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。\r\n\r\n``` yaml\r\ndeploy-stage-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - nabinno/heroku-install:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - destroy application\r\n        code: |\r\n          heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - fork\r\n        code: |\r\n          heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - setup addons of rediscloud\r\n        code: |\r\n          heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application -change dynos\r\n        code: |\r\n          heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Fork Application - change environment variables\r\n        code: |\r\n          _rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')\r\n          heroku config:set \\\r\n            S3_BUCKET=$S3_BUCKET \\\r\n            HEROKU_APP=$HEROKU_APP_NAME \\\r\n            REDISCLOUD_URL=$_rediscloud_url \\\r\n            --app $HEROKU_APP_NAME\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-herokuパイプライン\r\ndeploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。\r\n\r\n``` yaml\r\ndeploy-prod-heroku:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install NodeJS\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs\r\n    - script:\r\n        name: Assets Precompile - restore assets cache\r\n        code: |\r\n          [ -e $WERCKER_CACHE_DIR/public/assets ] && cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true\r\n          mkdir -p $WERCKER_SOURCE_DIR/tmp/cache\r\n          [ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] && cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true\r\n    - script:\r\n        name: Assets Precompile - main process\r\n        code: |\r\n          RAILS_ENV=production bundle exec rake assets:precompile --trace\r\n    - script:\r\n        name: Assets Precompile - store assets cache\r\n        code: |\r\n          mkdir -p $WERCKER_CACHE_DIR/public/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public\r\n          mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets\r\n          cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Assets Precompile - git commit\r\n        code: |\r\n          {\r\n            git add public/assets/.sprockets-manifest-*.json\r\n            git commit -m 'Run `rake assets:precompile` on Wercker.'\r\n          } || {\r\n            echo 'Skip: keep precompiled assets manifest.'\r\n          }\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n    - heroku-deploy:\r\n        key: $HEROKU_KEY\r\n        user: $HEROKU_USER\r\n        app-name: $HEROKU_APP_NAME\r\n        install-toolbelt: true\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## deploy-prod-gaeパイプライン\r\ndeploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。\r\n\r\nGAEのデプロイは癖があって、`gcloud app deploy`コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、`asset_sync`を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、`gcloud`のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は `./public` ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。\r\n\r\nGAEのコンテナの中身は、`gcloud beta app gen-config --runtime=ruby --custom` で出力されるDockerfileを参照ください。\r\n\r\n``` yaml\r\ndeploy-prod-gae:\r\n  steps:\r\n    - bundle-install\r\n    - script:\r\n        name: Install ImageMagick\r\n        code: |\r\n          apt-get update\r\n          apt-get install -y nodejs imagemagick\r\n    - script:\r\n        name: Echo Ruby information\r\n        code: |\r\n          env\r\n          echo \"ruby version $(ruby --version) running!\"\r\n          echo \"from location $(which ruby)\"\r\n          echo -p \"gem list: $(gem list)\"\r\n    - script:\r\n        name: DB Migrate\r\n        code: |\r\n          RAILS_ENV=production \\\r\n            DATABASE_URL=${DATABASE_URL} \\\r\n            bundle exec rake db:create db:migrate --trace\r\n    - script:\r\n        name: Install gcloud\r\n        code: |\r\n          curl https://sdk.cloud.google.com | bash\r\n          source ~/.bashrc\r\n    - script:\r\n        name: Authenticate gcloud\r\n        code: |\r\n          gcloud config set project utagaki-v2\r\n          openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json\r\n          gcloud auth activate-service-account --key-file ./gcloud.json\r\n    - script:\r\n        name: Deploy app to Google App Engine\r\n        code: |\r\n          gcloud app deploy ./app.yaml --promote --stop-previous-version\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n## post-deployパイプライン\r\npost-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に `git tag` をつけています。\r\n\r\n``` yaml\r\npost-deploy:\r\n  steps:\r\n    - add-ssh-key:\r\n        host: github.com\r\n        keyname: GITHUB\r\n    - add-to-known_hosts:\r\n        hostname: github.com\r\n        fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48\r\n    - script:\r\n        name: Add git-tag\r\n        code: |\r\n          _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)\r\n          git remote add origin git@github.com:nabinno/utagaki.git\r\n          git config --global user.email 'wercker@blahfe.com'\r\n          git config --global user.name 'Wercker Bot'\r\n          git tag -a $_tag master -m 'wercker deploy'\r\n          git push origin $_tag\r\n  after-steps:\r\n    - wantedly/pretty-slack-notify:\r\n        webhook_url: ${SLACK_WEBHOOK_URL}\r\n        channel: general\r\n```\r\n\r\n# WRAPUP\r\nこうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。\r\n\r\n手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。","body_html":"<p data-sourcepos=\"1:1-1:204\">Continuous Integration (CI) が徐々にDockerに対応し始める機運です。先行してWerckerがDocker対応を始めたので、その流れに乗るべくWerckerをDocker化してみました。</p>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-6:0\">\n<li data-sourcepos=\"4:1-4:71\">パフォーマンス改善のための開発環境がいけてない</li>\n<li data-sourcepos=\"5:1-6:0\">別PaaSへ移行するための開発環境が汎用化できてない、つらい</li>\n</ul>\n<h1 data-sourcepos=\"7:1-7:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"8:1-8:272\">というわけで、まずはCI上のDockerに載せてから次の手（GAEあたり）を考えることにしました。CIはWerckerを使用。以前から使っていたのですが、今回はボックスがDockerになったのでそちらに対応しました。</p>\n<p data-sourcepos=\"10:1-10:154\">まず、Werckerは「Docker」「環境変数」による環境管理、「パイプライン」によるワークフロー管理を行っています。</p>\n<ol data-sourcepos=\"12:1-15:0\">\n<li data-sourcepos=\"12:1-12:296\">\n<strong>Dockerで環境を管理。</strong> 今回は対応していないですが、GAEのコンテナ（<code>gcr.io/google_appengine/ruby:xxx</code>）と共通化することもできます。ただし、HerokuのHobby Dynosはプロセス数に制限があるのでコンテナ運用は工夫が必要です。</li>\n<li data-sourcepos=\"13:1-13:168\">\n<strong>異なるサービス間のネットワークをWerckerが生成する環境変数で管理。</strong> Dockerのネットワーク設定の煩雑さを解消します。</li>\n<li data-sourcepos=\"14:1-15:0\">\n<strong>タスクをワークフローとしてパイプラインで条件付け管理。</strong> パイプラインごとにコンテナを立ち上げているので、同じDocker環境でもパイプラインごとに環境変数を分けることが可能です。Herokuのパイプラインでもいいですが、今後別PaaSに移行する可能性を考えてCI管理にbetしました。</li>\n</ol>\n<p data-sourcepos=\"16:1-16:233\">次に、Werckerのふるまいを定義する<code>wercker.yml</code>は、下記シークエンス図のようにパイプラインごとに記述されています。今回は各パイプラインの詳細を見ていくことにします。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"757\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/7fab9f4f-a709-44e9-91bd-95974de3ade4.png\"></a>\n<h2 data-sourcepos=\"20:1-20:24\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"devパイプライン\" name=\"dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#dev%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"devパイプライン\"> &gt; devパイプライン</span></a>devパイプライン</h2>\n<p data-sourcepos=\"21:1-21:465\">devパイプラインは <code>wercker dev</code> コマンドをローカルでたたく際に使います。下記の例だとRSpec走らせているだけなのでおまけ程度。ただ、ローカル開発でDockerを使うことになったらこういう提案もありだと思います。プロジェクトレポジトリすべてをDockerにしてローカル開発するペイン、所謂git-dockerのバージョン管理問題があるので代替案として。</p>\n<div class=\"code-block\" data-sourcepos=\"23:1-46:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">box</span><span class=\"pi\">:</span> <span class=\"s\">ruby:2.3.1</span>\n<span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">postgres:9.6.1</span>\n  <span class=\"pi\">-</span> <span class=\"s\">redis:3.0.3</span>\n\n<span class=\"na\">dev</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"s\">internal/watch</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n        <span class=\"na\">reload</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"48:1-48:26\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"buildパイプライン\" name=\"build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#build%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"buildパイプライン\"> &gt; buildパイプライン</span></a>buildパイプライン</h2>\n<p data-sourcepos=\"49:1-49:203\">buildパイプラインもdevパイプラインと同じDockerボックスを使っています。やっていることはdevパイプラインと変わらず、すべてのブランチで走ります。</p>\n<div class=\"code-block\" data-sourcepos=\"51:1-75:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">build</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Setup database</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake db:create db:migrate</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Run rspec</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=test bundle exec rake spec</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"77:1-77:33\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"deploy-stageパイプライン\" name=\"deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-stage%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-stageパイプライン\"> &gt; deploy-stageパイプライン</span></a>deploy-stageパイプライン</h2>\n<p data-sourcepos=\"78:1-78:331\">deploy-stageパイプラインはステージング環境用。現在Herokuを本番環境で利用しているので、デプロイごとにそれをフォークして環境構築しています。また、Railsのアセットプリコンパイルの時間短縮はほかのCIと同様にキャッシュを利用しています。</p>\n<p data-sourcepos=\"80:1-80:130\">他のPaaSに移った場合に現在行っている本番環境のフォークをどうするかが検討課題となります。</p>\n<div class=\"code-block\" data-sourcepos=\"82:1-164:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-stage-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"s\">nabinno/heroku-install</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - destroy application</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - fork</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku fork --from $FROM_HEROKU_APP_NAME --to $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - setup addons of rediscloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku addons:create rediscloud:30 --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application -change dynos</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku ps:scale web=1:Free worker=1:Free --app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Fork Application - change environment variables</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_rediscloud_url=$(heroku run 'env | grep -e REDISCLOUD_.*_URL' --app $HEROKU_APP_NAME | awk -F= '{print $2}')</span>\n          <span class=\"s\">heroku config:set \\</span>\n            <span class=\"s\">S3_BUCKET=$S3_BUCKET \\</span>\n            <span class=\"s\">HEROKU_APP=$HEROKU_APP_NAME \\</span>\n            <span class=\"s\">REDISCLOUD_URL=$_rediscloud_url \\</span>\n            <span class=\"s\">--app $HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"166:1-166:39\" id=\"2-4-0\" name=\"2-4-0\">\n<a class=\"anchor\" id=\"deploy-prod-herokuパイプライン\" name=\"deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-heroku%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-4-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-herokuパイプライン\"> &gt; deploy-prod-herokuパイプライン</span></a>deploy-prod-herokuパイプライン</h2>\n<p data-sourcepos=\"167:1-167:150\">deploy-prod-herokuパイプラインは本番環境へのリリース用。環境変数以外はdeploy-stageパイプラインと同じものです。</p>\n<div class=\"code-block\" data-sourcepos=\"169:1-231:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-heroku</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install NodeJS</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - restore assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/public/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/public/assets $WERCKER_SOURCE_DIR/public || true</span>\n          <span class=\"s\">mkdir -p $WERCKER_SOURCE_DIR/tmp/cache</span>\n          <span class=\"s\">[ -e $WERCKER_CACHE_DIR/tmp/cache/assets ] &amp;&amp; cp -fr $WERCKER_CACHE_DIR/tmp/cache/assets $WERCKER_SOURCE_DIR/tmp/cache || true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - main process</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production bundle exec rake assets:precompile --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - store assets cache</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/public/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/public/assets $WERCKER_CACHE_DIR/public</span>\n          <span class=\"s\">mkdir -p $WERCKER_CACHE_DIR/tmp/cache/assets</span>\n          <span class=\"s\">cp -fr $WERCKER_SOURCE_DIR/tmp/cache/assets $WERCKER_CACHE_DIR/tmp/cache</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Assets Precompile - git commit</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">{</span>\n            <span class=\"s\">git add public/assets/.sprockets-manifest-*.json</span>\n            <span class=\"s\">git commit -m 'Run `rake assets:precompile` on Wercker.'</span>\n          <span class=\"s\">} || {</span>\n            <span class=\"s\">echo 'Skip: keep precompiled assets manifest.'</span>\n          <span class=\"s\">}</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n    <span class=\"pi\">-</span> <span class=\"na\">heroku-deploy</span><span class=\"pi\">:</span>\n        <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_KEY</span>\n        <span class=\"na\">user</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_USER</span>\n        <span class=\"na\">app-name</span><span class=\"pi\">:</span> <span class=\"s\">$HEROKU_APP_NAME</span>\n        <span class=\"na\">install-toolbelt</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">heroku run 'bundle exec rake db:migrate --trace' --app $HEROKU_APP_NAME</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"233:1-233:36\" id=\"2-5-0\" name=\"2-5-0\">\n<a class=\"anchor\" id=\"deploy-prod-gaeパイプライン\" name=\"deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#deploy-prod-gae%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-5-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"deploy-prod-gaeパイプライン\"> &gt; deploy-prod-gaeパイプライン</span></a>deploy-prod-gaeパイプライン</h2>\n<p data-sourcepos=\"234:1-234:186\">deploy-prod-gaeパイプラインはdeploy-prod-herokuパイプラインと同じく本番環境へのリリース用。GAEにいつでも移行できるように走らせています。</p>\n<p data-sourcepos=\"236:1-236:787\">GAEのデプロイは癖があって、<code>gcloud app deploy</code>コマンドをつかってDockerビルドを走らせますが、その時にDocker内に外部から環境変数を設定することができません。そのため、アセットプリコンパイルのビルドの際、<code>asset_sync</code>を使っていると別サーバーへ同期に失敗します。また、パイプライン上の別ステップに環境変数を当てて行うことはできるが、<code>gcloud</code>のデプロイステップとアセットプリコンパイルが重複して適切なダイジェストを発行できません。従って、GAEをつかう場合は <code>./public</code> ディレクトリをつかうのが現状の正解です。HerokuのSlugの取り扱い方針と違うので注意が必要です。</p>\n<p data-sourcepos=\"238:1-238:138\">GAEのコンテナの中身は、<code>gcloud beta app gen-config --runtime=ruby --custom</code> で出力されるDockerfileを参照ください。</p>\n<div class=\"code-block\" data-sourcepos=\"240:1-281:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">deploy-prod-gae</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">bundle-install</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install ImageMagick</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">apt-get update</span>\n          <span class=\"s\">apt-get install -y nodejs imagemagick</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Echo Ruby information</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">env</span>\n          <span class=\"s\">echo \"ruby version $(ruby --version) running!\"</span>\n          <span class=\"s\">echo \"from location $(which ruby)\"</span>\n          <span class=\"s\">echo -p \"gem list: $(gem list)\"</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">DB Migrate</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">RAILS_ENV=production \\</span>\n            <span class=\"s\">DATABASE_URL=${DATABASE_URL} \\</span>\n            <span class=\"s\">bundle exec rake db:create db:migrate --trace</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Install gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">curl https://sdk.cloud.google.com | bash</span>\n          <span class=\"s\">source ~/.bashrc</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Authenticate gcloud</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud config set project utagaki-v2</span>\n          <span class=\"s\">openssl aes-256-cbc -k ${DECRYPT_KEY} -d -in ./gcloud.json.encrypted -out ./gcloud.json</span>\n          <span class=\"s\">gcloud auth activate-service-account --key-file ./gcloud.json</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Deploy app to Google App Engine</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">gcloud app deploy ./app.yaml --promote --stop-previous-version</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"283:1-283:32\" id=\"2-6-0\" name=\"2-6-0\">\n<a class=\"anchor\" id=\"post-deployパイプライン\" name=\"post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" href=\"#post-deploy%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3\" data-position=\"2-6-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"post-deployパイプライン\"> &gt; post-deployパイプライン</span></a>post-deployパイプライン</h2>\n<p data-sourcepos=\"284:1-284:142\">post-deployパイプラインは本番環境にデプロイした後の後処理用です。参考程度に <code>git tag</code> をつけています。</p>\n<div class=\"code-block\" data-sourcepos=\"286:1-308:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">post-deploy</span><span class=\"pi\">:</span>\n  <span class=\"na\">steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-ssh-key</span><span class=\"pi\">:</span>\n        <span class=\"na\">host</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">keyname</span><span class=\"pi\">:</span> <span class=\"s\">GITHUB</span>\n    <span class=\"pi\">-</span> <span class=\"na\">add-to-known_hosts</span><span class=\"pi\">:</span>\n        <span class=\"na\">hostname</span><span class=\"pi\">:</span> <span class=\"s\">github.com</span>\n        <span class=\"na\">fingerprint</span><span class=\"pi\">:</span> <span class=\"s\">16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</span>\n    <span class=\"pi\">-</span> <span class=\"na\">script</span><span class=\"pi\">:</span>\n        <span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Add git-tag</span>\n        <span class=\"na\">code</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>\n          <span class=\"s\">_tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S)</span>\n          <span class=\"s\">git remote add origin git@github.com:nabinno/utagaki.git</span>\n          <span class=\"s\">git config --global user.email 'wercker@blahfe.com'</span>\n          <span class=\"s\">git config --global user.name 'Wercker Bot'</span>\n          <span class=\"s\">git tag -a $_tag master -m 'wercker deploy'</span>\n          <span class=\"s\">git push origin $_tag</span>\n  <span class=\"na\">after-steps</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">wantedly/pretty-slack-notify</span><span class=\"pi\">:</span>\n        <span class=\"na\">webhook_url</span><span class=\"pi\">:</span> <span class=\"s\">${SLACK_WEBHOOK_URL}</span>\n        <span class=\"na\">channel</span><span class=\"pi\">:</span> <span class=\"s\">general</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"310:1-310:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"311:1-311:276\">こうしてWerckerの設定ファイルを書いてみるに、どのCI、どの仮想環境も同じ書き味ということが分かります。当処懸念していたDocker化することによる嵌まり事はなく、すんなり移行することができました。</p>\n<p data-sourcepos=\"313:1-313:104\">手軽さ、管理のしやすさから、今後はすべてのCIがDockerに移行するでしょう。</p>\n","tags":["wercker","docker","heroku","google-app-engine"],"updated_at":"2021-01-16T12:13:04+09:00","childPublishedDate":{"published_on":"2017-02-07T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":124,"relative_category":"blog/backend","fields":{"title":"Increment Pは住所のバリデーションチェックでどの程度使えるか","excerpt":"7月に調査した「imi-enrichment-addressは住所のバリデーションチェックでどの程度使えるか」の続きになります。コロナ禍であらゆる流通がオンラインに移行する中、正しい住所を使うことはいっそう求められています。ユーザーが配送用に住所を入力する時そのデータが正しいとどうやって判定するのでしょうか。今回は商用サービスIncrement Pが住所のバリデーションチェックでどの程度使えるか検証してみました。   > PROBLEMPROBLEM \n\n- 住所の不備が至るところで起きている 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい imi-enrichment-addressで精度が思わしくなかったので今回は商用サービスで検証したい \n- 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい\n- 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい imi-enrichment-addressで精度が思わしくなかったので今回は商用サービスで検証したい \n- imi-enrichment-addressで精度が思わしくなかったので今回は商用サービスで検証したい  > SOLUTIONSOLUTION \n\nというわけで、住所のバリデーションチェックで商用版「Increment P」がどの程度使えるか検証します。  > Increment PとはIncrement Pとは \n\n住所をAPIを介すことで正規化することができます。APIの返値に解析レベル・解析ログを返すことでより柔軟な検証をおこなうことができるようになっています。 \n\n解析レベルとは、対象住所のマッチ度合いを都道府県・市区町村・町域・丁目・番地・号というレベルで分けたものです。APIの結果が解析レベル5「番地・番」以上になっていれば配送が確実に為されると言うように、配送の確実性を前提にして住所の入力者とやりとりを実現します。また、解析ログメッセージとは、住所の正規化を試みた際のログであり、バリデーションを調整する際に頻繁に確認するものです。詳細は「ドキュメント」をご覧下さい。    解析レベル レベルの数字 説明     都道府県 1 県レベルでマッチしました   市区町村 2 市区町村レベルでマッチしました   町域 (大字) 3 町域レベルでマッチしました   丁目 / 小字 4 丁目または小字レベルでマッチしました   番地（番） 5 番地（番）レベルでマッチしました   号情報が存在しない番地 7 番地（番）レベルでマッチしました（号情報が存在しない地域）   号 8 号レベルでマッチしました   不明 -1 不明    \n\n試しにIncrement Pを実行してみましょう。正確な住所を渡したときと不正確な住所を渡したときで解析レベルが5と3と異なった結果を返すことが見て取れます。 sh\n\n$ curl \"https://api-anorm.mapfan.com/v1/$(echo -n 長野県長野市大字長野旭町1108 | jq -sRr @uri).json\" \\ -H 'x-api-key: <api-key>' \\ -H 'Content-Type: application/json' | jq -r { \"type\": \"FeatureCollection\", \"query\": [ \"長野県長野市大字長野旭町1108\" ], \"features\": [ { \"type\": \"Feature\", \"geometry\": null, \"properties\": { \"query\": \"長野県長野市大字長野旭町1108\", \"place_name\": \"長野県長野市長野旭町 1108\", \"pref\": \"長野県\", \"pref_kana\": \"ナガノケン\", \"city\": \"長野市\", \"city_kana\": \"ナガノシ\", \"area\": \"長野\", \"area_kana\": \"ナガノ\", \"koaza_chome\": \"旭町\", \"koaza_chome_kana\": \"アサヒマチ\", \"banchi_go\": \"1108\", \"building\": \"\", \"building_number\": \"\", \"zipcode\": \"3800846\", \"geocoding_level\": 5, \"geocoding_level_desc\": \"番地（番）レベルでマッチしました(5)\", \"log\": \"RM002:[大字(字)]の文字を除去しました\", \"not_normalized\": \"\" } } ], \"attribution\": \"(c) INCREMENT P CORPORATION\" } $ curl \"https://api-anorm.mapfan.com/v1/$(echo -n 長野県長野市旭町1108 | jq -sRr @uri).json\" \\ -H 'x-api-key: <api-key>' \\ -H 'Content-Type: application/json' | jq -r { \"type\": \"FeatureCollection\", \"query\": [ \"長野県長野市旭町1108\" ], \"features\": [ { \"type\": \"Feature\", \"geometry\": null, \"properties\": { \"query\": \"長野県長野市旭町1108\", \"place_name\": \"長野県長野市旭町\", \"pref\": \"長野県\", \"pref_kana\": \"ナガノケン\", \"city\": \"長野市\", \"city_kana\": \"ナガノシ\", \"area\": \"旭町\", \"area_kana\": \"アサヒマチ\", \"koaza_chome\": \"\", \"koaza_chome_kana\": \"\", \"banchi_go\": \"\", \"building\": \"\", \"building_number\": \"\", \"zipcode\": \"3800846\", \"geocoding_level\": 3, \"geocoding_level_desc\": \"町域レベルでマッチしました(3)\", \"log\": \"NT001:正規化処理状況が建物名正規化処理の必要条件を満たさないので建物名正規化は行われません\", \"not_normalized\": \"1108\" } } ], \"attribution\": \"(c) INCREMENT P CORPORATION\" }  \n\nなお、上記結果を見て分かるとおり、Increment Pは大字省略には強そうですが町域自体の省略は苦手なようです。imi-enrichment-addressより柔軟ですが、基本は街区レベル位置参照情報を利用しているように推察されます。  > 検証用データ検証用データ \n\nさて、検証用データですが、imi-enrichment-addressの検証データと合わせて住所.jpを使います。今回はトライアルが1000件と制限があるので、imi-enrichment-addressで無効割合が54.42%と一番多かった青森県と住所の登録数が多い東京・愛知・北海道・大阪・福岡・神奈川、さらに通りが独特な京都、町字の組み合わせで住所が2つ以上存在する長野に対象を絞ります。各々100件ずつの検証になります。 sh\n\n$ { curl -sSL http://jusyo.jp/downloads/new/csv/csv_zenkoku.zip -o csv_zenkoku.zip; unzip -p csv_zenkoku.zip | nkf -w; rm csv_zenkoku.zip } >zenkoku.csv $ brew install noborus/tap/trdsql $ trdsql \" SELECT COUNT(*) FROM zenkoku.csv WHERE c21 <> '' \" 22431 $ trdsql -otbln \" SELECT c8, count(*) cn FROM zenkoku.csv WHERE c21 != '' GROUP BY c8 ORDER BY cn DESC\" | 都道府県 | count(*) | | --- | --- | | 東京都 | 4734 | | 愛知県 | 1541 | | 北海道 | 1251 | | 大阪府 | 884 | | 福岡県 | 845 | | 神奈川県 | 820 | [..] | 長野県 | 594 | [..] | 京都府 | 255 | [..] | 青森県 | 216 |   > Increment Pで検証用データを確認するIncrement Pで検証用データを確認する sh\n\n$ for p in 東京都 愛知県 北海道 大阪府 福岡県 神奈川県 青森県 京都府 長野県; do for a in $(trdsql \" SELECT c8||c10||c21 FROM zenkoku.csv WHERE c21 != '' AND c8 = '$p' ORDER BY RANDOM() LIMIT 100 \"); do curl -w'\\n' \"https://api-anorm.mapfan.com/v1/$(echo -n $a | jq -sRr @uri).json\" \\ -H 'x-api-key: <api-key>' \\ -H 'Content-Type: application/json' >>output.jsonl; done & done &   > 解析結果を確認する解析結果を確認する \n\nIncrement Pの解析結果を確認したところ、imi-enrichment-addressと比べると大方改善しました。特に青森県、北海道の改善率は高く字・条・線に対して有効に機能していることが伺えます。一方、京都や長野のように特殊な住所がある府県については改善が思うように行かないケースもあるようです。 sh\n\n$ cat output.jsonl \\ | jq -r '[ .features[].properties.pref, .features[].properties.query, .features[].properties.geocoding_level, .features[].properties.log ] | @csv' \\ | trdsql -otbln \" SELECT c1, COUNT(*) cn FROM - WHERE c3 >= 5 GROUP BY c1 ORDER BY cn DESC \"  \n\n解析レベル5「番地・番」以上の場合（※ 参考値はimi-enrichment-addressの有効割合）    都道府県 有効割合 参考値     東京都 100 99.11   大阪府 100 96.72   福岡県 95 91   神奈川県 95 98.28   愛知県 92 92.6   青森県 90 45.58   長野県 84 55.72   北海道 80 86.24   京都府 79 63.14    \n\n解析レベル4「丁目/小字」以上の場合（※ 参考値はimi-enrichment-addressの有効割合）    都道府県 有効割合 参考値     東京都 100 99.11   大阪府 100 96.72   北海道 98 86.24   愛知県 97 92.6   福岡県 96 91   神奈川県 95 98.28   青森県 93 45.58   長野県 84 55.72   京都府 79 63.14     > WRAPUPWRAPUP \n\n青森県の有効率が45.58%だったimi-enrichment-addressと比べると、Increment Pは調査した大凡の都道府県で改善し70%以上の有効割合を出していました。バリデーションチェックで使えるのかというと全ての都道府県で100%になっていないため心許ない状況ではあるものの、解析レベル4「丁目/小字」以下の住所については最終確認を促すフローを入れる等ひと手間加えれば実用に耐えうると考えます。"},"name":"[2021-11-23]Increment Pは住所のバリデーションチェックでどの程度使えるか","tags":["incrementp"],"childPublishedDate":{"published_on":"2021-11-23T00:00:00.000Z","published_on_unix":1637625600}}},{"node":{"number":119,"relative_category":"blog/backend","fields":{"title":"踏み台をSSM Session ManagerとAWS SSOで実現する","excerpt":"踏み台のユーザーが増えてきたため公開鍵管理や監視と運用負荷が上がってきました。オペミスが発生しやすい上 監査的な意味で無視できない状況になってきたので重い腰を上げることにしました。   > PROBLEMPROBLEM \n\n- EC2インスタンスの踏み台運用がつらい 公開鍵管理がつらい 提出・設定・確認ともに運用コストがかかる AWSアカウント数 x ユーザー数で指数関数的に運用コストが増していくことが想定される インフラ管理が分散していると、提出側・設定側ともに重複コストが発生する 監視運用がつらい 定期的に踏み台がブルートフォース攻撃を受けており、脅威が低いとは言えストレスがかかる 踏み台アクセスへの監査ログが不十分 \n- 公開鍵管理がつらい 提出・設定・確認ともに運用コストがかかる AWSアカウント数 x ユーザー数で指数関数的に運用コストが増していくことが想定される インフラ管理が分散していると、提出側・設定側ともに重複コストが発生する \n- 提出・設定・確認ともに運用コストがかかる\n- AWSアカウント数 x ユーザー数で指数関数的に運用コストが増していくことが想定される\n- インフラ管理が分散していると、提出側・設定側ともに重複コストが発生する\n- 監視運用がつらい 定期的に踏み台がブルートフォース攻撃を受けており、脅威が低いとは言えストレスがかかる 踏み台アクセスへの監査ログが不十分 \n- 定期的に踏み台がブルートフォース攻撃を受けており、脅威が低いとは言えストレスがかかる\n- 踏み台アクセスへの監査ログが不十分  > SOLUTIONSOLUTION \n\nというわけで、Session ManagerとSSOでアクセス管理の効率化を狙います。  > 踏み台サーバーの設定踏み台サーバーの設定 \n\nまず、データフローとしては下記の図の通りで、今回はプライベートサブネット上にEC2を置いて素のSession ManagerでDBへの接続することにします。当該インスタンスは AmazonSSMManagedInstanceCore ポリシー1を含んだロールを適用。なお、ECS ExecではSession Managerでポートフォワーディングを実現でき無かったことに加え、既存の踏み台資産を流用するため今回の実装対象から外しました。 \n\n  > SSOの設定SSOの設定 \n\n踏み台サーバーの設定が終わったら、次に当該インスタンスへ接続するためにSSOで渡すロールをアクセス権限セットに設定します。下記カスタムポリシーはEC2インスタンスにアクセスするための必要最低限のものになります。 カスタムポリシー json\n\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"cloudwatch:PutMetricData\", \"ds:CreateComputer\", \"ds:DescribeDirectories\", \"ec2:DescribeInstanceStatus\", \"logs:*\", \"ssm:*\", \"ec2messages:*\" ], \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": [ \"ssm:StartSession\" ], \"Resource\": [ \"arn:aws:ssm:*:*:session/<EC2インスタンスID>\", \"arn:aws:ec2:*:*:instance/<EC2インスタンスID>\" ] }, { \"Effect\": \"Deny\", \"Action\": [ \"ssm:Describe*\", \"ssm:Get*\", \"ssm:List*\", \"logs:Describe*\", \"logs:Get*\", \"logs:List*\" ], \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"iam:CreateServiceLinkedRole\", \"Resource\": \"arn:aws:iam::*:role/aws-service-role/ssm.amazonaws.com/AWSServiceRoleForAmazonSSM*\", \"Condition\": { \"StringLike\": { \"iam:AWSServiceName\": \"ssm.amazonaws.com\" } } }, { \"Effect\": \"Allow\", \"Action\": \"iam:CreateServiceLinkedRole\", \"Resource\": \"arn:aws:iam::*:role/aws-service-role/ssm.amazonaws.com/AWSServiceRoleForAmazonSSM*\", \"Condition\": { \"StringLike\": { \"iam:AWSServiceName\": \"ssm.amazonaws.com\" } } }, { \"Effect\": \"Allow\", \"Action\": [ \"iam:DeleteServiceLinkedRole\", \"iam:GetServiceLinkedRoleDeletionStatus\" ], \"Resource\": \"arn:aws:iam::*:role/aws-service-role/ssm.amazonaws.com/AWSServiceRoleForAmazonSSM*\" }, { \"Effect\": \"Allow\", \"Action\": [ \"ssmmessages:CreateControlChannel\", \"ssmmessages:CreateDataChannel\", \"ssmmessages:OpenControlChannel\", \"ssmmessages:OpenDataChannel\" ], \"Resource\": \"*\" } ] }    > セッションを張るための事前準備セッションを張るための事前準備 \n\nセッションを張るためには下記3つの手順が必要になります。SSO経由のセッション設定が2通りありますが、クレデンシャル方式はセッションが切れる毎に変更する手間があるため、CLI方式をお薦めします。 \n\n1. AWS CLI v2をインストール\n2. 下記いずれかの方式でSSO経由のセッション設定を行う クレデンシャル方式 CLI（ aws sso login ）方式 \n3. クレデンシャル方式\n4. CLI（ aws sso login ）方式\n5. Session Manager プラグインをインストール  > DBクライアントの設定DBクライアントの設定 \n\n最後に、DBクライアントについて3つの手順を踏んで接続を試みます2。なお、ローカル環境でポートフォワーディングを都度行うのを省略したい方は、DataGripを利用すると良いでしょう。 \n\n1. ローカル環境にて ~/.ssh/config ファイルを編集 Session Managerにproxyと対象RDSのエンドポイントを記載 configHost <任意のhost名> HostName <※ 指定しなければlocalhostになる> User ec2-user ProxyCommand sh -c \"aws ssm start-session --target <接続する踏み台のインスタンスID> --document-name AWS-StartSSHSession --parameters 'portNumber=%p' --region ap-northeast-1 --profile <プロフィール>\" LocalForward <任意のポート> <RDSエンドポイント>:<RDSポート> IdentityFile ~/.ssh/<EC2に接続する秘密鍵> 設定したhost名でセッションマネージャー越しにssh接続できるかを確認 sh$ ssh <設定したhost名> \n2. Session Managerにproxyと対象RDSのエンドポイントを記載 configHost <任意のhost名> HostName <※ 指定しなければlocalhostになる> User ec2-user ProxyCommand sh -c \"aws ssm start-session --target <接続する踏み台のインスタンスID> --document-name AWS-StartSSHSession --parameters 'portNumber=%p' --region ap-northeast-1 --profile <プロフィール>\" LocalForward <任意のポート> <RDSエンドポイント>:<RDSポート> IdentityFile ~/.ssh/<EC2に接続する秘密鍵> \n3. 設定したhost名でセッションマネージャー越しにssh接続できるかを確認 sh$ ssh <設定したhost名> \n4. 手順1で設定したsshで接続することでポートフォワーディング\n5. DBクライアントで下記のように接続情報を設定し接続する Host: <手順1のconfigファイルにて任意指定したホスト名> Port: <手順4のconfigファイルにて任意指定したポート> 他項目: DB接続情報 \n6. Host: <手順1のconfigファイルにて任意指定したホスト名>\n7. Port: <手順4のconfigファイルにて任意指定したポート>\n8. 他項目: DB接続情報  > WRAPUPWRAPUP \n\nパブリックサブネット上の踏み台に慣れている方は馴染みのない方法に戸惑うかも知れませんが、踏み台資産を流用できるという意味で導入のコストもそれほどかかりませんし、ユーザーとしても利用の敷居は高くありませんでした。後々の管理コストを心配している方は一度検討してみてはいかがでしょうか。  \n\n1. AmazonEC2RoleforSSM は非推奨のため適用しないように注意します。 ↩ \n2. 今回はメンテナンスコストを避けるためSSH over SSMの関連ツール ssh-ssm.sh ssm-tool は使わない方針でいます。 ↩"},"name":"[2021-11-21]踏み台をSSM Session ManagerとAWS SSOで実現する","tags":["SessionManager","AWSSSO"],"childPublishedDate":{"published_on":"2021-11-21T00:00:00.000Z","published_on_unix":1637452800}}},{"node":{"number":68,"relative_category":"blog/organization","fields":{"title":"飲み会に参加するための機材","excerpt":"以前チーム内でリモート懇親会を画策したのですが、食材の調達や経費精算など手間が多すぎて断念しました。ただ、その言い訳は実は本質的ではなく、実際に後ろ向きにさせていたのは「しゃべりながら食べるのがつらい」ということにありました。今回はそれを解決した機材を紹介します。  > PROBLEMPROBLEM \n\n- リモート飲みがつらい 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい 音声が悪すぎて相手にメッセージが伝わらない 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい \n- 有線ヘッドホンだとPCの前に張り付きになりつらい\n- 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい\n- というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい\n- 音声が悪すぎて相手にメッセージが伝わらない\n- 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない\n- 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 最初は楽しいがすぐ飽きる  > SOLUTIONSOLUTION \n\nというわけで、自分がこの1年試行錯誤した末に辿り着いた飲み会参加の機材スタックを共有します。  > オーディオインターフェイスオーディオインターフェイス \n\nオーディオインターフェイスはマイクやギターの音をパソコンに取り込むアナログ・デジタル変換と、取り込んだ音を再生するデジタル・アナログ変換の機能を提供します。 \n\nボイスメモ程度なら必要ないですが、フルリモートで頻繁に会議をしている機会が多いと音質とレイテンシーに多分な影響を与えます。オーディオインターフェイスがない場合、入力時にノイズが乗ったり、出力時に音質が劣化します。また、レイテンシーがひどくなったり音がゆがんだり、下手をするとPCに負荷がかかりフリーズします... \n\n会議を頻繁にする人はとりあえず手に入れたい機材。Steinberg UR22Cが人気です。 \n\n- Steinberg UR22C  > マイクマイク \n\n演説やスピーチ用にダイナミックマイクが使われていますが、オンラインミーティングで使う場合は聞き取りづらいので、何はともあれコンデンサーマイクを使うべきです。 \n\nコンデンサーマイクと言っても、いろいろあります。特にマイクの振動板（ダイアフラム）が大型か小型かで音質の印象が変わるので注意が必要です。私は下記の表のように利用シーンごとに使い分けています。    - 説明 利用シーン     スモールダイアフラム 現実主義。色のない、ニュートラルな音色を提供 ファシリテート   ラージダイアフラム 浪漫主義。音源をより大きく、愛らしいものに変換 発表、音楽活動    \n\nなお、HHKB等の打鍵音が大きいキーボードを利用している方や仕事スペースと家庭スペースとの距離が近い方は、いずれにしてもスモールダイアフラムがお薦めです。スモールダイアフラムはマイクから口元を少しでもずらすと音が入力されずらくなくなるため、期待した音質を提供することが出来ます。 \n\n製品としてはShure Beta87Aが人気です。また、購入する際はマイクスタンドとマイクスポンジもセットで検討すると良いです。マイクの位置を固定し風よけを設置した方が安定した音質に繋がります。 \n\n- Shure Beta87A  > ヘッドホンヘッドホン \n\n食事を取りながら相手の話を聞くには通常のヘッドホンだと食べ物を咀嚼するのに苦労します。口を開けたり閉めたりする際、顎とともにヘッドホンが上下に動くため相手の声が聞き取りづらくなります。 \n\n耳の穴に接しない骨伝導ヘッドホンは、食べ物を咀嚼する際の顎の動きに左右されることがないです。テレワークのヘッドホン多用が外耳炎を引き起こしているという話もあるので、そういう意味で骨伝導ヘッドホンは健康を保つ上でも重要な機材となります。 \n\nまた、使用していて分かったのですが、普段の食事の中でも使うことが出来るので、隙間時間に気軽にメディアに接しやすくなります。例えば、家族と一緒の部屋にいる中、食事を取りながらAWSのWebinarを聞くことができます。 \n\n製品としては業界を牽引しているAfterShokzのAeropexが人気です。今回はオーディオインターフェイスを利用しているので、音質をさらに高めるためにトランスリミッターと組み合わせましょう。 \n\n- AfterShokz Aeropex\n- トランスリミッター TaoTronics aptX-LL  > ビデオビデオ \n\nソーシャルメディアでよく登場するビデオ画像は、表情アップの図（ず）が前面に押し出された絵が一般的ですが、地（じ）の表現が薄く解釈余地がないものが多いです。表情が豊かな方は良いのですが、全員がそういうわけではないので地（じ）の生活の部分に焦点を当てた方が実態に合っています。 \n\n例えば、対面での会話の中では身につけている服装や持ち物等のアトリビュートに焦点が当たりますよね。「その身につけているアクセサリーは何?」「机の上に置いてあるその本、面白そうだね」という会話を思い出してください。 \n\nそういう意味で広角レンズを搭載したアクションカムは望ましい選択です。今時のアクションカムは高解像で鮮やかに表現してくれますし、外にいなくても部屋の中で十分面白い絵になります。 \n\nアクションカムは何でも良いのですが、私は普段「撮れラン」で使っているSony HDR-AS3000をミーティングの際に使っています。 \n\n- Sony HDR-AS3000  > WRAPUPWRAPUP \n\n今回紹介した機材に出会うまで紆余曲折ありましたが、揃えてみて満足しています。 \n\n飲み会でなくても良いですが、機材を揃えた方でいろいろ試してみたい方は一緒に雑談してみませんか。60分雑談会というのを開催しているので、いつでもお気軽にお声がけください。"},"name":"[2021-01-30]飲み会に参加するための機材","tags":["drinkup","team-building"],"childPublishedDate":{"published_on":"2021-01-30T00:00:00.000Z","published_on_unix":1611964800}}}]}},"pageContext":{"number":52}},"staticQueryHashes":[]}