{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/63","result":{"data":{"esaPost":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"> PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったのでつかってみた。題材は以前つくったEmacsライブラリ「esa.el」の移植だ。 \n\nhttps://github.com/nabinno/esa.red   > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうだったけど、慣れ親しんでるEmacsに「Skrylar/red.el」を適用した。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドした。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認した。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（nabinno/red-elixir）。 \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によくつかわれる。HTML/JavaScripでいうところDOM更新にあたるものといえばわかるだろう。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略した。こんな感じ。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよくつかう。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入した。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼなかった。あってもこのくらい。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリをつかっている。ライブラリパッケージはインストールはgit submodulesでいいが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意した（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了する。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義する。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能はつかえないが、コマンドラインREPLで挙動確認している際は do/args %require をつかう。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nRedは既存のフレームワークと比べるとまだまだ機能不足感がぬぐえないが、それを補えるだけの表現力をもっていた。","thumbnail":"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png"},"wip":false,"body_md":"<img alt=thumbnail src=https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png />\r\n\r\n# PROBLEM\r\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり\r\n    - 重たいフレームワークが多い\r\n    - 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい\r\n\r\n# SOLUTION\r\nというわけで、年明け見つけたRedがシンプルだったのでつかってみた。題材は以前つくったEmacsライブラリ「[esa.el](https://github.com/nabinno/esa.el)」の移植だ。\r\n\r\n[https://github.com/nabinno/esa.red](https://github.com/nabinno/esa.red)\r\n\r\n## やったこと\r\n### エディター\r\n構文がすなおなので特にエディタは関係なさそうだったけど、慣れ親しんでるEmacsに「[Skrylar/red.el](https://github.com/Skrylar/red.el)」を適用した。その際、 `red-font-lock-keywords` と `red-indent-line` に足りない箇所があったので[オーバーライドした](https://github.com/nabinno/dotfiles/blob/master/.emacs.d/lisp/init-red.el)。\r\n\r\n### 糖衣構文の適用\r\nRedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認した。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（[nabinno/red-elixir](https://github.com/nabinno/red-elixir)）。\r\n\r\n**1. compose**\r\n\r\nブロック内の変数を評価しブロックとして返す関数 `compose` は、VIDのフェイス更新によくつかわれる。HTML/JavaScripでいうところDOM更新にあたるものといえばわかるだろう。頻繁に「 `compose [foo (bar)]` 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に `compose` 関数を省略した。こんな感じ。\r\n\r\n```\r\n;-- before\r\ncompose [foo (bar)]\r\n\r\n;-- after\r\n~c[foo (bar)]\r\n```\r\n\r\n**2. 関数の入れ子**\r\n\r\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよくつかう。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入した。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼなかった。あってもこのくらい。\r\n\r\n```red\r\n;-- before\r\nrejoin collect [\r\n    foreach d data [\r\n        keep rejoin [d \"  \"]\r\n    ]\r\n]\r\n\r\n;-- after\r\ndata .[\r\n    |> Series/map 'd [rejoin [d \"  \"]]\r\n    |> rejoin\r\n]\r\n```\r\n\r\n### タスクランナーの用意\r\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリをつかっている。ライブラリパッケージはインストールはgit submodulesでいいが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意した（[nabinno/hot](https://github.com/nabinno/hot)、[nabinno/mods](https://github.com/nabinno/mods)）。\r\n\r\n**タスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ**\r\n\r\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了する。\r\n\r\n```sh\r\n> mkdir -p ~/.local/bin\r\n> wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot\r\n> chmod 744 ~/.local/bin/hot\r\n```\r\n\r\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義する。\r\n\r\n```sh\r\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red\r\n> cat hots.red\r\nRed []\r\n\r\nhots: context [\r\n    mods: [\r\n        red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir)\r\n        json #(init: %json.red git: https://github.com/rebolek/red-tools)\r\n        http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools)\r\n    ]\r\n]\r\n> hot mods/get\r\n```\r\n\r\nビルド時は `#include` をつかうのでパッケージ呼び出し機能はつかえないが、コマンドラインREPLで挙動確認している際は `do/args %require` をつかう。\r\n\r\n```sh\r\n> red\r\n>> do/args %require [red-elixir]\r\n>> 1 .. 10 .[\r\n    |> Series/map 'i [i * 2]\r\n    |> Series/map 'i [i + 1]\r\n]\r\n== [3 5 7 9 11 13 15 17 19 21]\r\n```\r\n\r\n# WRAPUP\r\nRedは既存のフレームワークと比べるとまだまだ機能不足感がぬぐえないが、それを補えるだけの表現力をもっていた。\r\n\r\n","body_html":"<a href=\"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"thumbnail\" src=\"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png\"></a>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-7:0\">\n<li data-sourcepos=\"4:1-7:0\">クロスプラットフォーム用のクライアントソフトをつくるにあたり\n<ul data-sourcepos=\"5:5-7:0\">\n<li data-sourcepos=\"5:5-5:45\">重たいフレームワークが多い</li>\n<li data-sourcepos=\"6:5-7:0\">汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"8:1-8:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"9:1-9:207\">というわけで、年明け見つけたRedがシンプルだったのでつかってみた。題材は以前つくったEmacsライブラリ「<a href=\"https://github.com/nabinno/esa.el\" target=\"_blank\" rel=\"noopener noreferrer\">esa.el</a>」の移植だ。</p>\n<p data-sourcepos=\"11:1-11:72\"><a href=\"https://github.com/nabinno/esa.red\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/nabinno/esa.red</a></p>\n<h2 data-sourcepos=\"13:1-13:18\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"やったこと\" name=\"%E3%82%84%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8\" href=\"#%E3%82%84%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"やったこと\"> &gt; やったこと</span></a>やったこと</h2>\n<h3 data-sourcepos=\"14:1-14:19\" id=\"2-1-1\" name=\"2-1-1\">\n<a class=\"anchor\" id=\"エディター\" name=\"%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%83%BC\" href=\"#%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%83%BC\" data-position=\"2-1-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"エディター\"> &gt; エディター</span></a>エディター</h3>\n<p data-sourcepos=\"15:1-15:394\">構文がすなおなので特にエディタは関係なさそうだったけど、慣れ親しんでるEmacsに「<a href=\"https://github.com/Skrylar/red.el\" target=\"_blank\" rel=\"noopener noreferrer\">Skrylar/red.el</a>」を適用した。その際、 <code>red-font-lock-keywords</code> と <code>red-indent-line</code> に足りない箇所があったので<a href=\"https://github.com/nabinno/dotfiles/blob/master/.emacs.d/lisp/init-red.el\" target=\"_blank\" rel=\"noopener noreferrer\">オーバーライドした</a>。</p>\n<h3 data-sourcepos=\"17:1-17:25\" id=\"2-1-2\" name=\"2-1-2\">\n<a class=\"anchor\" id=\"糖衣構文の適用\" name=\"%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87%E3%81%AE%E9%81%A9%E7%94%A8\" href=\"#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87%E3%81%AE%E9%81%A9%E7%94%A8\" data-position=\"2-1-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"糖衣構文の適用\"> &gt; 糖衣構文の適用</span></a>糖衣構文の適用</h3>\n<p data-sourcepos=\"18:1-18:305\">RedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認した。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（<a href=\"https://github.com/nabinno/red-elixir\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/red-elixir</a>）。</p>\n<p data-sourcepos=\"20:1-20:14\"><strong>1. compose</strong></p>\n<p data-sourcepos=\"22:1-22:449\">ブロック内の変数を評価しブロックとして返す関数 <code>compose</code> は、VIDのフェイス更新によくつかわれる。HTML/JavaScripでいうところDOM更新にあたるものといえばわかるだろう。頻繁に「 <code>compose [foo (bar)]</code> 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に <code>compose</code> 関数を省略した。こんな感じ。</p>\n<div class=\"code-block\" data-sourcepos=\"24:1-30:3\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>;-- before\ncompose [foo (bar)]\n\n;-- after\n~c[foo (bar)]\n</code></pre></div></div>\n<p data-sourcepos=\"32:1-32:25\"><strong>2. 関数の入れ子</strong></p>\n<p data-sourcepos=\"34:1-34:417\">素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよくつかう。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入した。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼなかった。あってもこのくらい。</p>\n<div class=\"code-block\" data-sourcepos=\"36:1-49:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>red</div>\n<div class=\"highlight\"><pre class=\"highlight red\"><code>;-- before\nrejoin collect [\n    foreach d data [\n        keep rejoin [d \"  \"]\n    ]\n]\n\n;-- after\ndata .[\n    |&gt; Series/map 'd [rejoin [d \"  \"]]\n    |&gt; rejoin\n]\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"51:1-51:34\" id=\"2-1-3\" name=\"2-1-3\">\n<a class=\"anchor\" id=\"タスクランナーの用意\" name=\"%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%AE%E7%94%A8%E6%84%8F\" href=\"#%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%AE%E7%94%A8%E6%84%8F\" data-position=\"2-1-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"タスクランナーの用意\"> &gt; タスクランナーの用意</span></a>タスクランナーの用意</h3>\n<p data-sourcepos=\"52:1-52:466\">今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリをつかっている。ライブラリパッケージはインストールはgit submodulesでいいが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意した（<a href=\"https://github.com/nabinno/hot\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/hot</a>、<a href=\"https://github.com/nabinno/mods\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/mods</a>）。</p>\n<p data-sourcepos=\"54:1-54:118\"><strong>タスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ</strong></p>\n<p data-sourcepos=\"56:1-56:112\">RedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了する。</p>\n<div class=\"code-block\" data-sourcepos=\"58:1-62:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> <span class=\"nb\">mkdir</span> <span class=\"nt\">-p</span> ~/.local/bin\n<span class=\"o\">&gt;</span> wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux <span class=\"nt\">-O</span> ~/.local/bin/hot\n<span class=\"o\">&gt;</span> <span class=\"nb\">chmod </span>744 ~/.local/bin/hot\n</code></pre></div>\n</div>\n<p data-sourcepos=\"64:1-64:108\">パッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義する。</p>\n<div class=\"code-block\" data-sourcepos=\"66:1-79:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red\n<span class=\"o\">&gt;</span> <span class=\"nb\">cat </span>hots.red\nRed <span class=\"o\">[]</span>\n\nhots: context <span class=\"o\">[</span>\n    mods: <span class=\"o\">[</span>\n        red-elixir <span class=\"c\">#(init: %init.red git: https://github.com/nabinno/red-elixir)</span>\n        json <span class=\"c\">#(init: %json.red git: https://github.com/rebolek/red-tools)</span>\n        http-tools <span class=\"c\">#(init: %http-tools.red git: https://github.com/rebolek/red-tools)</span>\n    <span class=\"o\">]</span>\n<span class=\"o\">]</span>\n<span class=\"o\">&gt;</span> hot mods/get\n</code></pre></div>\n</div>\n<p data-sourcepos=\"81:1-81:195\">ビルド時は <code>#include</code> をつかうのでパッケージ呼び出し機能はつかえないが、コマンドラインREPLで挙動確認している際は <code>do/args %require</code> をつかう。</p>\n<div class=\"code-block\" data-sourcepos=\"83:1-91:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> red\n<span class=\"o\">&gt;&gt;</span> <span class=\"k\">do</span>/args %require <span class=\"o\">[</span>red-elixir]\n<span class=\"o\">&gt;&gt;</span> 1 .. 10 .[\n    |&gt; Series/map <span class=\"s1\">'i [i * 2]\n    |&gt; Series/map '</span>i <span class=\"o\">[</span>i + 1]\n<span class=\"o\">]</span>\n<span class=\"o\">==</span> <span class=\"o\">[</span>3 5 7 9 11 13 15 17 19 21]\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"93:1-93:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"94:1-94:159\">Redは既存のフレームワークと比べるとまだまだ機能不足感がぬぐえないが、それを補えるだけの表現力をもっていた。</p>\n","tags":["red","esa"],"updated_at":"2021-01-11T13:01:29+09:00","childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":64,"relative_category":"blog/backend","fields":{"title":"WSL2時代のDocker開発スタイル","excerpt":"> PROBLEMPROBLEM \n\n- あたらしくでたWSL2によって以前書いた記事からだいぶ状況が変わった 主な変更点 WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- 主な変更点 WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) \n- WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss)\n- WSL2 軽量Hyper-V上のLinux (Linux Kernel)\n- /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- Win32側の9Pクライアント 9prdr.sys \n- WSL側の9Pクライアント /init    > SOLUTIONSOLUTION \n\nというわけで、前記事で掲げていた目標「WSLでDockerをつかったWebアプリケーション開発ができるかどうか」について再確認します。   > 対象環境対象環境 \n\n- Windows 10 Pro Version 1903 OS Build 18922.1000 Windows Terminal (Preview) Version 0.2.1715.0 WSL2 Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard) Docker version 19.03.0-rc3, build 27fcb77 WSL1 Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft) \n- Windows Terminal (Preview) Version 0.2.1715.0\n- WSL2 Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard) Docker version 19.03.0-rc3, build 27fcb77 \n- Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard)\n- Docker version 19.03.0-rc3, build 27fcb77\n- WSL1 Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft) \n- Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft)   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- WSL2を使ってみる (InsiderPreview) \n\nWSLのパッケージ管理は下記2つを押さえておけば問題ないでしょう。 \n\n1. asdf/anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう 関数言語界隈ではasdfが主流になってきてるようです。 \n2. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n3. 関数言語界隈ではasdfが主流になってきてるようです。\n4. nix Haskellのようにasdf/anyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n5. Haskellのようにasdf/anyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n6. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyはWSL2に対応しておらずConEmuは描画がくずれやすいため、デフォルトのターミナルかWindows Terminalが選択肢となります。 \n\nWindows TerminalとConEmuとの比較    - Windows Terminal ConEmu     透過対象 backgroundImage ConEmu自体   キーバインド制約 Alt+Shiftが効かない 特になし   WSL2の描画 特になし くずれる   管理者権限で実行 初回のみ タスク実行ごと      > DockerのインストールDockerのインストール \n\nWSL1ではDockerデーモンがつかえないのでWSL2でDockerをつかうようにしましょう。Docker CEをインストールします。 \n\nどうしてもWSL1でということであれば、Win32 (WSL1からみるとdrvfs) 側でDocker For Windowsを用意します。インストールはDockerのダウンロードページから手順通りおこないます。\n 構成等は前回の記事を参照ください。   > さて、WSL2からDockerはどの程度つかえるのかさて、WSL2からDockerはどの程度つかえるのか \n\nWSL2は軽量Hyper-V上にLinuxコンテナを動かしているので、基本Hyper-Vと同様にDockerをつかうことができます。 \n\nただし、WSL1と違いlocalhostにWSL2がバインドできません (2019-07-27追記: Build Version 18945で解決しました )。\n また、WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています。 \n\nひとつずつ解決方法を見ていきましょう。   > 1. WSL1と違いlocalhostにWSL2がバインドできません1. WSL1と違いlocalhostにWSL2がバインドできません \n\nWSL2がつかっているVirtual Switchはinternal onlyのため、Win32側からlocalhostをつかってWSL2にアクセスすることができません。現在対応中のようです (2019-07-27追記: Build Version 18945で解決しました )。 \n\n対処方法は2つあります。 \n\na. WSL1をつかう \n\nこれが一番楽ですが、WSL1は次項であげるパフォーマンス上の欠点があるので、Web系フロントエンド開発におけるライブリローディング機能をつかうケースに限定するといいでしょう。 \n\nb. Hostsファイルをつかう \n\nWin32のHostsファイルでWSL2のeth0インターフェイスのIPアドレスに適当なホスト名を割り当てます（ポートごとにホストを振り分けたい場合はWSL2側にProxyを用意するといいでしょう）。   shell \n\n# C:\\Windows\\System32\\drivers\\etc\\hosts 172.17.72.217 dashboard.local.me   \n\nWSL2のIPアドレスはコンテナを立ち上げるごとに変わるので、下記のようなコマンドレットをWin32側のPowerShell $PROFILEに用意しておくといいでしょう。WSL2だけで完結したい方はシェル上から powershell.exe -Command 'Sync-HostsToWslIp' と打つだけです。   powershell \n\n# $PROFILE function Sync-HostsToWslIp { $hosts = \"$env:SystemRoot\\System32\\drivers\\etc\\hosts\"; $pattern = \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"; $wslip = bash.exe -c \"ifconfig eth0 | grep 'inet '\"; if ($wslip -match $pattern) { $wslip = $matches[0]; } else { echo \"The Script Exited, the ip address of WSL 2 cannot be found\"; exit; } cat $hosts | %{ $_ -match $pattern } $rc = cat $hosts | %{ $_ -replace $matches[0], $wslip } $rc | Out-File $hosts; }     > 2. WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています2. WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています \n\nいろんな方がベンチマークを公開してるのでそれを参考にするといいでしょう。 \n\nCf. \n\n- Pythonでファイル操作のベンチマーク\n- dd、git cloneのベンチマーク \n\nわたしは git status -sb をよくつかうので、そのコマンドで簡単なベンチマークとりました。   shell \n\n# WSLx $ cd ~/nabinno.github.io $ \\time -f %e git status -sb # Win32/WSLx $ cd ~/nabinno.github.io $ \\time -f %e powershell.exe -Command 'git status -sb' # Win32 PS> cd ~/nabinno.github.io PS> (Measure-Command { git status -sb }).TotalMilliseconds / 1000 | %{ [math]::Round($_, 2) }      Subject WSL Win32     WSL1 0.47 0.09   WSL2 0.00 0.61   Win32/WSL1 2.66 1.91   Win32/WSL2 2.81 1.79   Win32 0.51 0.12      > Docker以外でWSLの課題はないのかDocker以外でWSLの課題はないのか   > デバイスへのアクセスデバイスへのアクセス \n\n以前から要望があったものだと「デバイスアクセスができない」件があります。 \n\n9P導入前だとこれはElixirのIoTフレームワークNervesのように、WSL UtilitiesでWSLパスをWin32パスに変換してからWin32にあるデバイス関連ツールをつかうのが簡単な解決策でした。   sh \n\n$ fwup.exe -a -i $(wslpath -w -a _build/rpi0_dev/nerves/images/hello_nerves.fw) -t complete -d $(fwup.exe -D | sed 's/,.*//')   \n\nただし9Pを導入したWindows 10 Version 1903以降は、WSL1もWSL2もともにWSLパスを変換せずにWin32にあるデバイス関連ツールをつかうことができます。   sh \n\n$ fwup.exe -a -i _build/rpi0_dev/nerves/images/hello_nerves.fw -t complete -d $(fwup.exe -D | sed 's/,.*//')     > WRAPUPWRAPUP \n\nわたしの観測範囲では課題はほぼ問題ない状態になっていました。 \n\nおすすめ開発環境は下記のとおり    item content     IDE WSLx上のエディタ   Webフロントエンド開発 WSL1   Docker関連開発 WSL2   dotfiles WSLx、Win32を共有管理    \n\nWin32側のIDEをつかっているユーザーはパフォーマンス上の不満がまだあるかもしれませんが、WSLでDockerをつかったWebアプリケーション開発は十分できる、と言えそうです。つまり、Linux・macOS・WindowsによるWebアプリケーション開発は十分共有できる、と。 \n\nいい時代になりました。"},"name":"[2019-07-06]WSL2時代のDocker開発スタイル","tags":["wsl","wsl2","ubuntu"],"childPublishedDate":{"published_on":"2019-07-06T00:00:00.000Z","published_on_unix":1562371200}}},{"node":{"number":61,"relative_category":"blog/health","fields":{"title":"ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","excerpt":"> PROBLEMPROBLEM \n\n- 以前からオフィスに行くと目や喉が痛くなることがあったので、自分の体調なのか環境なのか原因を切り分けるために汚染計測器「Dienmern DM106A」を購入 ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる \n- ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる   > SOLUTIONSOLUTION \n\nというわけで、DM106AのセンサーデータをRaspberry Piで定期取得することにした。設置方法の詳細はGitHubレポジトリを参照。下記は実装概要。   > 電子部品の構成電子部品の構成    item description     Raspberry Pi 3 Model B+    Aosong DHT11 気温・湿度センサー、GPIO   Nova SDS021 PM2.5・PM10センサー、UART   ams CCS811 TVOC・CO2eセンサー、I2C    \n\n電子工作は素人ゆえどのセンサーを買えばいいかわからなかったのでDM106Aを分解して各センサーの型番をしらべた。DHT011、SDS021はDM106Aとおなじセンサー、HCHOセンサーは信頼性があり手ごろなのがうまく見つけられなかった。TVOCセンサーはAdafruitが推しているCCS811を採用した。   > コードの構成コードの構成    item description     AirElixir.Application アプリケーション管理   AirElixir.GoogleSpreadsheets センサーデータ記録   AirElixirSensor.Publisher センサーデータ発行・送信   AirElixirSensor.Subscriber センサーデータ購読・受信    \n\n基本構成はGrovePiを参考にした。発行処理はElixirでうまくいかないケースがあったのでまずはPython/ErlPortでおこなった。後々Elixirに移行できるようにマクロにしてある。   > 5日ほど稼働してわかったこと・見立て、今後の課題5日ほど稼働してわかったこと・見立て、今後の課題  \n\n- オフィスの空気清浄機「Hitachi EP-LVG110」はPMをきちんとフィルターしていた ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている \n- ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている\n- 人の入りが多い時間帯に空気（TVOCやCO2e）がよごれる 人が「出る」ときよりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察 \n- 人が「出る」ときよりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察\n- TVOCやCO2eはPMのうごきに連動している（かも） チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n- チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n- TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ\n- TVOCの変動が大きすぎる ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均 \n- ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均\n- TVOCのスパイクを抑えたい TODO: ファイトレメディエーションによる効果を見ていきたいところ \n- TODO: ファイトレメディエーションによる効果を見ていきたいところ   > WRAPUPWRAPUP \n\nElixirは健康管理に向いている。   txt \n\n「なんか体調がすぐれないなあ...」 「Elixirちょうだい!」   \n\nという感じ。"},"name":"[2018-12-22]ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","tags":["elixir","raspberry-pi","particulates","physiology"],"childPublishedDate":{"published_on":"2018-12-22T00:00:00.000Z","published_on_unix":1545436800}}},{"node":{"number":58,"relative_category":"blog/backend","fields":{"title":"WSL（Windows Subsystem for Linux）でDockerをつかったWebアプリケーション開発をおこなう際の注意点","excerpt":"これは無宗教ななびの  が書くDocker Advent Calendar 2017用記事です。前日はinductorさんの「Docker Meetupの中身まとめ」でした  （写真はクリスマスを日本にひろめた明治屋 ）   > PROBLEMPROBLEM \n\n- macOSとWindowsでWebアプリケーション開発をする際に 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- ただ、実際どこまで開発ができるかわからんしなあ   > SOLUTIONSOLUTION \n\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。 \n\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。 \n\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。   > 対象環境対象環境 \n\n- Windows 10 Pro 1709 16299.64 Hyper-V 10.0.16299.15 Docker for Windows 17.09.0-ce-win33 Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Hyper-V 10.0.16299.15\n- Docker for Windows 17.09.0-ce-win33\n- Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Docker Client 1.12.6   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- Windows Subsystem for Linuxをインストールしてみよう！ \n\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。 \n\n1. apt WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します \n2. WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\n3. anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます \n4. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n5. exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\n6. nix ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n7. ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n8. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。 \n\n- WSLtty Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 \n- ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\n- EmacsでCtrl-SPC set-mark が機能する\n- 画面サイズの変更が柔軟\n- Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- PowerShellなどほかのコンソールの呼び出しが面倒\n- ConEmu Pros PowerShellなどほかのコンソールの呼び出しが楽 Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- Pros PowerShellなどほかのコンソールの呼び出しが楽 \n- PowerShellなどほかのコンソールの呼び出しが楽\n- Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- ファイルの読込速度がおそい\n- EmacsでCtrl-SPC set-mark が機能しない\n- 画面サイズの変更に制限がある   > WSLttyWSLtty \n\n- mintty/wsltty \n\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは chsh がつかえないのでログイン時につかいたいシェルを指定します。もし、 screen をつかいたい場合は /run/screen ディレクトリを作成してからコマンド指定します。   bat \n\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'   ConEmu \n\n- ConEmu - Handy Windows Terminal \n\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい1のでおすすめしません。 \n\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。   bash \n\n# task parameters /icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\" # task command bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%     > Docker for WindowsのインストールDocker for Windowsのインストール \n\n- Docker For Windows \n\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。 \n\n構成は下記のようになります。  \n\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 DOCKER_HOST をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。 \n\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\n2. WSL上のDockerクライアントに DOCKER_HOST=tcp://0.0.0.0:2375 を設定 \n\nWSLには下記のようなaliasを用意しておくといいでしょう。   bash \n\nexport DOCKER_HOST=tcp://0.0.0.0:2375 alias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\" alias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"     > さて、WSLからDocker for Windowsはどの程度つかえるのかさて、WSLからDocker for Windowsはどの程度つかえるのか \n\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。 \n\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\n2. WSLはLinux形式のパスしか扱えません、C:\\Dev のようなドライブ名にコロンをつけたURIスキーマは扱えません\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません2 \n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります3  \n\nひとつずつ解決方法を見ていきましょう。   > 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません \n\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。   > 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません \n\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。   bash \n\n$ ln -s /mnt/c /C # 開発ディレクトリはこんな感じで参照できます $ ls -al /C/Dev total 0 drwxrwxrwx 0 root root 512 Oct 27 00:54 . drwxrwxrwx 0 root root 512 Dec 8 07:49 .. drwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1 drwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2     > 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません \n\n各OS間での違いを吸収するため、プロジェクトに PRJ_ROOT のような環境変数を用意しましょう。   yaml \n\nservices: app-front: image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front volumes: - ${PRJ_ROOT}/front:/var/www/front     > 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります \n\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました  \n\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。   bash \n\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules $ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules     > WRAPUPWRAPUP \n\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。 \n\n随時、気になる課題が出てきたら追記します。  \n\n1. https://github.com/cmderdev/cmder/issues/901 ↩ \n2. https://github.com/docker/compose/issues/4039#issuecomment-269558432 ↩ \n3. https://github.com/Microsoft/WSL/issues/2448 ↩"},"name":"[2017-12-10]WSL（Windows Subsystem for Linux）でDockerをつかったWebアプリケーション開発をおこなう際の注意点","tags":["wsl","docker","ubuntu"],"childPublishedDate":{"published_on":"2017-12-10T00:00:00.000Z","published_on_unix":1512864000}}}]}},"pageContext":{"number":63}},"staticQueryHashes":[]}