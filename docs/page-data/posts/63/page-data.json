{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/63","result":{"data":{"esaPost":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- 今回作ったコード https://github.com/nabinno/esa.red    > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、 docs.red-lang.org とRed by Exampleをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装しました。 \n\n- 実装した糖衣構文 nabinno/red-elixir  \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。","thumbnail":"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png"},"wip":false,"body_md":"<img alt=thumbnail src=https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png />\r\n\r\nRedという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。\r\n\r\n# PROBLEM\r\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり\r\n    - 重たいフレームワークが多い\r\n    - 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい\r\n\r\n# SOLUTION\r\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「[esa.el](https://github.com/nabinno/esa.el)」の移植です。\r\n\r\n- 今回作ったコード [https://github.com/nabinno/esa.red](https://github.com/nabinno/esa.red)\r\n\r\n## やったこと\r\n### エディター\r\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「[Skrylar/red.el](https://github.com/Skrylar/red.el)」を適用しました。その際、 `red-font-lock-keywords` と `red-indent-line` に足りない箇所があったので[オーバーライドしました](https://github.com/nabinno/dotfiles/blob/master/.emacs.d/lisp/init-red.el)。\r\n\r\n### 糖衣構文の適用\r\nRedはコマンドラインREPLがつかえるので、 [docs.red-lang.org](https://github.com/red/docs/blob/master/en/SUMMARY.adoc) と[Red by Example](https://www.red-by-example.org/)をみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装しました。\r\n\r\n- 実装した糖衣構文 [nabinno/red-elixir](https://github.com/nabinno/red-elixir)\r\n\r\n**1. compose**\r\n\r\nブロック内の変数を評価しブロックとして返す関数 `compose` は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 `compose [foo (bar)]` 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に `compose` 関数を省略しました。こんな感じです。\r\n\r\n```\r\n;-- before\r\ncompose [foo (bar)]\r\n\r\n;-- after\r\n~c[foo (bar)]\r\n```\r\n\r\n**2. 関数の入れ子**\r\n\r\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。\r\n\r\n```red\r\n;-- before\r\nrejoin collect [\r\n    foreach d data [\r\n        keep rejoin [d \"  \"]\r\n    ]\r\n]\r\n\r\n;-- after\r\ndata .[\r\n    |> Series/map 'd [rejoin [d \"  \"]]\r\n    |> rejoin\r\n]\r\n```\r\n\r\n### タスクランナーの用意\r\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（[nabinno/hot](https://github.com/nabinno/hot)、[nabinno/mods](https://github.com/nabinno/mods)）。\r\n\r\n**タスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ**\r\n\r\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。\r\n\r\n```sh\r\n> mkdir -p ~/.local/bin\r\n> wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot\r\n> chmod 744 ~/.local/bin/hot\r\n```\r\n\r\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。\r\n\r\n```sh\r\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red\r\n> cat hots.red\r\nRed []\r\n\r\nhots: context [\r\n    mods: [\r\n        red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir)\r\n        json #(init: %json.red git: https://github.com/rebolek/red-tools)\r\n        http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools)\r\n    ]\r\n]\r\n> hot mods/get\r\n```\r\n\r\nビルド時は `#include` をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は `do/args %require` を使います。\r\n\r\n```sh\r\n> red\r\n>> do/args %require [red-elixir]\r\n>> 1 .. 10 .[\r\n    |> Series/map 'i [i * 2]\r\n    |> Series/map 'i [i + 1]\r\n]\r\n== [3 5 7 9 11 13 15 17 19 21]\r\n```\r\n\r\n# WRAPUP\r\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。\r\n","body_html":"<a href=\"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"thumbnail\" src=\"https://raw.githubusercontent.com/nabinno/esa.red/master/esa.red.png\"></a>\n<p data-sourcepos=\"3:1-3:368\">Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。</p>\n<h1 data-sourcepos=\"5:1-5:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"6:1-9:0\">\n<li data-sourcepos=\"6:1-9:0\">クロスプラットフォーム用のクライアントソフトをつくるにあたり\n<ul data-sourcepos=\"7:5-9:0\">\n<li data-sourcepos=\"7:5-7:45\">重たいフレームワークが多い</li>\n<li data-sourcepos=\"8:5-9:0\">汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"10:1-10:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"11:1-11:213\">というわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「<a href=\"https://github.com/nabinno/esa.el\" target=\"_blank\" rel=\"noopener noreferrer\">esa.el</a>」の移植です。</p>\n<ul data-sourcepos=\"13:1-14:0\">\n<li data-sourcepos=\"13:1-14:0\">今回作ったコード <a href=\"https://github.com/nabinno/esa.red\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/nabinno/esa.red</a>\n</li>\n</ul>\n<h2 data-sourcepos=\"15:1-15:18\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"やったこと\" name=\"%E3%82%84%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8\" href=\"#%E3%82%84%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"やったこと\"> &gt; やったこと</span></a>やったこと</h2>\n<h3 data-sourcepos=\"16:1-16:19\" id=\"2-1-1\" name=\"2-1-1\">\n<a class=\"anchor\" id=\"エディター\" name=\"%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%83%BC\" href=\"#%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%83%BC\" data-position=\"2-1-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"エディター\"> &gt; エディター</span></a>エディター</h3>\n<p data-sourcepos=\"17:1-17:403\">構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「<a href=\"https://github.com/Skrylar/red.el\" target=\"_blank\" rel=\"noopener noreferrer\">Skrylar/red.el</a>」を適用しました。その際、 <code>red-font-lock-keywords</code> と <code>red-indent-line</code> に足りない箇所があったので<a href=\"https://github.com/nabinno/dotfiles/blob/master/.emacs.d/lisp/init-red.el\" target=\"_blank\" rel=\"noopener noreferrer\">オーバーライドしました</a>。</p>\n<h3 data-sourcepos=\"19:1-19:25\" id=\"2-1-2\" name=\"2-1-2\">\n<a class=\"anchor\" id=\"糖衣構文の適用\" name=\"%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87%E3%81%AE%E9%81%A9%E7%94%A8\" href=\"#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87%E3%81%AE%E9%81%A9%E7%94%A8\" data-position=\"2-1-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"糖衣構文の適用\"> &gt; 糖衣構文の適用</span></a>糖衣構文の適用</h3>\n<p data-sourcepos=\"20:1-20:351\">RedはコマンドラインREPLがつかえるので、 <a href=\"https://github.com/red/docs/blob/master/en/SUMMARY.adoc\" target=\"_blank\" rel=\"noopener noreferrer\">docs.red-lang.org</a> と<a href=\"https://www.red-by-example.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Red by Example</a>をみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装しました。</p>\n<ul data-sourcepos=\"22:1-23:0\">\n<li data-sourcepos=\"22:1-23:0\">実装した糖衣構文 <a href=\"https://github.com/nabinno/red-elixir\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/red-elixir</a>\n</li>\n</ul>\n<p data-sourcepos=\"24:1-24:14\"><strong>1. compose</strong></p>\n<p data-sourcepos=\"26:1-26:467\">ブロック内の変数を評価しブロックとして返す関数 <code>compose</code> は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 <code>compose [foo (bar)]</code> 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に <code>compose</code> 関数を省略しました。こんな感じです。</p>\n<div class=\"code-block\" data-sourcepos=\"28:1-34:3\"><div class=\"highlight\"><pre class=\"highlight plaintext\"><code>;-- before\ncompose [foo (bar)]\n\n;-- after\n~c[foo (bar)]\n</code></pre></div></div>\n<p data-sourcepos=\"36:1-36:25\"><strong>2. 関数の入れ子</strong></p>\n<p data-sourcepos=\"38:1-38:444\">素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。</p>\n<div class=\"code-block\" data-sourcepos=\"40:1-53:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>red</div>\n<div class=\"highlight\"><pre class=\"highlight red\"><code>;-- before\nrejoin collect [\n    foreach d data [\n        keep rejoin [d \"  \"]\n    ]\n]\n\n;-- after\ndata .[\n    |&gt; Series/map 'd [rejoin [d \"  \"]]\n    |&gt; rejoin\n]\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"55:1-55:34\" id=\"2-1-3\" name=\"2-1-3\">\n<a class=\"anchor\" id=\"タスクランナーの用意\" name=\"%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%AE%E7%94%A8%E6%84%8F\" href=\"#%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%AE%E7%94%A8%E6%84%8F\" data-position=\"2-1-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"タスクランナーの用意\"> &gt; タスクランナーの用意</span></a>タスクランナーの用意</h3>\n<p data-sourcepos=\"56:1-56:478\">今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（<a href=\"https://github.com/nabinno/hot\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/hot</a>、<a href=\"https://github.com/nabinno/mods\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/mods</a>）。</p>\n<p data-sourcepos=\"58:1-58:118\"><strong>タスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ</strong></p>\n<p data-sourcepos=\"60:1-60:115\">RedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。</p>\n<div class=\"code-block\" data-sourcepos=\"62:1-66:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> <span class=\"nb\">mkdir</span> <span class=\"nt\">-p</span> ~/.local/bin\n<span class=\"o\">&gt;</span> wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux <span class=\"nt\">-O</span> ~/.local/bin/hot\n<span class=\"o\">&gt;</span> <span class=\"nb\">chmod </span>744 ~/.local/bin/hot\n</code></pre></div>\n</div>\n<p data-sourcepos=\"68:1-68:111\">パッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。</p>\n<div class=\"code-block\" data-sourcepos=\"70:1-83:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red\n<span class=\"o\">&gt;</span> <span class=\"nb\">cat </span>hots.red\nRed <span class=\"o\">[]</span>\n\nhots: context <span class=\"o\">[</span>\n    mods: <span class=\"o\">[</span>\n        red-elixir <span class=\"c\">#(init: %init.red git: https://github.com/nabinno/red-elixir)</span>\n        json <span class=\"c\">#(init: %json.red git: https://github.com/rebolek/red-tools)</span>\n        http-tools <span class=\"c\">#(init: %http-tools.red git: https://github.com/rebolek/red-tools)</span>\n    <span class=\"o\">]</span>\n<span class=\"o\">]</span>\n<span class=\"o\">&gt;</span> hot mods/get\n</code></pre></div>\n</div>\n<p data-sourcepos=\"85:1-85:201\">ビルド時は <code>#include</code> をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は <code>do/args %require</code> を使います。</p>\n<div class=\"code-block\" data-sourcepos=\"87:1-95:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"o\">&gt;</span> red\n<span class=\"o\">&gt;&gt;</span> <span class=\"k\">do</span>/args %require <span class=\"o\">[</span>red-elixir]\n<span class=\"o\">&gt;&gt;</span> 1 .. 10 .[\n    |&gt; Series/map <span class=\"s1\">'i [i * 2]\n    |&gt; Series/map '</span>i <span class=\"o\">[</span>i + 1]\n<span class=\"o\">]</span>\n<span class=\"o\">==</span> <span class=\"o\">[</span>3 5 7 9 11 13 15 17 19 21]\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"97:1-97:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"98:1-98:292\">クライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。</p>\n","tags":["red","esa"],"updated_at":"2021-01-16T14:08:12+09:00","childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":55,"relative_category":"blog/backend","fields":{"title":"PositiveSSLをHerokuに適用する","excerpt":"年に1回のSSL更新のイベントです。毎年同じことをすれば良いかというとそうでもなく、販社と卸の都合でSSLの購入方法が微妙に変わります。とは言え、毎年一から調べ直すのも手間なので備忘として記しておきます。   > PROBLEMPROBLEM \n\n- HerokuのSSLの期限がきた   > SOLUTIONSOLUTION \n\n- というわけで、いつも使っているSSL販売代理店SSLs.com（NameCheap社）でPositiveSSL（運用Comodo社）を購入しHerokuに適用します。   > HOWTOHOWTO \n\n1. 証明書を購入する SSL販売代理店であればどこでもいいのですが、昔から使っているので \n2. SSL販売代理店であればどこでもいいのですが、昔から使っているので\n3. 秘密鍵と署名リクエストをつくる 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key 署名リクエスト openssl req -new -key server.key -out server.csr \n4. 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 \n5. 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key \n6. 署名リクエスト openssl req -new -key server.key -out server.csr \n7. 証明書発行を申請する SSL販売代理店より署名リクエストserver.csrと関連情報を送信します \n8. SSL販売代理店より署名リクエストserver.csrと関連情報を送信します\n9. ドメイン保持の証明をする PositiveSSLの運用会社Comodoに対しドメイン保持の証明します 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります \n10. PositiveSSLの運用会社Comodoに対しドメイン保持の証明します\n11. 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります\n12. Heroku用の証明書をつくる 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n13. 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます\n14. Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n15. Herokuに証明書を適用する 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n16. 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key \n17. heroku addons:add ssl:endpoint\n18. heroku certs:add server.crt server.key\n19. 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n20. heroku certs:update server.crt server.key   > WRAPUPWRAPUP \n\nこのあたりが自動化されれば良いと思いつつ、自動化されたらこのあたりを調べるモチベーションがなくなるので年に一回のリハビリイベントとして位置づけておきます、はい。"},"name":"[2017-04-23]PositiveSSLをHerokuに適用する","tags":[],"childPublishedDate":{"published_on":"2017-04-23T00:00:00.000Z","published_on_unix":1492905600}}},{"node":{"number":54,"relative_category":"blog/frontend","fields":{"title":"Xamarin開発環境をととのえる","excerpt":"Xamarinに手を出し始めたのは良いのですが、その開発環境がどうにも手になじまず試行錯誤しています。今回の記事で解決できるかというと微妙ではありますが、やれるだけのことはやってみようと思います。   > PROBLEMPROBLEM \n\n- Xamarin開発環境がサーバー側のそれとかい離している Visual Studio Community 2015の動作がもっさりしている 適切な開発フローがわからない 適切なアプリケーションフレームワークがわからない 適切なXAMLプレビュワーがわからない 適切なAndroidエミュレーターがわからない \n- Visual Studio Community 2015の動作がもっさりしている\n- 適切な開発フローがわからない\n- 適切なアプリケーションフレームワークがわからない\n- 適切なXAMLプレビュワーがわからない\n- 適切なAndroidエミュレーターがわからない   > SOLUTIONSOLUTION \n\nというわけで、動作が快適になったといわれるVisual Studio 2017がでたのでそちらを中心に開発環境を暫定で整理します、永遠のWIPです。   > 開発フロー開発フロー \n\nまず、想定している開発フローは下記の通り。 \n\n- テスト駆動開発 デバッグ エミュレーター画面の動作確認 - ビルドスピード等考慮してUWPでおこなう アウトプット - Debug.WriteLineなどの確認 イミディエイト - 変数の追跡 C# REPL - C#やパッケージの動作確認 XAMLのプレビュー - いらない子 テスト 単体テスト - NUnit UIテスト - 保留 \n- デバッグ エミュレーター画面の動作確認 - ビルドスピード等考慮してUWPでおこなう アウトプット - Debug.WriteLineなどの確認 イミディエイト - 変数の追跡 C# REPL - C#やパッケージの動作確認 XAMLのプレビュー - いらない子 \n- エミュレーター画面の動作確認 - ビルドスピード等考慮してUWPでおこなう\n- アウトプット - Debug.WriteLineなどの確認\n- イミディエイト - 変数の追跡\n- C# REPL - C#やパッケージの動作確認\n- XAMLのプレビュー - いらない子\n- テスト 単体テスト - NUnit UIテスト - 保留 \n- 単体テスト - NUnit\n- UIテスト - 保留\n- Github Flowにそったデプロイ featureブランチをきってプルリクエストをたてる 当該ブランチに対してCIツールでビルド・テスト・配布を自動化 - ビルド・テスト後にレビュアーにメールにて配布しスマホで確認してもらう流れ。 CIツール Visual Studio Mobile Center - HockeyApp（クラッシュレポート）とXamarin Test Cloud（UIテスト）を統合したCIサービス。Xamarin.Formsは2017年3月18日現在iOS対応、Android非対応という状況。UWPは知らない。 Wercker - masterマージ後にいらなくなったfeatureブランチを消すなどの後片付け役。 Appストアへデプロイ Android iOS UWP \n- featureブランチをきってプルリクエストをたてる\n- 当該ブランチに対してCIツールでビルド・テスト・配布を自動化 - ビルド・テスト後にレビュアーにメールにて配布しスマホで確認してもらう流れ。 CIツール Visual Studio Mobile Center - HockeyApp（クラッシュレポート）とXamarin Test Cloud（UIテスト）を統合したCIサービス。Xamarin.Formsは2017年3月18日現在iOS対応、Android非対応という状況。UWPは知らない。 Wercker - masterマージ後にいらなくなったfeatureブランチを消すなどの後片付け役。 \n- CIツール Visual Studio Mobile Center - HockeyApp（クラッシュレポート）とXamarin Test Cloud（UIテスト）を統合したCIサービス。Xamarin.Formsは2017年3月18日現在iOS対応、Android非対応という状況。UWPは知らない。 Wercker - masterマージ後にいらなくなったfeatureブランチを消すなどの後片付け役。 \n- Visual Studio Mobile Center - HockeyApp（クラッシュレポート）とXamarin Test Cloud（UIテスト）を統合したCIサービス。Xamarin.Formsは2017年3月18日現在iOS対応、Android非対応という状況。UWPは知らない。\n- Wercker - masterマージ後にいらなくなったfeatureブランチを消すなどの後片付け役。\n- Appストアへデプロイ Android iOS UWP \n- Android\n- iOS\n- UWP \n\nちなみにWerckerでのfeatureブランチなどの後片付けはこんな感じです。masterマージのタイミングで走らせます。   yaml \n\nbox: ruby:2.4.0 build: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - script: name: Add git-tag code: | _tag=$(date -u -d '9 hours' +%Y-%m-%d-%H-%M-%S) git remote add origin git@github.com:nabinno/utagaki.git git config --global user.email 'wercker@blahfe.com' git config --global user.name 'Wercker Bot' git tag -a $_tag master -m 'wercker deploy' git push origin $_tag after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > 開発環境開発環境 \n\nその上で開発環境は下記の通りに設定します。Visual Studio 2017版Xamarinは現時点でHypervisorがHyper-Vを考慮していない、Intel HAXMやVirtualBoxなどのホスト型を前提としています。ただ私見としては、VirtualBoxなどのホスト型はWindowsアップデート時に動作検証対象となっておらずクラッシュが起きやすいです。Hyper-Vを開発環境とすることをお薦めします。いずれにせよ、デバッグはビルドスピード等がHypervisorに左右されるAndroidではなくUWPで行うと良いでしょう。 \n\n- IDE Visual Studio Community 2017 Basic extentions Microsoft Visual Studio Community 2017 Version 15.0.26228.9 D15RTWSVC Microsoft .NET Framework Version 4.6.01586 Visual C# 2017 JavaScript Language Service 2.0 JavaScript Project System 2.0 JavaScript UWP Project System 2.0 TypeScript 2.1.5.0 Microsoft Visual Studio VC Package 1.0 Xamarin 4.3.0.784 (73f58d6) Xamarin.Android SDK 7.1.0.41 (9578cdc) Xamarin.iOS and Xamarin.Mac SDK 10.4.0.123 (35d1ccd) Visual Studio Tools for Unity 3.0.0.1 Visual Studio Tools for Universal Windows Apps 15.0.26228.00 Mono Debugging for Visual Studio Mono.Debugging.VisualStudio ASP.NET and Web Tools 2017 15.0.30223.0 NuGet Package Manager 4.0.0 Common Azure Tools 1.9 NpgsqlVSPackage Extension 1.0 Merq 1.1.13-alpha (2f64b6d) VSPackage Extension 1.2 Other extentions JetBrains ReSharper Ultimate 2016.3.2 - なにはともあれ入れておく。 CodeMaid 10.2.7 - 気軽にコード整形してくれる。 .ignore 1.2.71 Markdown Editor 1.11.201 File Nesting 2.6.67 GitHub.VisualStudio 2.2.0.8 VSColorOutput 2.5 HideMenu 1.0 - MinimaliticViewとの組み合わせでEmacsっぽい画面になる。 MinimaliticView Extension 1.0 Debug用エミュレーター XAML Previewer for Xamarin.Forms - Gorilla PlayerはVS2017未対応の上、Data Bindingを参照できないため機能的にXAML Previewer for Xamarin.Formsとほぼかわらない様子。 Android Emulator Manager/Android SDK Manager - VS2017ではHyper-VベースのVisual Studio Emulator for Xamarinがなくなり、Intel HAXMベースのAndroid Emulator Manager/Android SDK Manager (Google)のみとなった。 \n- Visual Studio Community 2017\n- Basic extentions Microsoft Visual Studio Community 2017 Version 15.0.26228.9 D15RTWSVC Microsoft .NET Framework Version 4.6.01586 Visual C# 2017 JavaScript Language Service 2.0 JavaScript Project System 2.0 JavaScript UWP Project System 2.0 TypeScript 2.1.5.0 Microsoft Visual Studio VC Package 1.0 Xamarin 4.3.0.784 (73f58d6) Xamarin.Android SDK 7.1.0.41 (9578cdc) Xamarin.iOS and Xamarin.Mac SDK 10.4.0.123 (35d1ccd) Visual Studio Tools for Unity 3.0.0.1 Visual Studio Tools for Universal Windows Apps 15.0.26228.00 Mono Debugging for Visual Studio Mono.Debugging.VisualStudio ASP.NET and Web Tools 2017 15.0.30223.0 NuGet Package Manager 4.0.0 Common Azure Tools 1.9 NpgsqlVSPackage Extension 1.0 Merq 1.1.13-alpha (2f64b6d) VSPackage Extension 1.2 \n- Microsoft Visual Studio Community 2017 Version 15.0.26228.9 D15RTWSVC\n- Microsoft .NET Framework Version 4.6.01586\n- Visual C# 2017\n- JavaScript Language Service 2.0\n- JavaScript Project System 2.0\n- JavaScript UWP Project System 2.0\n- TypeScript 2.1.5.0\n- Microsoft Visual Studio VC Package 1.0\n- Xamarin 4.3.0.784 (73f58d6)\n- Xamarin.Android SDK 7.1.0.41 (9578cdc)\n- Xamarin.iOS and Xamarin.Mac SDK 10.4.0.123 (35d1ccd)\n- Visual Studio Tools for Unity 3.0.0.1\n- Visual Studio Tools for Universal Windows Apps 15.0.26228.00\n- Mono Debugging for Visual Studio Mono.Debugging.VisualStudio\n- ASP.NET and Web Tools 2017 15.0.30223.0\n- NuGet Package Manager 4.0.0\n- Common Azure Tools 1.9\n- NpgsqlVSPackage Extension 1.0\n- Merq 1.1.13-alpha (2f64b6d)\n- VSPackage Extension 1.2\n- Other extentions JetBrains ReSharper Ultimate 2016.3.2 - なにはともあれ入れておく。 CodeMaid 10.2.7 - 気軽にコード整形してくれる。 .ignore 1.2.71 Markdown Editor 1.11.201 File Nesting 2.6.67 GitHub.VisualStudio 2.2.0.8 VSColorOutput 2.5 HideMenu 1.0 - MinimaliticViewとの組み合わせでEmacsっぽい画面になる。 MinimaliticView Extension 1.0 \n- JetBrains ReSharper Ultimate 2016.3.2 - なにはともあれ入れておく。\n- CodeMaid 10.2.7 - 気軽にコード整形してくれる。\n- .ignore 1.2.71\n- Markdown Editor 1.11.201\n- File Nesting 2.6.67\n- GitHub.VisualStudio 2.2.0.8\n- VSColorOutput 2.5\n- HideMenu 1.0 - MinimaliticViewとの組み合わせでEmacsっぽい画面になる。\n- MinimaliticView Extension 1.0\n- Debug用エミュレーター XAML Previewer for Xamarin.Forms - Gorilla PlayerはVS2017未対応の上、Data Bindingを参照できないため機能的にXAML Previewer for Xamarin.Formsとほぼかわらない様子。 Android Emulator Manager/Android SDK Manager - VS2017ではHyper-VベースのVisual Studio Emulator for Xamarinがなくなり、Intel HAXMベースのAndroid Emulator Manager/Android SDK Manager (Google)のみとなった。 \n- XAML Previewer for Xamarin.Forms - Gorilla PlayerはVS2017未対応の上、Data Bindingを参照できないため機能的にXAML Previewer for Xamarin.Formsとほぼかわらない様子。\n- Android Emulator Manager/Android SDK Manager - VS2017ではHyper-VベースのVisual Studio Emulator for Xamarinがなくなり、Intel HAXMベースのAndroid Emulator Manager/Android SDK Manager (Google)のみとなった。\n- DevStack Prism Prism template - スキャフォールド、スニペット便利 Profile78 - Profile259になっているがWindows 8必要ないので Newtonsoft.Json FubarCoder.RestSharp.Portable.HttpClient NUnit Moq \n- Prism Prism template - スキャフォールド、スニペット便利 Profile78 - Profile259になっているがWindows 8必要ないので Newtonsoft.Json FubarCoder.RestSharp.Portable.HttpClient NUnit Moq \n- Prism template - スキャフォールド、スニペット便利\n- Profile78 - Profile259になっているがWindows 8必要ないので\n- Newtonsoft.Json\n- FubarCoder.RestSharp.Portable.HttpClient\n- NUnit\n- Moq   > キーバインドキーバインド \n\nおまけのEmacs風キーバインド。Edit.Emacsメソッドは1級市民ではないのでその周辺で代替します。Edit.LineCut、Edit.Outline、ReSharpeのいらないキーバインドは削除しています。    category command keybind     Navigation CodeMaid.SwitchFile C-c,:   Navigation Edit.CharLeft C-b   Navigation Edit.CharRight C-f   Navigation Edit.DocumentBottom M->   Navigation Edit.DocumentTop M-<   Navigation Edit.GoTo M-g   Navigation Edit.IncrementalSearch C-s   Navigation Edit.LineDown C-n   Navigation Edit.LineEnd C-e   Navigation Edit.LineStart C-a   Navigation Edit.LineUp C-p   Navigation Edit.NextMethod M-}   Navigation Edit.PageDown C-v   Navigation Edit.PageUp M-v   Navigation Edit.PreviousMethod M-{   Navigation Edit.ScrollLineCenter C-l   Navigation Edit.ToggleAllOutling C-u,M-c   Navigation Edit.ToggleOutlingExpansion C-i   Navigation Edit.WordNext M-f   Navigation Edit.WordPrevious M-b   Navigation ReSharper.ReSharper_GotoRecentFiles M-x,b   Navigation Team.TeamExplorerSearch C-x,g   Navigation View.C#Interactive C-c,i   Navigation Window.NewVerticalTabGroup C-x,&#124;   Navigation Window.PreviousTabGroup C-x,1   Edit Build.BuildSolution C-c,b   Edit Build.RebuildSolution C-c,r   Edit CodeMaid.JoinLine C-c,j   Edit CodeMaid.SortLines M-x,s   Edit Debug.Start C-c,d   Edit Edit.BackwardDelete C-h   Edit Edit.BackwardDelete M-h   Edit Edit.BreakLine C-m   Edit Edit.Capitalize M-c   Edit Edit.CommentSelection M-;   Edit Edit.Delete C-d   Edit Edit.InsertSnippet C-,   Edit Edit.LineCut C-k   Edit Edit.LineDownExtendColumn M-.   Edit Edit.LineUpExtendColumn M-,   Edit Edit.MakeLowercase M-l   Edit Edit.MakeUppercase M-u   Edit Edit.Paste C-y   Edit Edit.SelectCurrentWord C-SPC   Edit Edit.UncommentSelection M-:   Edit Edit.Undo M-/   Edit File.Close C-x,k   Edit File.SaveSelection C-x,C-s   Edit Project.AddNewItem C-c,s   Edit ReSharpe._ReSharper_DuplicateText C-c,p   Edit ReSharper.ReSharper_GotoRelatedFile C-c,;   Edit ReSharper.ReSharper_GotoText C-c,g   Edit Tools.ManageNuGetPackagesforSolution C-c,n   Edit Tools.Options M-0   Edit View.PackageManagerConsole C-q,1      > WRAPUPWRAPUP \n\n途中途中心の声が漏れていますが、なんとか触れる状態になってきました。ただ、モチベーションとしては下がり気味なのでこのままXamarinをさわり続けるかは分かりません。やはり文化が違いますね。"},"name":"[2017-03-31]Xamarin開発環境をととのえる","tags":["xamarin.forms","prism","xamarin"],"childPublishedDate":{"published_on":"2017-03-31T00:00:00.000Z","published_on_unix":1490918400}}},{"node":{"number":60,"relative_category":"blog/backend","fields":{"title":"連載 Rails2Phoenix 2 認証機能を実装する","excerpt":"連載「Rails2Phoenix」になります、前回は「UmbrellaプロジェクトをHerokuにデプロイする 」でした。今回は前回課題としてあがった認証機能の実装を試みたいと思います。   > PROBLEMPROBLEM \n\n- サービスについて 拡張にともない技術スタックがふえるのを抑えたい スケーラビリティのためのコストを抑えたい パフォーマンスをあげたい \n- 拡張にともない技術スタックがふえるのを抑えたい\n- スケーラビリティのためのコストを抑えたい\n- パフォーマンスをあげたい   > SOLUTIONSOLUTION \n\nというわけで、現在つかっているRailsをPhoenixに変更することにしました。方針は以下の通りで、今回はRails/Deviseの認証機能をPhoenixで実装する流れを取り上げます。 \n\n方針 \n\n- Railsから徐々にPhoenixに移行できるように いままでとおなじPaaS（Heroku） いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく いままでとおなじDB 移行完了までDBマイグレーションをしない \n- いままでとおなじPaaS（Heroku）\n- いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく \n- ブランチ戦略は phoenix/base をベースに\n- 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく\n- いままでとおなじDB 移行完了までDBマイグレーションをしない \n- 移行完了までDBマイグレーションをしない\n- Phoenixは今後の拡張性をかんがえてUmbrellaプロジェクトで   > Guardianを実装するGuardianを実装する \n\nまず、参考にしたのはBlackodeのguardian_authです。ただ、Guardianのバージョンがふるいので1.0へのマイグレーション記事をもとにアレンジしてあります。認証に関係しそうな構成は下記の通り。 \n\nロジック \n\n- MyApp.Account\n- MyApp.Account.Registration\n- MyApp.Account.User\n- MyApp.Auth.Guardian\n- MyApp.Auth.ErrorHandler\n- MyApp.Auth.Pipeline\n- MyApp.Auth.AfterPipeline\n- MyApp.Auth.Session \n\nコントローラ \n\n- MyAppWeb.RegistrationController\n- MyAppWeb.SessionController   > シリアライザとエラーハンドラの設定シリアライザとエラーハンドラの設定 \n\nGuardian1.0から直接ではなくモジュールを介して参照するようになりました。下記のように各モジュールを用意してコンフィグに割り当てます。   elixir \n\n# apps/my_app/lib/my_app/auth/guardian.ex defmodule MyApp.Auth.Guardian do use Guardian, otp_app: :my_app alias MyApp.Account def subject_for_token(resource, _claims), do: {:ok, to_string(resource.id)} def subject_for_token(_, _), do: {:error, :reason_for_error} def resource_from_claims(claims), do: {:ok, Account.get_user!(claims[\"sub\"])} def resource_from_claims(_claims), do: {:error, :reason_for_error} end     elixir \n\n# apps/my_app/lib/my_app/auth/error_handler.ex defmodule MyApp.Auth.ErrorHandler do import Plug.Conn def auth_error(conn, {type, _reason}, _opts) do body = Poison.encode!(%{message: to_string(type)}) send_resp(conn, 401, body) end end     elixir \n\n# apps/my_app/config/config.exs config :my_app, MyApp.Auth.Guardian, issuer: \"MyApp\", ttl: {30, :days}, allowed_drift: 2000, # optionals allowed_algos: [\"HS512\"], verify_module: MyApp.Auth.Guardian.JWT, verify_issuer: true, secret_key: System.get_env(\"GUARDIAN_SECRET\") || \"secret_key\"     > ルーターの設定ルーターの設定 \n\n認証のパイプラインは、認証中と認証後のものを用意しコンフィグとルーターに割り当てます。 \n\nルータースコープ内のパイプラインくみあわせについて、ここでは未ログインスコープには認証前・認証中パイプライン、ログイン済スコープには認証前・認証中・認証後パイプラインを適用しています。こうすることでどのスコープにも認証リソースをロードすることができ、かつ、認証も担保することができるようになります。具体的にいうと、ルート / などの同一URLで未ログインスコープとログイン済スコープの切り替えができるようになります。   elixir \n\n# apps/my_app/lib/my_app/auth/pipeline.ex defmodule MyApp.Auth.Pipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.VerifySession, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.VerifyHeader, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.LoadResource, allow_blank: true) end     elixir \n\n# apps/my_app/lib/my_app/auth/after_pipeline.ex defmodule MyApp.Auth.AfterPipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.EnsureAuthenticated) end     elixir \n\n# apps/my_app/lib/my_app_web/router.ex defmodule MyAppWeb.Router do use MyAppWeb, :router pipeline :browser do plug(:accepts, [\"html\"]) plug(:fetch_session) plug(:fetch_flash) plug(:protect_from_forgery) plug(:put_secure_browser_headers) end pipeline :browser_auth do plug(MyApp.Auth.Pipeline) end pipeline :browser_auth_after do plug(MyApp.Auth.AfterPipeline) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth]) post(\"/registration\", RegistrationController, :create) get(\"/login\", SessionController, :new) post(\"/login\", SessionController, :create) get(\"/logout\", SessionController, :delete) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth, :browser_auth_after]) get(\"/edit\", RegistrationController, :edit) put(\"/edit\", RegistrationController, :update) get(\"/users\", UserController, :index) resources \"/\", UserController, only: [:show, :delete], param: \"username\" end end     elixir \n\n# apps/my_app/config/config.exs config :MyApp, MyApp.Auth.Pipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler config :MyApp, MyApp.Auth.AferPipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler     > 登録登録 \n\n登録は登録用のロジック（ユーザーモデルと登録サービス）とコントローラを用意します。 \n\nこのあたりはDevise/Railsとあまり変わりません。他のアクション「新規パスワード発行」「メールアドレス確認」等も同様の構成をとろうと思っています。   elixir \n\n# apps/my_app/lib/my_app_web/controller/registration_controller.ex def create(conn, user_params) do changeset = User.registration_changeset(%User{}, user_params) case Registration.create(changeset, Repo) do {:ok, user} -> conn |> MyApp.Auth.login(user) |> put_flash(:info, \"Your account was created successfully\") |> redirect(to: page_path(conn, :home)) {:error, changeset} -> conn |> put_flash(:error, \"Unable to create account: Try again\") |> render(MyAppWeb.PageView, \"home.html\", changeset: changeset) end end     elixir \n\n# apps/my_app/lib/my_app/auth/auth.ex def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end     elixir \n\n# apps/my_app/lib/my_app/account/registration.ex def create(changeset, repo) do changeset |> repo.insert() end     > ログイン・ログアウトログイン・ログアウト \n\nログイン・ログアウトはセッション用のサービスとコントローラで実装します。   elixir \n\n# apps/my_app/lib/my_app_web/controller/session_controller.ex @doc \"Logged in [POST /login]\" def create(conn, %{\"email\" => email, \"password\" => password}) do case Session.authenticate_user(email, password) do {:ok, user} -> conn |> Session.login(user) |> put_flash(:info, \"Logged in successfully\") |> redirect(to: page_path(conn, :home)) {:error, _reason} -> conn |> put_flash(:error, \"Wrong username/password\") |> render(\"new.html\") end end @doc \"Logged out [DELETE /logout]\" def delete(conn, _params) do conn |> Session.logout() |> put_flash(:info, \"Logged out successfully.\") |> redirect(to: \"/\") end     elixir \n\n# apps/my_app/lib/my_app/auth/session.ex defmodule MyApp.Auth.Session do import Ecto.Query import Plug.Conn import Comeonin.Bcrypt, only: [checkpw: 2, dummy_checkpw: 0] alias MyApp.Repo alias MyApp.Auth.Guardian alias MyApp.Account.User def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end def logout(conn), do: Guardian.Plug.sign_out(conn) def authenticate_user(email, given_password) do query = Ecto.Query.from(u in User, where: u.email == ^email) Repo.one(query) |> check_password(given_password) end def current_user(conn), do: Guardian.Plug.current_resource(conn, []) def logged_in?(conn), do: Guardian.Plug.authenticated?(conn, []) defp check_password(nil, _), do: {:error, \"Incorrect username or password\"} defp check_password(user, given_password) do case Comeonin.Bcrypt.checkpw(given_password, user.encrypted_password) do true -> {:ok, user} false -> {:error, \"Incorrect email or password\"} end end end   \n\nDevise/Railsのビューヘルパーはビューマクロで適用します。   elixir \n\n# apps/my_app/lib/my_app_web.ex def view do quote do # .. import Okuribi.Auth.Session, only: [current_user: 1, logged_in?: 1] end end   \n\nあるいは、put_assigns関数をはやしてコントローラマクロに適用します。   elixir \n\n# apps/my_app/lib/my_app/auth/session.ex def put_assigns(%{private: %{phoenix_action: action}} = conn, settings) do current_resource = Guardian.Plug.current_resource(conn) settings = if current_resource, do: settings[:sign_in][action] || [], else: settings[:sign_out][action] || [] conn |> assign(:current_user, current_resource) |> assign(:page_title, settings[:page_title]) |> assign(:page_description, settings[:page_description]) end     elixir \n\n# apps/my_app/lib/my_app_web.ex def controller do quote do # .. import Okuribi.Auth, only: [put_assigns: 2] end end   \n\nassignsひとつでアクセスできるので、下記のようにコントローラでまとめて指定することでRailsのActionView::Helpers::CaptureHelper#provideの代わりに使えます。   elixir \n\n# apps/my_app/lib/my_app_web/controller/*_controller.ex @page %{ sign_in: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_in.page_title\"), page_description: \"\" } }, sign_out: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_out.page_title\"), page_description: \"\" } } } plug(:put_assigns, @page when action in [:home])     > その他その他 \n\nRailsのビューをPhoenixのテンプレートに移植するには下記の変換を地道に行っていきます。 \n\n- Rails ActionView::Helpers::FormHelper#form_for(record, options={}, &block) ActionView::Helpers::FormHelper#text_field(object_name, method, options={}) ActionView::Helpers::FormHelper#file_field(object_name, method, options={}) ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={}) ActionView::Helpers::FormHelper#password_field(object_name, method, options={}) ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={}) ActionView::Helpers::FormBuilder#submit(value=nil, options={}) ActionView::Helpers::TranslationHelper#t \n- ActionView::Helpers::FormHelper#form_for(record, options={}, &block)\n- ActionView::Helpers::FormHelper#text_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#file_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#password_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={})\n- ActionView::Helpers::FormBuilder#submit(value=nil, options={})\n- ActionView::Helpers::TranslationHelper#t\n- Phoenix Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun) Phoenix.HTML.Form.text_input(form, field, opts \\\\ []) Phoenix.HTML.Form.file_input(form, field, opts \\\\ []) Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ []) Phoenix.HTML.Form.password_input(form, field, opts \\\\ []) Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ []) Phoenix.HTML.Form.submit(opts, opts \\\\ []) Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{}) \n- Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun)\n- Phoenix.HTML.Form.text_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.file_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.password_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ [])\n- Phoenix.HTML.Form.submit(opts, opts \\\\ [])\n- Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{})   > WRAPUPWRAPUP \n\n前回もそうですが、コードのマイグレーションはまあ地味な作業ですよね。とまれ、認証機能を実装できたので良しとしましょう。"},"name":"[2018-05-20]連載 Rails2Phoenix 2 認証機能を実装する","tags":["phoenix-framework","elixir","ruby-on-rails","ruby","wercker","heroku","authentication","guardian"],"childPublishedDate":{"published_on":"2018-05-20T00:00:00.000Z","published_on_unix":1526774400}}}]}},"pageContext":{"number":63}},"staticQueryHashes":[]}