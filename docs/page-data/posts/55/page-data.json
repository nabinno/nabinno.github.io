{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/55","result":{"data":{"esaPost":{"number":55,"relative_category":"blog/backend","fields":{"title":"PositiveSSLをHerokuに適用する","excerpt":"> PROBLEMPROBLEM \n\n- HerokuのSSLの期限がきた。   > SOLUTIONSOLUTION \n\n- というわけで、いつもつかっているSSL販売代理店「NameCheap社のSSLs.com」でPositiveSSL（運用Comodo社）をHerokuに適用することに。   > HOWTOHOWTO \n\n1. 証明書を購入する まあ、SSL販売代理店であればどこでもいいんですが \n2. まあ、SSL販売代理店であればどこでもいいんですが\n3. 秘密鍵と署名リクエストをつくる 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key 署名リクエスト openssl req -new -key server.key -out server.csr \n4. 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 \n5. 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key \n6. 署名リクエスト openssl req -new -key server.key -out server.csr \n7. 証明書発行を申請する SSL販売代理店より署名リクエストserver.csrと関連情報を送信する \n8. SSL販売代理店より署名リクエストserver.csrと関連情報を送信する\n9. ドメイン保持の証明をする PositiveSSLの運用会社Comodoにたいしドメイン保持の証明をする 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択 \n10. PositiveSSLの運用会社Comodoにたいしドメイン保持の証明をする\n11. 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択\n12. Heroku用の証明書をつくる 証明タスクをこなししばらくすると、Comodo社より複数の証明書がおくられてくる Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n13. 証明タスクをこなししばらくすると、Comodo社より複数の証明書がおくられてくる\n14. Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n15. Herokuに証明書を適用する 新規で適用する場合 heroku addons:add ssl:endpoint heroku certs:add server.crt server.key 更新する場合 heroku certs:update server.crt server.key \n16. 新規で適用する場合 heroku addons:add ssl:endpoint heroku certs:add server.crt server.key \n17. heroku addons:add ssl:endpoint\n18. heroku certs:add server.crt server.key\n19. 更新する場合 heroku certs:update server.crt server.key \n20. heroku certs:update server.crt server.key","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/5fcde784-4a5e-40b2-8da2-4ea9d5abc177.png"},"wip":false,"body_md":"<img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/5fcde784-4a5e-40b2-8da2-4ea9d5abc177.png\">\r\n\r\n# PROBLEM\r\n- HerokuのSSLの期限がきた。\r\n\r\n# SOLUTION\r\n- というわけで、いつもつかっているSSL販売代理店「NameCheap社のSSLs.com」でPositiveSSL（運用Comodo社）をHerokuに適用することに。\r\n\r\n## HOWTO\r\n1. 証明書を購入する\r\n    - まあ、SSL販売代理店であればどこでもいいんですが\r\n2. 秘密鍵と署名リクエストをつくる\r\n    - 秘密鍵 `openssl genrsa -des3 -out server.orig.key 2048`\r\n    - 秘密鍵パスワードなし`openssl rsa -in server.orig.key -out server.key`\r\n    - 署名リクエスト `openssl req -new -key server.key -out server.csr`\r\n3. 証明書発行を申請する\r\n    - SSL販売代理店より署名リクエスト`server.csr`と関連情報を送信する\r\n4. ドメイン保持の証明をする\r\n    - PositiveSSLの運用会社Comodoにたいしドメイン保持の証明をする\r\n    - 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択\r\n5. Heroku用の証明書をつくる\r\n    - 証明タスクをこなししばらくすると、Comodo社より複数の証明書がおくられてくる\r\n    - Heroku用に証明書をつくる `cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt`\r\n6. Herokuに証明書を適用する\r\n    - 新規で適用する場合\r\n        - `heroku addons:add ssl:endpoint`\r\n        - `heroku certs:add server.crt server.key`\r\n    - 更新する場合\r\n        - `heroku certs:update server.crt server.key`\r\n\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/5fcde784-4a5e-40b2-8da2-4ea9d5abc177.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/5fcde784-4a5e-40b2-8da2-4ea9d5abc177.png\"></a>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-5:0\">\n<li data-sourcepos=\"4:1-5:0\">HerokuのSSLの期限がきた。</li>\n</ul>\n<h1 data-sourcepos=\"6:1-6:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<ul data-sourcepos=\"7:1-8:0\">\n<li data-sourcepos=\"7:1-8:0\">というわけで、いつもつかっているSSL販売代理店「NameCheap社のSSLs.com」でPositiveSSL（運用Comodo社）をHerokuに適用することに。</li>\n</ul>\n<h2 data-sourcepos=\"9:1-9:8\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"HOWTO\" name=\"HOWTO\" href=\"#HOWTO\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"HOWTO\"> &gt; HOWTO</span></a>HOWTO</h2>\n<ol data-sourcepos=\"10:1-30:0\">\n<li data-sourcepos=\"10:1-11:75\">証明書を購入する\n<ul data-sourcepos=\"11:5-11:75\">\n<li data-sourcepos=\"11:5-11:75\">まあ、SSL販売代理店であればどこでもいいんですが</li>\n</ul>\n</li>\n<li data-sourcepos=\"12:1-15:78\">秘密鍵と署名リクエストをつくる\n<ul data-sourcepos=\"13:5-15:78\">\n<li data-sourcepos=\"13:5-13:64\">秘密鍵 <code>openssl genrsa -des3 -out server.orig.key 2048</code>\n</li>\n<li data-sourcepos=\"14:5-14:85\">秘密鍵パスワードなし<code>openssl rsa -in server.orig.key -out server.key</code>\n</li>\n<li data-sourcepos=\"15:5-15:78\">署名リクエスト <code>openssl req -new -key server.key -out server.csr</code>\n</li>\n</ul>\n</li>\n<li data-sourcepos=\"16:1-17:93\">証明書発行を申請する\n<ul data-sourcepos=\"17:5-17:93\">\n<li data-sourcepos=\"17:5-17:93\">SSL販売代理店より署名リクエスト<code>server.csr</code>と関連情報を送信する</li>\n</ul>\n</li>\n<li data-sourcepos=\"18:1-20:127\">ドメイン保持の証明をする\n<ul data-sourcepos=\"19:5-20:127\">\n<li data-sourcepos=\"19:5-19:86\">PositiveSSLの運用会社Comodoにたいしドメイン保持の証明をする</li>\n<li data-sourcepos=\"20:5-20:127\">証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択</li>\n</ul>\n</li>\n<li data-sourcepos=\"21:1-23:173\">Heroku用の証明書をつくる\n<ul data-sourcepos=\"22:5-23:173\">\n<li data-sourcepos=\"22:5-22:114\">証明タスクをこなししばらくすると、Comodo社より複数の証明書がおくられてくる</li>\n<li data-sourcepos=\"23:5-23:173\">Heroku用に証明書をつくる <code>cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt &gt; server.crt</code>\n</li>\n</ul>\n</li>\n<li data-sourcepos=\"24:1-30:0\">Herokuに証明書を適用する\n<ul data-sourcepos=\"25:5-30:0\">\n<li data-sourcepos=\"25:5-27:50\">新規で適用する場合\n<ul data-sourcepos=\"26:9-27:50\">\n<li data-sourcepos=\"26:9-26:42\"><code>heroku addons:add ssl:endpoint</code></li>\n<li data-sourcepos=\"27:9-27:50\"><code>heroku certs:add server.crt server.key</code></li>\n</ul>\n</li>\n<li data-sourcepos=\"28:5-30:0\">更新する場合\n<ul data-sourcepos=\"29:9-30:0\">\n<li data-sourcepos=\"29:9-30:0\"><code>heroku certs:update server.crt server.key</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","tags":[],"updated_at":"2021-01-11T12:50:52+09:00","childPublishedDate":{"published_on":"2017-04-23T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":61,"relative_category":"blog/health","fields":{"title":"ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","excerpt":"皆さんは体調管理どうされていますか。一度痛い目に遭うと日常の細かい差異が気になってきて、そこをどうにか解決したいというのが人情です。今回は自分の咽頭痛の解消のため一つ実験をしてみました。   > PROBLEMPROBLEM \n\n- 以前からオフィスに行くと目や喉が痛くなることがあったので、自分の体調なのか環境なのか原因を切り分けるために汚染計測器「Dienmern DM106A」を購入 ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる \n- ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる   > SOLUTIONSOLUTION \n\nというわけで、DM106AのセンサーデータをRaspberry Piで定期取得することにしました。設置方法の詳細はGitHubレポジトリを参照ください。下記、実装概要になります。   > 電子部品の構成電子部品の構成    item description     Raspberry Pi 3 Model B+    Aosong DHT11 気温・湿度センサー、GPIO   Nova SDS021 PM2.5・PM10センサー、UART   ams CCS811 TVOC・CO2eセンサー、I2C    \n\nまず、電子工作は素人ゆえどのセンサーを買えばいいか分からなかったのでDM106Aを分解して各センサーの型番を調べました。DHT011、SDS021はDM106Aとおなじセンサー、HCHOセンサーは信頼性があり手ごろなのがうまく見つけられませんでした。TVOCセンサーはAdafruitが推しているCCS811を採用しました。   > コードの構成コードの構成    item description     AirElixir.Application アプリケーション管理   AirElixir.GoogleSpreadsheets センサーデータ記録   AirElixirSensor.Publisher センサーデータ発行・送信   AirElixirSensor.Subscriber センサーデータ購読・受信    \n\n次に、基本構成はGrovePiを参考にしました。発行処理はElixirでうまくいかないケースがあったのでまずはPython/ErlPortで行いました。後々Elixirに移行できるようにマクロにしました。   > 5日ほど稼働してわかったこと・見立て、今後の課題5日ほど稼働してわかったこと・見立て、今後の課題  \n\n最後に、分かったこと、見立てですが、3点あります。2番目に関しては予想通りだったのですが、1番目、3番目に関しては意外であり、疑り深い私としては特に空気清浄機がきちんと機能していたことに驚きました。 \n\n1. オフィスの空気清浄機「Hitachi EP-LVG110」はPMをきちんとフィルターしていた ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている \n2. ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている\n3. 人の入りが多い時間帯に空気（TVOCやCO2e）が汚れる 人が「出る」時よりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察 \n4. 人が「出る」時よりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察\n5. TVOCやCO2eはPMのうごきに連動している（かも） チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n6. チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n7. TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n\n課題としてはその性質からして仕方ないのですがTVOCの変動が大きすぎて解読を難しかったです。計測方法等を再度見直す必要がありそうです。 \n\n- TVOCの変動が大きすぎる ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均 \n- ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均\n- TVOCのスパイクを抑えたい TODO: ファイトレメディエーションによる効果を見ていきたいところ \n- TODO: ファイトレメディエーションによる効果を見ていきたいところ   > WRAPUPWRAPUP \n\n今回の実験はこれが言いたかっただけという指摘をされるとぐうの音も出ませんが、はっきり言わせてください。そう、Elixirは健康管理に向いています。   txt \n\n「なんか体調がすぐれないなあ...」 「Elixirちょうだい!」   \n\nという感じです、はい。"},"name":"[2018-12-22]ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","tags":["elixir","raspberry-pi","particulates","physiology"],"childPublishedDate":{"published_on":"2018-12-22T00:00:00.000Z","published_on_unix":1545436800}}},{"node":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- https://github.com/nabinno/esa.red   > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（nabinno/red-elixir）。 \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。"},"name":"[2019-03-31]イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","tags":["red","esa"],"childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z","published_on_unix":1553990400}}},{"node":{"number":56,"relative_category":"blog/backend","fields":{"title":"RubyのCSVパースをPyCallで実行する（ベンチマーク）","excerpt":"先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。   > PROBLEMPROBLEM \n\n- 大量のCSVを読み込む際、毎回時間がかかる   > SOLUTIONSOLUTION \n\nというわけで、「Dalibor Nasevicのベンチマーク記事」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り CSV.foreach が速いとの結論でした。    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0      > PyCallのベンチマークPyCallのベンチマーク \n\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。   ruby \n\nrequire_relative './helpers' require 'pycall/import' include PyCall::Import pyimport :pandas, as: :pd print_memory_usage do print_time_spent do csv = pd.read_csv.('data.csv') sum = csv['id'].sum.() puts \"Sum: #{sum}\" end end   \n\nPyCallは pyenv との相性が悪いのでSystemインストールしたPythonでたたきます。   sh \n\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb Sum: 499999500000 Time: 1.49 Memory: 54.99 MB   \n\n結果    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0   6. PyCall 1.49 54.99    \n\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった CSV.foreach より16倍の実行速度となりました。   > WRAPUPWRAPUP \n\nPyCallのオブジェクトが PyObjectとActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。 \n\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。"},"name":"[2017-06-05]RubyのCSVパースをPyCallで実行する（ベンチマーク）","tags":["ruby","benchmark","pycall"],"childPublishedDate":{"published_on":"2017-06-05T00:00:00.000Z","published_on_unix":1496620800}}}]}},"pageContext":{"number":55}},"staticQueryHashes":[]}