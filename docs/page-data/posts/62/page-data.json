{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/62","result":{"data":{"esaPost":{"number":62,"relative_category":"blog/backend","fields":{"title":"Elixirではてなブックマーク","excerpt":"> PROBLEMPROBLEM \n\n- フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- あとで確認することができない\n- 読みたくない記事をブクマしてしまう\n- 適切でないURLでブクマしてしまう   > SOLUTIONSOLUTION \n\nというわけで、下記の方針でブクマすることにした。設置方法の詳細はGitHubレポジトリを参照。 \n\n方針 \n\n- フィードごとにタグづけする\n- ブクマ対象になる記事をリンクとタイトルで除外判定する\n- ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する\n- 上記設定はYAMLファイルで簡単に管理できるようにする\n- フィード読込とブクマを非同期処理できるようElixirで実装する   > ブクマの管理方法ブクマの管理方法 \n\n下記5つのYAMLファイルで管理している、構造はマップとリストのみ。記事を読みすすめる中で気になるキーワードが出てきたら都度 feed.yaml を更新する。また、記事にノイズが多いようだったら傾向を分析して除外ファイル feed_excluded_link.yaml feed_excluded_title.yaml を更新してる。    item description     feed.yaml フィードグループ名に対するリンク、タグのマップ   feed_excluded_link.yaml 除外すべきフィードリンクのリスト   feed_excluded_title.yaml 除外すべきフィードタイトルのリスト   feed_corrected_link.yaml フィードリンクに対するトリミングすべきパラメータのマップ   feed_redirected_link.yaml フィードリンクに対するリダイレクト先リンクのマップ      yaml \n\n# feed.yaml nabinno/sports/feed_group_name: tags: - ski links: - http://rss.example.com/ski_feed.rss - http://rss.example.com/snowboard_feed.rss - http://ski-status.example.com/rss # feed_excluded_link.yaml - anti-ski.example.com - awesome-snowboard.example.com # feed_excluded_title.yaml - queer - two-planker - beaver-tail # feed_corrected_link.yaml amazon.com: - ref - ie # feed_redirected_link.yaml ski-status.example.com: - Floki.find(fst, \".post__body a\")     > Elixirによる非同期処理Elixirによる非同期処理   > 監視機構 Supervisor監視機構 Supervisor \n\nElixirには監視機構があり、それが各ワーカーを子プロセスとして管理している。ここではフィード読込とブクマは別々のワーカーで処理しているが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ one_for_all ）にしてある。 \n\n下記のように Supervisor.start_link を Keshikimi2.Application.start に適用すると、アプリケーション開始（ mix run ）した時点で監視機構が起動される。   ex \n\nSupervisor.start_link( [ :hackney_pool.child_spec(:hatena_bookmark_pool, timeout: 15_000, max_connections: 100), # @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する supervisor(Cachex, [:feed, []]), supervisor(Keshikimi2Feed.Registry, [prefix]), # フィード読込処理 (PubSub) supervisor(Keshikimi2Feed.Subscriber, [prefix]), worker(Keshikimi2Feed.Worker, [prefix]), worker(Keshikimi2Feed.Publisher, [[prefix: prefix, poll_interval: 3_000]]), # ブクマ処理 worker(Keshikimi2.HatenaBookmark.AddEntry, [ [prefix: prefix, poll_interval: 3_000] ]) ], strategy: :one_for_all, name: name(prefix) )     > 非同期処理 Task.async_stream非同期処理 Task.async_stream \n\n配列を引き回すリクエスト処理は Task.async_stream がうってつけである。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいる。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができる。   ex \n\nCachex.keys!(:feed) |> Enum.reject(fn key -> key in [ \"excluded_links\", \"excluded_titles\", \"corrected_links\", \"redirected_links\", \"feed_group\", \"archived_links\" ] end) |> Task.async_stream( fn item_link -> with {:ok, [item_title, feed_tags]} <- Cachex.get(:feed, item_link), :ok <- validate_all(item_link, item_title), corrected_link <- correct_all(item_link), {:ok, payload} <- FormData.create( %{ url: corrected_link, comment: feed_tags |> Enum.map_join(fn tag -> \"[#{tag}]\" end), rks: System.get_env(\"HATENA_BOOKMARK_RKS\"), private: 0, keep_original_url: 1, with_status_op: 1, from: \"inplace\", post_twitter: 0, post_evernote: 0 }, :url_encoded, get: false ) do do_add_entries_to_hb(payload) Logger.info(\"add entry: #{item_link}\") end archive_link(item_link) end, timeout: 15_000 ) |> Stream.run()     > WRAPUPWRAPUP   > これからのはてなブックマークの使い方これからのはてなブックマークの使い方 \n\n- 手動でブクマ: 気になった記事があるごとに\n- ブクマの確認: 気になるタグごとにまとめて確認 たとえば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「nabinno/github」をみる、という感じ。 \n- たとえば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「nabinno/github」をみる、という感じ。","thumbnail":"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png"},"wip":false,"body_md":"<img alt=thumbnail src=https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png />\r\n\r\n# PROBLEM\r\n- フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる\r\n    - フィードをそのままブクマしていると下記の問題がでてくる\r\n        - あとで確認することができない\r\n        - 読みたくない記事をブクマしてしまう\r\n        - 適切でないURLでブクマしてしまう\r\n\r\n# SOLUTION\r\nというわけで、下記の方針でブクマすることにした。設置方法の詳細は[GitHubレポジトリ](https://github.com/nabinno/keshikimi2)を参照。\r\n\r\n**方針**\r\n\r\n- フィードごとにタグづけする\r\n- ブクマ対象になる記事をリンクとタイトルで除外判定する\r\n- ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する\r\n- 上記設定はYAMLファイルで簡単に管理できるようにする\r\n- フィード読込とブクマを非同期処理できるようElixirで実装する\r\n\r\n## ブクマの管理方法\r\n下記5つのYAMLファイルで管理している、構造はマップとリストのみ。記事を読みすすめる中で気になるキーワードが出てきたら都度 `feed.yaml` を更新する。また、記事にノイズが多いようだったら傾向を分析して除外ファイル `feed_excluded_link.yaml` `feed_excluded_title.yaml` を更新してる。\r\n\r\n| item                        | description                                              |\r\n|-----------------------------|----------------------------------------------------------|\r\n| `feed.yaml`                 | フィードグループ名に対するリンク、タグのマップ           |\r\n| `feed_excluded_link.yaml`   | 除外すべきフィードリンクのリスト                         |\r\n| `feed_excluded_title.yaml`  | 除外すべきフィードタイトルのリスト                       |\r\n| `feed_corrected_link.yaml`  | フィードリンクに対するトリミングすべきパラメータのマップ |\r\n| `feed_redirected_link.yaml` | フィードリンクに対するリダイレクト先リンクのマップ       |\r\n\r\n```yaml\r\n# feed.yaml\r\nnabinno/sports/feed_group_name:\r\n  tags:\r\n    - ski\r\n  links:\r\n    - http://rss.example.com/ski_feed.rss\r\n    - http://rss.example.com/snowboard_feed.rss\r\n    - http://ski-status.example.com/rss\r\n\r\n# feed_excluded_link.yaml\r\n- anti-ski.example.com\r\n- awesome-snowboard.example.com\r\n\r\n# feed_excluded_title.yaml\r\n- queer\r\n- two-planker\r\n- beaver-tail\r\n\r\n# feed_corrected_link.yaml\r\namazon.com:\r\n  - ref\r\n  - ie\r\n\r\n# feed_redirected_link.yaml\r\nski-status.example.com:\r\n  - Floki.find(fst, \".post__body a\")\r\n```\r\n\r\n## Elixirによる非同期処理\r\n### 監視機構 Supervisor\r\n\r\nElixirには監視機構があり、それが各ワーカーを子プロセスとして管理している。ここではフィード読込とブクマは別々のワーカーで処理しているが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ `one_for_all` ）にしてある。\r\n\r\n下記のように `Supervisor.start_link` を `Keshikimi2.Application.start` に適用すると、アプリケーション開始（ `mix run` ）した時点で監視機構が起動される。\r\n\r\n```ex\r\nSupervisor.start_link(\r\n  [\r\n    :hackney_pool.child_spec(:hatena_bookmark_pool, timeout: 15_000, max_connections: 100),\r\n    # @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する\r\n    supervisor(Cachex, [:feed, []]),\r\n    supervisor(Keshikimi2Feed.Registry, [prefix]),\r\n\r\n    # フィード読込処理 (PubSub)\r\n    supervisor(Keshikimi2Feed.Subscriber, [prefix]),\r\n    worker(Keshikimi2Feed.Worker, [prefix]),\r\n    worker(Keshikimi2Feed.Publisher, [[prefix: prefix, poll_interval: 3_000]]),\r\n\r\n    # ブクマ処理\r\n    worker(Keshikimi2.HatenaBookmark.AddEntry, [\r\n      [prefix: prefix, poll_interval: 3_000]\r\n    ])\r\n  ],\r\n  strategy: :one_for_all,\r\n  name: name(prefix)\r\n)\r\n```\r\n\r\n### 非同期処理 Task.async_stream\r\n\r\n配列を引き回すリクエスト処理は `Task.async_stream` がうってつけである。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいる。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができる。\r\n\r\n```ex\r\nCachex.keys!(:feed)\r\n|> Enum.reject(fn key ->\r\n  key in [\r\n    \"excluded_links\",\r\n    \"excluded_titles\",\r\n    \"corrected_links\",\r\n    \"redirected_links\",\r\n    \"feed_group\",\r\n    \"archived_links\"\r\n  ]\r\nend)\r\n|> Task.async_stream(\r\n  fn item_link ->\r\n    with {:ok, [item_title, feed_tags]} <- Cachex.get(:feed, item_link),\r\n         :ok <- validate_all(item_link, item_title),\r\n         corrected_link <- correct_all(item_link),\r\n         {:ok, payload} <-\r\n           FormData.create(\r\n             %{\r\n               url: corrected_link,\r\n               comment: feed_tags |> Enum.map_join(fn tag -> \"[#{tag}]\" end),\r\n               rks: System.get_env(\"HATENA_BOOKMARK_RKS\"),\r\n               private: 0,\r\n               keep_original_url: 1,\r\n               with_status_op: 1,\r\n               from: \"inplace\",\r\n               post_twitter: 0,\r\n               post_evernote: 0\r\n             },\r\n             :url_encoded,\r\n             get: false\r\n           ) do\r\n      do_add_entries_to_hb(payload)\r\n      Logger.info(\"add entry: #{item_link}\")\r\n    end\r\n\r\n    archive_link(item_link)\r\n  end,\r\n  timeout: 15_000\r\n)\r\n|> Stream.run()\r\n```\r\n\r\n# WRAPUP\r\n## これからのはてなブックマークの使い方\r\n\r\n- **手動でブクマ:** 気になった記事があるごとに\r\n- **ブクマの確認:** 気になるタグごとにまとめて確認\r\n    - たとえば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「[nabinno/github](http://b.hatena.ne.jp/nabinno/github)」をみる、という感じ。\r\n","body_html":"<a href=\"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"thumbnail\" src=\"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png\"></a>\n<h1 data-sourcepos=\"3:1-3:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"4:1-9:0\">\n<li data-sourcepos=\"4:1-9:0\">フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる\n<ul data-sourcepos=\"5:5-9:0\">\n<li data-sourcepos=\"5:5-9:0\">フィードをそのままブクマしていると下記の問題がでてくる\n<ul data-sourcepos=\"6:9-9:0\">\n<li data-sourcepos=\"6:9-6:52\">あとで確認することができない</li>\n<li data-sourcepos=\"7:9-7:61\">読みたくない記事をブクマしてしまう</li>\n<li data-sourcepos=\"8:9-9:0\">適切でないURLでブクマしてしまう</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"10:1-10:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"11:1-11:170\">というわけで、下記の方針でブクマすることにした。設置方法の詳細は<a href=\"https://github.com/nabinno/keshikimi2\" target=\"_blank\" rel=\"noopener noreferrer\">GitHubレポジトリ</a>を参照。</p>\n<p data-sourcepos=\"13:1-13:10\"><strong>方針</strong></p>\n<ul data-sourcepos=\"15:1-20:0\">\n<li data-sourcepos=\"15:1-15:41\">フィードごとにタグづけする</li>\n<li data-sourcepos=\"16:1-16:80\">ブクマ対象になる記事をリンクとタイトルで除外判定する</li>\n<li data-sourcepos=\"17:1-17:122\">ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する</li>\n<li data-sourcepos=\"18:1-18:75\">上記設定はYAMLファイルで簡単に管理できるようにする</li>\n<li data-sourcepos=\"19:1-20:0\">フィード読込とブクマを非同期処理できるようElixirで実装する</li>\n</ul>\n<h2 data-sourcepos=\"21:1-21:27\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"ブクマの管理方法\" name=\"%E3%83%96%E3%82%AF%E3%83%9E%E3%81%AE%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95\" href=\"#%E3%83%96%E3%82%AF%E3%83%9E%E3%81%AE%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"ブクマの管理方法\"> &gt; ブクマの管理方法</span></a>ブクマの管理方法</h2>\n<p data-sourcepos=\"22:1-22:375\">下記5つのYAMLファイルで管理している、構造はマップとリストのみ。記事を読みすすめる中で気になるキーワードが出てきたら都度 <code>feed.yaml</code> を更新する。また、記事にノイズが多いようだったら傾向を分析して除外ファイル <code>feed_excluded_link.yaml</code> <code>feed_excluded_title.yaml</code> を更新してる。</p>\n<table data-sourcepos=\"24:1-30:115\">\n<thead>\n<tr data-sourcepos=\"24:1-24:90\">\n<th data-sourcepos=\"24:2-24:30\">item</th>\n<th data-sourcepos=\"24:32-24:89\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"26:1-26:113\">\n<td data-sourcepos=\"26:2-26:30\"><code>feed.yaml</code></td>\n<td data-sourcepos=\"26:32-26:112\">フィードグループ名に対するリンク、タグのマップ</td>\n</tr>\n<tr data-sourcepos=\"27:1-27:106\">\n<td data-sourcepos=\"27:2-27:30\"><code>feed_excluded_link.yaml</code></td>\n<td data-sourcepos=\"27:32-27:105\">除外すべきフィードリンクのリスト</td>\n</tr>\n<tr data-sourcepos=\"28:1-28:107\">\n<td data-sourcepos=\"28:2-28:30\"><code>feed_excluded_title.yaml</code></td>\n<td data-sourcepos=\"28:32-28:106\">除外すべきフィードタイトルのリスト</td>\n</tr>\n<tr data-sourcepos=\"29:1-29:118\">\n<td data-sourcepos=\"29:2-29:30\"><code>feed_corrected_link.yaml</code></td>\n<td data-sourcepos=\"29:32-29:117\">フィードリンクに対するトリミングすべきパラメータのマップ</td>\n</tr>\n<tr data-sourcepos=\"30:1-30:115\">\n<td data-sourcepos=\"30:2-30:30\"><code>feed_redirected_link.yaml</code></td>\n<td data-sourcepos=\"30:32-30:114\">フィードリンクに対するリダイレクト先リンクのマップ</td>\n</tr>\n</tbody>\n</table>\n<div class=\"code-block\" data-sourcepos=\"32:1-59:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"c1\"># feed.yaml</span>\n<span class=\"s\">nabinno/sports/feed_group_name</span><span class=\"pi\">:</span>\n  <span class=\"na\">tags</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">ski</span>\n  <span class=\"na\">links</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://rss.example.com/ski_feed.rss</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://rss.example.com/snowboard_feed.rss</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://ski-status.example.com/rss</span>\n\n<span class=\"c1\"># feed_excluded_link.yaml</span>\n<span class=\"pi\">-</span> <span class=\"s\">anti-ski.example.com</span>\n<span class=\"pi\">-</span> <span class=\"s\">awesome-snowboard.example.com</span>\n\n<span class=\"c1\"># feed_excluded_title.yaml</span>\n<span class=\"pi\">-</span> <span class=\"s\">queer</span>\n<span class=\"pi\">-</span> <span class=\"s\">two-planker</span>\n<span class=\"pi\">-</span> <span class=\"s\">beaver-tail</span>\n\n<span class=\"c1\"># feed_corrected_link.yaml</span>\n<span class=\"s\">amazon.com</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">ref</span>\n  <span class=\"pi\">-</span> <span class=\"s\">ie</span>\n\n<span class=\"c1\"># feed_redirected_link.yaml</span>\n<span class=\"s\">ski-status.example.com</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">Floki.find(fst, \".post__body a\")</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"61:1-61:33\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"Elixirによる非同期処理\" name=\"Elixir%E3%81%AB%E3%82%88%E3%82%8B%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86\" href=\"#Elixir%E3%81%AB%E3%82%88%E3%82%8B%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Elixirによる非同期処理\"> &gt; Elixirによる非同期処理</span></a>Elixirによる非同期処理</h2>\n<h3 data-sourcepos=\"62:1-62:27\" id=\"2-2-1\" name=\"2-2-1\">\n<a class=\"anchor\" id=\"監視機構 Supervisor\" name=\"%E7%9B%A3%E8%A6%96%E6%A9%9F%E6%A7%8B%20Supervisor\" href=\"#%E7%9B%A3%E8%A6%96%E6%A9%9F%E6%A7%8B%20Supervisor\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"監視機構 Supervisor\"> &gt; 監視機構 Supervisor</span></a>監視機構 Supervisor</h3>\n<p data-sourcepos=\"64:1-64:414\">Elixirには監視機構があり、それが各ワーカーを子プロセスとして管理している。ここではフィード読込とブクマは別々のワーカーで処理しているが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ <code>one_for_all</code> ）にしてある。</p>\n<p data-sourcepos=\"66:1-66:194\">下記のように <code>Supervisor.start_link</code> を <code>Keshikimi2.Application.start</code> に適用すると、アプリケーション開始（ <code>mix run</code> ）した時点で監視機構が起動される。</p>\n<div class=\"code-block\" data-sourcepos=\"68:1-89:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ex</div>\n<div class=\"highlight\"><pre class=\"highlight elixir\"><code><span class=\"no\">Supervisor</span><span class=\"o\">.</span><span class=\"n\">start_link</span><span class=\"p\">(</span>\n  <span class=\"p\">[</span>\n    <span class=\"ss\">:hackney_pool</span><span class=\"o\">.</span><span class=\"n\">child_spec</span><span class=\"p\">(</span><span class=\"ss\">:hatena_bookmark_pool</span><span class=\"p\">,</span> <span class=\"ss\">timeout:</span> <span class=\"mi\">15_000</span><span class=\"p\">,</span> <span class=\"ss\">max_connections:</span> <span class=\"mi\">100</span><span class=\"p\">),</span>\n    <span class=\"c1\"># @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Cachex</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"ss\">:feed</span><span class=\"p\">,</span> <span class=\"p\">[]]),</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Registry</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n\n    <span class=\"c1\"># フィード読込処理 (PubSub)</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Subscriber</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Worker</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Publisher</span><span class=\"p\">,</span> <span class=\"p\">[[</span><span class=\"ss\">prefix:</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"ss\">poll_interval:</span> <span class=\"mi\">3_000</span><span class=\"p\">]]),</span>\n\n    <span class=\"c1\"># ブクマ処理</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2</span><span class=\"o\">.</span><span class=\"no\">HatenaBookmark</span><span class=\"o\">.</span><span class=\"no\">AddEntry</span><span class=\"p\">,</span> <span class=\"p\">[</span>\n      <span class=\"p\">[</span><span class=\"ss\">prefix:</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"ss\">poll_interval:</span> <span class=\"mi\">3_000</span><span class=\"p\">]</span>\n    <span class=\"p\">])</span>\n  <span class=\"p\">],</span>\n  <span class=\"ss\">strategy:</span> <span class=\"ss\">:one_for_all</span><span class=\"p\">,</span>\n  <span class=\"ss\">name:</span> <span class=\"n\">name</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"91:1-91:37\" id=\"2-2-2\" name=\"2-2-2\">\n<a class=\"anchor\" id=\"非同期処理 Task.async_stream\" name=\"%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%20Task.async_stream\" href=\"#%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%20Task.async_stream\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"非同期処理 Task.async_stream\"> &gt; 非同期処理 Task.async_stream</span></a>非同期処理 Task.async_stream</h3>\n<p data-sourcepos=\"93:1-93:429\">配列を引き回すリクエスト処理は <code>Task.async_stream</code> がうってつけである。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいる。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができる。</p>\n<div class=\"code-block\" data-sourcepos=\"95:1-137:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ex</div>\n<div class=\"highlight\"><pre class=\"highlight elixir\"><code><span class=\"no\">Cachex</span><span class=\"o\">.</span><span class=\"n\">keys!</span><span class=\"p\">(</span><span class=\"ss\">:feed</span><span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Enum</span><span class=\"o\">.</span><span class=\"n\">reject</span><span class=\"p\">(</span><span class=\"k\">fn</span> <span class=\"n\">key</span> <span class=\"o\">-&gt;</span>\n  <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"p\">[</span>\n    <span class=\"s2\">\"excluded_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"excluded_titles\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"corrected_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"redirected_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"feed_group\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"archived_links\"</span>\n  <span class=\"p\">]</span>\n<span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Task</span><span class=\"o\">.</span><span class=\"n\">async_stream</span><span class=\"p\">(</span>\n  <span class=\"k\">fn</span> <span class=\"n\">item_link</span> <span class=\"o\">-&gt;</span>\n    <span class=\"n\">with</span> <span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">item_title</span><span class=\"p\">,</span> <span class=\"n\">feed_tags</span><span class=\"p\">]}</span> <span class=\"o\">&lt;-</span> <span class=\"no\">Cachex</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"ss\">:feed</span><span class=\"p\">,</span> <span class=\"n\">item_link</span><span class=\"p\">),</span>\n         <span class=\"ss\">:ok</span> <span class=\"o\">&lt;-</span> <span class=\"n\">validate_all</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">,</span> <span class=\"n\">item_title</span><span class=\"p\">),</span>\n         <span class=\"n\">corrected_link</span> <span class=\"o\">&lt;-</span> <span class=\"n\">correct_all</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">),</span>\n         <span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span> <span class=\"n\">payload</span><span class=\"p\">}</span> <span class=\"o\">&lt;-</span>\n           <span class=\"no\">FormData</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span>\n             <span class=\"p\">%{</span>\n               <span class=\"ss\">url:</span> <span class=\"n\">corrected_link</span><span class=\"p\">,</span>\n               <span class=\"ss\">comment:</span> <span class=\"n\">feed_tags</span> <span class=\"o\">|&gt;</span> <span class=\"no\">Enum</span><span class=\"o\">.</span><span class=\"n\">map_join</span><span class=\"p\">(</span><span class=\"k\">fn</span> <span class=\"n\">tag</span> <span class=\"o\">-&gt;</span> <span class=\"s2\">\"[</span><span class=\"si\">#{</span><span class=\"n\">tag</span><span class=\"si\">}</span><span class=\"s2\">]\"</span> <span class=\"k\">end</span><span class=\"p\">),</span>\n               <span class=\"ss\">rks:</span> <span class=\"no\">System</span><span class=\"o\">.</span><span class=\"n\">get_env</span><span class=\"p\">(</span><span class=\"s2\">\"HATENA_BOOKMARK_RKS\"</span><span class=\"p\">),</span>\n               <span class=\"ss\">private:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n               <span class=\"ss\">keep_original_url:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n               <span class=\"ss\">with_status_op:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n               <span class=\"ss\">from:</span> <span class=\"s2\">\"inplace\"</span><span class=\"p\">,</span>\n               <span class=\"ss\">post_twitter:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n               <span class=\"ss\">post_evernote:</span> <span class=\"mi\">0</span>\n             <span class=\"p\">},</span>\n             <span class=\"ss\">:url_encoded</span><span class=\"p\">,</span>\n             <span class=\"ss\">get:</span> <span class=\"no\">false</span>\n           <span class=\"p\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">do_add_entries_to_hb</span><span class=\"p\">(</span><span class=\"n\">payload</span><span class=\"p\">)</span>\n      <span class=\"no\">Logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s2\">\"add entry: </span><span class=\"si\">#{</span><span class=\"n\">item_link</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"n\">archive_link</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span><span class=\"p\">,</span>\n  <span class=\"ss\">timeout:</span> <span class=\"mi\">15_000</span>\n<span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Stream</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"139:1-139:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<h2 data-sourcepos=\"140:1-140:57\" id=\"3-1-0\" name=\"3-1-0\">\n<a class=\"anchor\" id=\"これからのはてなブックマークの使い方\" name=\"%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E3%81%AE%E3%81%AF%E3%81%A6%E3%81%AA%E3%83%96%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%AF%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9\" href=\"#%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E3%81%AE%E3%81%AF%E3%81%A6%E3%81%AA%E3%83%96%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%AF%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9\" data-position=\"3-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"これからのはてなブックマークの使い方\"> &gt; これからのはてなブックマークの使い方</span></a>これからのはてなブックマークの使い方</h2>\n<ul data-sourcepos=\"142:1-144:197\">\n<li data-sourcepos=\"142:1-142:65\">\n<strong>手動でブクマ:</strong> 気になった記事があるごとに</li>\n<li data-sourcepos=\"143:1-144:197\">\n<strong>ブクマの確認:</strong> 気になるタグごとにまとめて確認\n<ul data-sourcepos=\"144:5-144:197\">\n<li data-sourcepos=\"144:5-144:197\">たとえば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「<a href=\"http://b.hatena.ne.jp/nabinno/github\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/github</a>」をみる、という感じ。</li>\n</ul>\n</li>\n</ul>\n","tags":["elixir","hatena-bookmark"],"updated_at":"2021-01-11T12:45:08+09:00","childPublishedDate":{"published_on":"2019-01-01T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":67,"relative_category":"blog/frontend","fields":{"title":"esaをHeadless CMSとして使う","excerpt":"最近仕事の同僚からHeadless CMS という言葉を聞いていて「自分には関係ないな」と距離を取っていたのですが、なぜか回り回って自分からHeadless CMSを作ることになりました。世の中何が起きるか分からないですね。   > PROBLEMPROBLEM \n\n- ブログを普段書かない人なのだが、よそ向けに情報発信する必要が出てきた とは言っても、今までMarkdownをJekyllで管理していたので画像を貼り付けるのが手間でモチベーションが大きく下がっていた さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった \n- とは言っても、今までMarkdownをJekyllで管理していたので画像を貼り付けるのが手間でモチベーションが大きく下がっていた さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった \n- さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった   > SOLUTIONSOLUTION \n\nというわけで、esaをHeadless CMSとして使うことにしました。 \n\nやってることは昔のMovableTypeそのもので懐かしかったです。コンテンツを別システムで管理しビルドサーバーに当該コンテンツを流し込みリビルド、最後にホストサーバーにアップロードというワークフロー。今はJAMStackの文脈で語られているようです。 \n\nこのHeadless CMSが昔と違うのはコンテンツ作成に集中できること。CI周りが発達したので一度ワークフローを組み立てれば後は自動でコンテンツを生成できます。   > やり方やり方 \n\n- esa.io でゆるふわ情報共有 - Middleman Blog への Export サンプル付き #esa_io - Qiita\n- 技術ブログを支える技術（Gatsby + esaio） - mottox2 blog\n- Next.jsとesaを使った個人サイト構築 | corocn.dev \n\nそれほど時間をかけられなかったので、上記3記事の中で手軽さを考慮しmottox2さんのソースコードを拝借しました。ありがとうございます。 \n\n- 作ったレポジトリ：nabinno/nabinno.github.io: On Blahfe - Nab's Github Pages    > シークエンス図シークエンス図 \n\n私が手を入れたのはコンポーネントを削りGatsby Blog Starterに寄せたのと、デプロイ方法を使い慣れたCircleCIに変えたくらいです。 \n\nGitHub PagesにはVercelのような便利なWebhookがないので、esaで実装されたGitHub Webhook連携を使いそれをトリガーにCircleCIジョブを走らせています。 \n\n   > CircleCIジョブCircleCIジョブ \n\nまた、CircleCIジョブは何の変哲もないもので、NodeJSを叩いてGitプッシュしているくらいです。先ほどのGitHub Webhookと似た感じの泥臭いワークフローは [skip ci] コメントの追加があります。当該コメントを入れないとジョブが再帰的に走り続けるので出口で明示してあります。   yml \n\nversion: 2.1 jobs: build_deploy: docker: - image: circleci/node:12.4 steps: - checkout - run: name: Install NPM command: npm install - run: name: Build command: npm run clean && npm run build - add_ssh_keys: fingerprints: - \"{foo}\" - deploy: name: Deploy command: | git config --global user.email \"nab+circleci@blahfe.com\" git config --global user.name \"nabinno+circleci\" git add . git commit -m \"[skip ci]Run npm run clean && npm run build.\" git push origin master workflows: build_deploy: jobs: - build_deploy: filters: branches: only: master     > WRAPUPWRAPUP \n\nとまあ大した作業内容ではないのですが、久しぶりに昔懐かしのMovableTypeのリビルドを思い出しつつ、副産物として全く縁遠かったNetlifyとVercelの位置づけを薄らと感じ取れました。"},"name":"[2021-01-18]esaをHeadless CMSとして使う","tags":["gatsby","esa","headless-cms","cms"],"childPublishedDate":{"published_on":"2021-01-18T00:00:00.000Z","published_on_unix":1610928000}}},{"node":{"number":64,"relative_category":"blog/backend","fields":{"title":"WSL2時代のDocker開発スタイル","excerpt":"> PROBLEMPROBLEM \n\n- あたらしくでたWSL2によって以前書いた記事からだいぶ状況が変わった 主な変更点 WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- 主な変更点 WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- WSLのアーキテクチャが2種類になり、WSLはその2つのアーキテクチャを管理する機能に変わった WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss) WSL2 軽量Hyper-V上のLinux (Linux Kernel) \n- WSL1 Windows Subsystem for Linux上のLinux (LXCore/Lxss)\n- WSL2 軽量Hyper-V上のLinux (Linux Kernel)\n- /procや/sysなどの特殊ファイルもふくめた共有プロトコル「9P」が実装された Win32側の9Pクライアント 9prdr.sys WSL側の9Pクライアント /init \n- Win32側の9Pクライアント 9prdr.sys \n- WSL側の9Pクライアント /init    > SOLUTIONSOLUTION \n\nというわけで、前記事で掲げていた目標「WSLでDockerをつかったWebアプリケーション開発ができるかどうか」について再確認します。   > 対象環境対象環境 \n\n- Windows 10 Pro Version 1903 OS Build 18922.1000 Windows Terminal (Preview) Version 0.2.1715.0 WSL2 Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard) Docker version 19.03.0-rc3, build 27fcb77 WSL1 Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft) \n- Windows Terminal (Preview) Version 0.2.1715.0\n- WSL2 Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard) Docker version 19.03.0-rc3, build 27fcb77 \n- Ubuntu Version 1804.2019.5210 (Linux 4.19.43-microsoft-standard)\n- Docker version 19.03.0-rc3, build 27fcb77\n- WSL1 Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft) \n- Ubuntu 18.04 LTS Version 1804.2019.522.0 (Linux 4.4.0-18922-Microsoft)   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- WSL2を使ってみる (InsiderPreview) \n\nWSLのパッケージ管理は下記2つを押さえておけば問題ないでしょう。 \n\n1. asdf/anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう 関数言語界隈ではasdfが主流になってきてるようです。 \n2. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n3. 関数言語界隈ではasdfが主流になってきてるようです。\n4. nix Haskellのようにasdf/anyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n5. Haskellのようにasdf/anyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n6. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyはWSL2に対応しておらずConEmuは描画がくずれやすいため、デフォルトのターミナルかWindows Terminalが選択肢となります。 \n\nWindows TerminalとConEmuとの比較    - Windows Terminal ConEmu     透過対象 backgroundImage ConEmu自体   キーバインド制約 Alt+Shiftが効かない 特になし   WSL2の描画 特になし くずれる   管理者権限で実行 初回のみ タスク実行ごと      > DockerのインストールDockerのインストール \n\nWSL1ではDockerデーモンがつかえないのでWSL2でDockerをつかうようにしましょう。Docker CEをインストールします。 \n\nどうしてもWSL1でということであれば、Win32 (WSL1からみるとdrvfs) 側でDocker For Windowsを用意します。インストールはDockerのダウンロードページから手順通りおこないます。\n 構成等は前回の記事を参照ください。   > さて、WSL2からDockerはどの程度つかえるのかさて、WSL2からDockerはどの程度つかえるのか \n\nWSL2は軽量Hyper-V上にLinuxコンテナを動かしているので、基本Hyper-Vと同様にDockerをつかうことができます。 \n\nただし、WSL1と違いlocalhostにWSL2がバインドできません (2019-07-27追記: Build Version 18945で解決しました )。\n また、WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています。 \n\nひとつずつ解決方法を見ていきましょう。   > 1. WSL1と違いlocalhostにWSL2がバインドできません1. WSL1と違いlocalhostにWSL2がバインドできません \n\nWSL2がつかっているVirtual Switchはinternal onlyのため、Win32側からlocalhostをつかってWSL2にアクセスすることができません。現在対応中のようです (2019-07-27追記: Build Version 18945で解決しました )。 \n\n対処方法は2つあります。 \n\na. WSL1をつかう \n\nこれが一番楽ですが、WSL1は次項であげるパフォーマンス上の欠点があるので、Web系フロントエンド開発におけるライブリローディング機能をつかうケースに限定するといいでしょう。 \n\nb. Hostsファイルをつかう \n\nWin32のHostsファイルでWSL2のeth0インターフェイスのIPアドレスに適当なホスト名を割り当てます（ポートごとにホストを振り分けたい場合はWSL2側にProxyを用意するといいでしょう）。   shell \n\n# C:\\Windows\\System32\\drivers\\etc\\hosts 172.17.72.217 dashboard.local.me   \n\nWSL2のIPアドレスはコンテナを立ち上げるごとに変わるので、下記のようなコマンドレットをWin32側のPowerShell $PROFILEに用意しておくといいでしょう。WSL2だけで完結したい方はシェル上から powershell.exe -Command 'Sync-HostsToWslIp' と打つだけです。   powershell \n\n# $PROFILE function Sync-HostsToWslIp { $hosts = \"$env:SystemRoot\\System32\\drivers\\etc\\hosts\"; $pattern = \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"; $wslip = bash.exe -c \"ifconfig eth0 | grep 'inet '\"; if ($wslip -match $pattern) { $wslip = $matches[0]; } else { echo \"The Script Exited, the ip address of WSL 2 cannot be found\"; exit; } cat $hosts | %{ $_ -match $pattern } $rc = cat $hosts | %{ $_ -replace $matches[0], $wslip } $rc | Out-File $hosts; }     > 2. WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています2. WSL1と同様にWin32・WSL間でのファイルの読み書きにパフォーマンスの差が大きく出ています \n\nいろんな方がベンチマークを公開してるのでそれを参考にするといいでしょう。 \n\nCf. \n\n- Pythonでファイル操作のベンチマーク\n- dd、git cloneのベンチマーク \n\nわたしは git status -sb をよくつかうので、そのコマンドで簡単なベンチマークとりました。   shell \n\n# WSLx $ cd ~/nabinno.github.io $ \\time -f %e git status -sb # Win32/WSLx $ cd ~/nabinno.github.io $ \\time -f %e powershell.exe -Command 'git status -sb' # Win32 PS> cd ~/nabinno.github.io PS> (Measure-Command { git status -sb }).TotalMilliseconds / 1000 | %{ [math]::Round($_, 2) }      Subject WSL Win32     WSL1 0.47 0.09   WSL2 0.00 0.61   Win32/WSL1 2.66 1.91   Win32/WSL2 2.81 1.79   Win32 0.51 0.12      > Docker以外でWSLの課題はないのかDocker以外でWSLの課題はないのか   > デバイスへのアクセスデバイスへのアクセス \n\n以前から要望があったものだと「デバイスアクセスができない」件があります。 \n\n9P導入前だとこれはElixirのIoTフレームワークNervesのように、WSL UtilitiesでWSLパスをWin32パスに変換してからWin32にあるデバイス関連ツールをつかうのが簡単な解決策でした。   sh \n\n$ fwup.exe -a -i $(wslpath -w -a _build/rpi0_dev/nerves/images/hello_nerves.fw) -t complete -d $(fwup.exe -D | sed 's/,.*//')   \n\nただし9Pを導入したWindows 10 Version 1903以降は、WSL1もWSL2もともにWSLパスを変換せずにWin32にあるデバイス関連ツールをつかうことができます。   sh \n\n$ fwup.exe -a -i _build/rpi0_dev/nerves/images/hello_nerves.fw -t complete -d $(fwup.exe -D | sed 's/,.*//')     > WRAPUPWRAPUP \n\nわたしの観測範囲では課題はほぼ問題ない状態になっていました。 \n\nおすすめ開発環境は下記のとおり    item content     IDE WSLx上のエディタ   Webフロントエンド開発 WSL1   Docker関連開発 WSL2   dotfiles WSLx、Win32を共有管理    \n\nWin32側のIDEをつかっているユーザーはパフォーマンス上の不満がまだあるかもしれませんが、WSLでDockerをつかったWebアプリケーション開発は十分できる、と言えそうです。つまり、Linux・macOS・WindowsによるWebアプリケーション開発は十分共有できる、と。 \n\nいい時代になりました。"},"name":"[2019-07-06]WSL2時代のDocker開発スタイル","tags":["wsl","wsl2","ubuntu"],"childPublishedDate":{"published_on":"2019-07-06T00:00:00.000Z","published_on_unix":1562371200}}},{"node":{"number":61,"relative_category":"blog/health","fields":{"title":"ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","excerpt":"> PROBLEMPROBLEM \n\n- 以前からオフィスに行くと目や喉が痛くなることがあったので、自分の体調なのか環境なのか原因を切り分けるために汚染計測器「Dienmern DM106A」を購入 ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる \n- ただ、DM106Aの計測はその時その時のスナップショットなので傾向を読み解きづらい、また、都度実施する手間がかかる   > SOLUTIONSOLUTION \n\nというわけで、DM106AのセンサーデータをRaspberry Piで定期取得することにした。設置方法の詳細はGitHubレポジトリを参照。下記は実装概要。   > 電子部品の構成電子部品の構成    item description     Raspberry Pi 3 Model B+    Aosong DHT11 気温・湿度センサー、GPIO   Nova SDS021 PM2.5・PM10センサー、UART   ams CCS811 TVOC・CO2eセンサー、I2C    \n\n電子工作は素人ゆえどのセンサーを買えばいいかわからなかったのでDM106Aを分解して各センサーの型番をしらべた。DHT011、SDS021はDM106Aとおなじセンサー、HCHOセンサーは信頼性があり手ごろなのがうまく見つけられなかった。TVOCセンサーはAdafruitが推しているCCS811を採用した。   > コードの構成コードの構成    item description     AirElixir.Application アプリケーション管理   AirElixir.GoogleSpreadsheets センサーデータ記録   AirElixirSensor.Publisher センサーデータ発行・送信   AirElixirSensor.Subscriber センサーデータ購読・受信    \n\n基本構成はGrovePiを参考にした。発行処理はElixirでうまくいかないケースがあったのでまずはPython/ErlPortでおこなった。後々Elixirに移行できるようにマクロにしてある。   > 5日ほど稼働してわかったこと・見立て、今後の課題5日ほど稼働してわかったこと・見立て、今後の課題  \n\n- オフィスの空気清浄機「Hitachi EP-LVG110」はPMをきちんとフィルターしていた ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている \n- ただし、空気清浄機はTVOCには効果がなく、これはTroia氏や加藤氏・苅部氏の考察でも言及されている\n- 人の入りが多い時間帯に空気（TVOCやCO2e）がよごれる 人が「出る」ときよりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察 \n- 人が「出る」ときよりも「入る」際に濃度があがるのは、外のVOCが服などに付着しているためと推察\n- TVOCやCO2eはPMのうごきに連動している（かも） チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n- チャート上はEP-LVG110がPM除去しているためわからないが、日本気象協会のPM2.5分布予測に照らしてみるとPM濃度が高い日にTVOC濃度があがっていた TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ \n- TODO: PMがVOCを運んでいる可能性があるので、IQAirなどのAPIから周辺環境のPMデータも取得したいところ\n- TVOCの変動が大きすぎる ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均 \n- ポーリング・出力を20分ごとからポーリング3秒ごと・出力20分ごとに変更した、出力データは20分の平均\n- TVOCのスパイクを抑えたい TODO: ファイトレメディエーションによる効果を見ていきたいところ \n- TODO: ファイトレメディエーションによる効果を見ていきたいところ   > WRAPUPWRAPUP \n\nElixirは健康管理に向いている。   txt \n\n「なんか体調がすぐれないなあ...」 「Elixirちょうだい!」   \n\nという感じ。"},"name":"[2018-12-22]ElixirとRaspberry PiでPM2.5などの環境データを定点観察し、目・喉の痛みに備える","tags":["elixir","raspberry-pi","particulates","physiology"],"childPublishedDate":{"published_on":"2018-12-22T00:00:00.000Z","published_on_unix":1545436800}}}]}},"pageContext":{"number":62}},"staticQueryHashes":[]}