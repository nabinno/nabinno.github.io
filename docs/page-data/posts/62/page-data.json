{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/62","result":{"data":{"esaPost":{"number":62,"relative_category":"blog/backend","fields":{"title":"Elixirではてなブックマーク","excerpt":"紆余曲折合ってはてなブックマークの運用を見直す必要が出てきました。人の興味というのは尽きないもので知りたいことが次々出てきます。にも拘わらず人の時間は有限でそれにあがなうための手段を考えたわけです。   > PROBLEMPROBLEM \n\n- フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- あとで確認することができない\n- 読みたくない記事をブクマしてしまう\n- 適切でないURLでブクマしてしまう   > SOLUTIONSOLUTION \n\nというわけで、下記の方針でブクマすることにしました。設置方法の詳細はGitHubレポジトリを参照ください。そして、方針は下記の通りになります。 \n\n方針 \n\n- フィードごとにタグづけする\n- ブクマ対象になる記事をリンクとタイトルで除外判定する\n- ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する\n- 上記設定はYAMLファイルで簡単に管理できるようにする\n- フィード読込とブクマを非同期処理できるようElixirで実装する   > ブクマの管理方法ブクマの管理方法 \n\nまずブクマの管理ですが、下記5つのYAMLファイルで構成しています、構造はマップとリストのみ。ブクマしたいと思う記事を読みすすめる中で気になるキーワードが出てきたら都度 feed.yaml を更新します。また、記事にノイズが多いようだったら傾向を分析して除外ファイル feed_excluded_link.yaml feed_excluded_title.yaml を更新します。    item description     feed.yaml フィードグループ名に対するリンク、タグのマップ   feed_excluded_link.yaml 除外すべきフィードリンクのリスト   feed_excluded_title.yaml 除外すべきフィードタイトルのリスト   feed_corrected_link.yaml フィードリンクに対するトリミングすべきパラメータのマップ   feed_redirected_link.yaml フィードリンクに対するリダイレクト先リンクのマップ      yaml \n\n# feed.yaml nabinno/sports/feed_group_name: tags: - ski links: - http://rss.example.com/ski_feed.rss - http://rss.example.com/snowboard_feed.rss - http://ski-status.example.com/rss # feed_excluded_link.yaml - anti-ski.example.com - awesome-snowboard.example.com # feed_excluded_title.yaml - queer - two-planker - beaver-tail # feed_corrected_link.yaml amazon.com: - ref - ie # feed_redirected_link.yaml ski-status.example.com: - Floki.find(fst, \".post__body a\")     > Elixirによる非同期処理Elixirによる非同期処理 \n\nElixirで非同期処理を行っているのですが、大きく分けて監視機構のSupervisorと非同期処理のTask.async_streamを使っています。   > 監視機構 Supervisor監視機構 Supervisor \n\nまず、Supervisor。Elixirには監視機構Supervisorがあり、それが各ワーカーを子プロセスとして管理しています。ここではフィード読込とブクマは別々のワーカーで処理しますが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ one_for_all ）にしてあります。再起動戦略の詳細は「OTPスーパバイザ · Elixir School」を参照下さい。 \n\n下記のように Supervisor.start_link を Keshikimi2.Application.start に適用すると、アプリケーション開始（ mix run ）した時点で監視機構が起動されます。   ex \n\nSupervisor.start_link( [ :hackney_pool.child_spec(:hatena_bookmark_pool, timeout: 15_000, max_connections: 100), # @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する supervisor(Cachex, [:feed, []]), supervisor(Keshikimi2Feed.Registry, [prefix]), # フィード読込処理 (PubSub) supervisor(Keshikimi2Feed.Subscriber, [prefix]), worker(Keshikimi2Feed.Worker, [prefix]), worker(Keshikimi2Feed.Publisher, [[prefix: prefix, poll_interval: 3_000]]), # ブクマ処理 worker(Keshikimi2.HatenaBookmark.AddEntry, [ [prefix: prefix, poll_interval: 3_000] ]) ], strategy: :one_for_all, name: name(prefix) )     > 非同期処理 Task.async_stream非同期処理 Task.async_stream \n\n次に、Task.async_stream。配列を引き回すリクエスト処理は Task.async_stream がうってつけです。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいます。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができます。   ex \n\nCachex.keys!(:feed) |> Enum.reject(fn key -> key in [ \"excluded_links\", \"excluded_titles\", \"corrected_links\", \"redirected_links\", \"feed_group\", \"archived_links\" ] end) |> Task.async_stream( fn item_link -> with {:ok, [item_title, feed_tags]} <- Cachex.get(:feed, item_link), :ok <- validate_all(item_link, item_title), corrected_link <- correct_all(item_link), {:ok, payload} <- FormData.create( %{ url: corrected_link, comment: feed_tags |> Enum.map_join(fn tag -> \"[#{tag}]\" end), rks: System.get_env(\"HATENA_BOOKMARK_RKS\"), private: 0, keep_original_url: 1, with_status_op: 1, from: \"inplace\", post_twitter: 0, post_evernote: 0 }, :url_encoded, get: false ) do do_add_entries_to_hb(payload) Logger.info(\"add entry: #{item_link}\") end archive_link(item_link) end, timeout: 15_000 ) |> Stream.run()     > WRAPUPWRAPUP \n\nElixirの非同期処理を使うことではてなブックマークの運用がとても快適になりました。はてなブックマークとの今後の付き合い方は下記のように考えています。 \n\n- 手動でブクマ: 気になった記事があるごとに\n- ブクマの確認: 気になるタグごとにまとめて確認 \n\nブクマの確認については、例えば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「nabinno/github」をみる、という感じの運用です。 \n\n融通が利かない点で途中運用が難しくなる気もしますが、しばらく回してみます。","thumbnail":"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png"},"wip":false,"body_md":"<img alt=thumbnail src=https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png />\r\n\r\n紆余曲折合ってはてなブックマークの運用を見直す必要が出てきました。人の興味というのは尽きないもので知りたいことが次々出てきます。にも拘わらず人の時間は有限でそれにあがなうための手段を考えたわけです。\r\n\r\n# PROBLEM\r\n- フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる\r\n    - フィードをそのままブクマしていると下記の問題がでてくる\r\n        - あとで確認することができない\r\n        - 読みたくない記事をブクマしてしまう\r\n        - 適切でないURLでブクマしてしまう\r\n\r\n# SOLUTION\r\nというわけで、下記の方針でブクマすることにしました。設置方法の詳細は[GitHubレポジトリ](https://github.com/nabinno/keshikimi2)を参照ください。そして、方針は下記の通りになります。\r\n\r\n**方針**\r\n\r\n- フィードごとにタグづけする\r\n- ブクマ対象になる記事をリンクとタイトルで除外判定する\r\n- ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する\r\n- 上記設定はYAMLファイルで簡単に管理できるようにする\r\n- フィード読込とブクマを非同期処理できるようElixirで実装する\r\n\r\n## ブクマの管理方法\r\nまずブクマの管理ですが、下記5つのYAMLファイルで構成しています、構造はマップとリストのみ。ブクマしたいと思う記事を読みすすめる中で気になるキーワードが出てきたら都度 `feed.yaml` を更新します。また、記事にノイズが多いようだったら傾向を分析して除外ファイル `feed_excluded_link.yaml` `feed_excluded_title.yaml` を更新します。\r\n\r\n| item                        | description                                              |\r\n|-----------------------------|----------------------------------------------------------|\r\n| `feed.yaml`                 | フィードグループ名に対するリンク、タグのマップ           |\r\n| `feed_excluded_link.yaml`   | 除外すべきフィードリンクのリスト                         |\r\n| `feed_excluded_title.yaml`  | 除外すべきフィードタイトルのリスト                       |\r\n| `feed_corrected_link.yaml`  | フィードリンクに対するトリミングすべきパラメータのマップ |\r\n| `feed_redirected_link.yaml` | フィードリンクに対するリダイレクト先リンクのマップ       |\r\n\r\n```yaml\r\n# feed.yaml\r\nnabinno/sports/feed_group_name:\r\n  tags:\r\n    - ski\r\n  links:\r\n    - http://rss.example.com/ski_feed.rss\r\n    - http://rss.example.com/snowboard_feed.rss\r\n    - http://ski-status.example.com/rss\r\n\r\n# feed_excluded_link.yaml\r\n- anti-ski.example.com\r\n- awesome-snowboard.example.com\r\n\r\n# feed_excluded_title.yaml\r\n- queer\r\n- two-planker\r\n- beaver-tail\r\n\r\n# feed_corrected_link.yaml\r\namazon.com:\r\n  - ref\r\n  - ie\r\n\r\n# feed_redirected_link.yaml\r\nski-status.example.com:\r\n  - Floki.find(fst, \".post__body a\")\r\n```\r\n\r\n## Elixirによる非同期処理\r\nElixirで非同期処理を行っているのですが、大きく分けて監視機構のSupervisorと非同期処理のTask.async_streamを使っています。\r\n\r\n### 監視機構 Supervisor\r\nまず、Supervisor。Elixirには監視機構Supervisorがあり、それが各ワーカーを子プロセスとして管理しています。ここではフィード読込とブクマは別々のワーカーで処理しますが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ `one_for_all` ）にしてあります。再起動戦略の詳細は「[OTPスーパバイザ · Elixir School](https://elixirschool.com/ja/lessons/advanced/otp-supervisors/)」を参照下さい。\r\n\r\n下記のように `Supervisor.start_link` を `Keshikimi2.Application.start` に適用すると、アプリケーション開始（ `mix run` ）した時点で監視機構が起動されます。\r\n\r\n```ex\r\nSupervisor.start_link(\r\n  [\r\n    :hackney_pool.child_spec(:hatena_bookmark_pool, timeout: 15_000, max_connections: 100),\r\n    # @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する\r\n    supervisor(Cachex, [:feed, []]),\r\n    supervisor(Keshikimi2Feed.Registry, [prefix]),\r\n\r\n    # フィード読込処理 (PubSub)\r\n    supervisor(Keshikimi2Feed.Subscriber, [prefix]),\r\n    worker(Keshikimi2Feed.Worker, [prefix]),\r\n    worker(Keshikimi2Feed.Publisher, [[prefix: prefix, poll_interval: 3_000]]),\r\n\r\n    # ブクマ処理\r\n    worker(Keshikimi2.HatenaBookmark.AddEntry, [\r\n      [prefix: prefix, poll_interval: 3_000]\r\n    ])\r\n  ],\r\n  strategy: :one_for_all,\r\n  name: name(prefix)\r\n)\r\n```\r\n\r\n### 非同期処理 Task.async_stream\r\n次に、Task.async_stream。配列を引き回すリクエスト処理は `Task.async_stream` がうってつけです。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいます。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができます。\r\n\r\n```ex\r\nCachex.keys!(:feed)\r\n|> Enum.reject(fn key ->\r\n  key in [\r\n    \"excluded_links\",\r\n    \"excluded_titles\",\r\n    \"corrected_links\",\r\n    \"redirected_links\",\r\n    \"feed_group\",\r\n    \"archived_links\"\r\n  ]\r\nend)\r\n|> Task.async_stream(\r\n  fn item_link ->\r\n    with {:ok, [item_title, feed_tags]} <- Cachex.get(:feed, item_link),\r\n         :ok <- validate_all(item_link, item_title),\r\n         corrected_link <- correct_all(item_link),\r\n         {:ok, payload} <-\r\n           FormData.create(\r\n             %{\r\n               url: corrected_link,\r\n               comment: feed_tags |> Enum.map_join(fn tag -> \"[#{tag}]\" end),\r\n               rks: System.get_env(\"HATENA_BOOKMARK_RKS\"),\r\n               private: 0,\r\n               keep_original_url: 1,\r\n               with_status_op: 1,\r\n               from: \"inplace\",\r\n               post_twitter: 0,\r\n               post_evernote: 0\r\n             },\r\n             :url_encoded,\r\n             get: false\r\n           ) do\r\n      do_add_entries_to_hb(payload)\r\n      Logger.info(\"add entry: #{item_link}\")\r\n    end\r\n\r\n    archive_link(item_link)\r\n  end,\r\n  timeout: 15_000\r\n)\r\n|> Stream.run()\r\n```\r\n\r\n# WRAPUP\r\nElixirの非同期処理を使うことではてなブックマークの運用がとても快適になりました。はてなブックマークとの今後の付き合い方は下記のように考えています。\r\n\r\n- **手動でブクマ:** 気になった記事があるごとに\r\n- **ブクマの確認:** 気になるタグごとにまとめて確認\r\n\r\nブクマの確認については、例えば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「[nabinno/github](http://b.hatena.ne.jp/nabinno/github)」をみる、という感じの運用です。\r\n\r\n融通が利かない点で途中運用が難しくなる気もしますが、しばらく回してみます。\r\n","body_html":"<a href=\"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"thumbnail\" src=\"https://raw.githubusercontent.com/nabinno/keshikimi2/master/priv/img/diagram.png\"></a>\n<p data-sourcepos=\"3:1-3:297\">紆余曲折合ってはてなブックマークの運用を見直す必要が出てきました。人の興味というのは尽きないもので知りたいことが次々出てきます。にも拘わらず人の時間は有限でそれにあがなうための手段を考えたわけです。</p>\n<h1 data-sourcepos=\"5:1-5:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"6:1-11:0\">\n<li data-sourcepos=\"6:1-11:0\">フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる\n<ul data-sourcepos=\"7:5-11:0\">\n<li data-sourcepos=\"7:5-11:0\">フィードをそのままブクマしていると下記の問題がでてくる\n<ul data-sourcepos=\"8:9-11:0\">\n<li data-sourcepos=\"8:9-8:52\">あとで確認することができない</li>\n<li data-sourcepos=\"9:9-9:61\">読みたくない記事をブクマしてしまう</li>\n<li data-sourcepos=\"10:9-11:0\">適切でないURLでブクマしてしまう</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"12:1-12:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"13:1-13:242\">というわけで、下記の方針でブクマすることにしました。設置方法の詳細は<a href=\"https://github.com/nabinno/keshikimi2\" target=\"_blank\" rel=\"noopener noreferrer\">GitHubレポジトリ</a>を参照ください。そして、方針は下記の通りになります。</p>\n<p data-sourcepos=\"15:1-15:10\"><strong>方針</strong></p>\n<ul data-sourcepos=\"17:1-22:0\">\n<li data-sourcepos=\"17:1-17:41\">フィードごとにタグづけする</li>\n<li data-sourcepos=\"18:1-18:80\">ブクマ対象になる記事をリンクとタイトルで除外判定する</li>\n<li data-sourcepos=\"19:1-19:122\">ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する</li>\n<li data-sourcepos=\"20:1-20:75\">上記設定はYAMLファイルで簡単に管理できるようにする</li>\n<li data-sourcepos=\"21:1-22:0\">フィード読込とブクマを非同期処理できるようElixirで実装する</li>\n</ul>\n<h2 data-sourcepos=\"23:1-23:27\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"ブクマの管理方法\" name=\"%E3%83%96%E3%82%AF%E3%83%9E%E3%81%AE%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95\" href=\"#%E3%83%96%E3%82%AF%E3%83%9E%E3%81%AE%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"ブクマの管理方法\"> &gt; ブクマの管理方法</span></a>ブクマの管理方法</h2>\n<p data-sourcepos=\"24:1-24:444\">まずブクマの管理ですが、下記5つのYAMLファイルで構成しています、構造はマップとリストのみ。ブクマしたいと思う記事を読みすすめる中で気になるキーワードが出てきたら都度 <code>feed.yaml</code> を更新します。また、記事にノイズが多いようだったら傾向を分析して除外ファイル <code>feed_excluded_link.yaml</code> <code>feed_excluded_title.yaml</code> を更新します。</p>\n<table data-sourcepos=\"26:1-32:115\">\n<thead>\n<tr data-sourcepos=\"26:1-26:90\">\n<th data-sourcepos=\"26:2-26:30\">item</th>\n<th data-sourcepos=\"26:32-26:89\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"28:1-28:113\">\n<td data-sourcepos=\"28:2-28:30\"><code>feed.yaml</code></td>\n<td data-sourcepos=\"28:32-28:112\">フィードグループ名に対するリンク、タグのマップ</td>\n</tr>\n<tr data-sourcepos=\"29:1-29:106\">\n<td data-sourcepos=\"29:2-29:30\"><code>feed_excluded_link.yaml</code></td>\n<td data-sourcepos=\"29:32-29:105\">除外すべきフィードリンクのリスト</td>\n</tr>\n<tr data-sourcepos=\"30:1-30:107\">\n<td data-sourcepos=\"30:2-30:30\"><code>feed_excluded_title.yaml</code></td>\n<td data-sourcepos=\"30:32-30:106\">除外すべきフィードタイトルのリスト</td>\n</tr>\n<tr data-sourcepos=\"31:1-31:118\">\n<td data-sourcepos=\"31:2-31:30\"><code>feed_corrected_link.yaml</code></td>\n<td data-sourcepos=\"31:32-31:117\">フィードリンクに対するトリミングすべきパラメータのマップ</td>\n</tr>\n<tr data-sourcepos=\"32:1-32:115\">\n<td data-sourcepos=\"32:2-32:30\"><code>feed_redirected_link.yaml</code></td>\n<td data-sourcepos=\"32:32-32:114\">フィードリンクに対するリダイレクト先リンクのマップ</td>\n</tr>\n</tbody>\n</table>\n<div class=\"code-block\" data-sourcepos=\"34:1-61:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"c1\"># feed.yaml</span>\n<span class=\"s\">nabinno/sports/feed_group_name</span><span class=\"pi\">:</span>\n  <span class=\"na\">tags</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">ski</span>\n  <span class=\"na\">links</span><span class=\"pi\">:</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://rss.example.com/ski_feed.rss</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://rss.example.com/snowboard_feed.rss</span>\n    <span class=\"pi\">-</span> <span class=\"s\">http://ski-status.example.com/rss</span>\n\n<span class=\"c1\"># feed_excluded_link.yaml</span>\n<span class=\"pi\">-</span> <span class=\"s\">anti-ski.example.com</span>\n<span class=\"pi\">-</span> <span class=\"s\">awesome-snowboard.example.com</span>\n\n<span class=\"c1\"># feed_excluded_title.yaml</span>\n<span class=\"pi\">-</span> <span class=\"s\">queer</span>\n<span class=\"pi\">-</span> <span class=\"s\">two-planker</span>\n<span class=\"pi\">-</span> <span class=\"s\">beaver-tail</span>\n\n<span class=\"c1\"># feed_corrected_link.yaml</span>\n<span class=\"s\">amazon.com</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">ref</span>\n  <span class=\"pi\">-</span> <span class=\"s\">ie</span>\n\n<span class=\"c1\"># feed_redirected_link.yaml</span>\n<span class=\"s\">ski-status.example.com</span><span class=\"pi\">:</span>\n  <span class=\"pi\">-</span> <span class=\"s\">Floki.find(fst, \".post__body a\")</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"63:1-63:33\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"Elixirによる非同期処理\" name=\"Elixir%E3%81%AB%E3%82%88%E3%82%8B%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86\" href=\"#Elixir%E3%81%AB%E3%82%88%E3%82%8B%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Elixirによる非同期処理\"> &gt; Elixirによる非同期処理</span></a>Elixirによる非同期処理</h2>\n<p data-sourcepos=\"64:1-64:162\">Elixirで非同期処理を行っているのですが、大きく分けて監視機構のSupervisorと非同期処理のTask.async_streamを使っています。</p>\n<h3 data-sourcepos=\"66:1-66:27\" id=\"2-2-1\" name=\"2-2-1\">\n<a class=\"anchor\" id=\"監視機構 Supervisor\" name=\"%E7%9B%A3%E8%A6%96%E6%A9%9F%E6%A7%8B%20Supervisor\" href=\"#%E7%9B%A3%E8%A6%96%E6%A9%9F%E6%A7%8B%20Supervisor\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"監視機構 Supervisor\"> &gt; 監視機構 Supervisor</span></a>監視機構 Supervisor</h3>\n<p data-sourcepos=\"67:1-67:609\">まず、Supervisor。Elixirには監視機構Supervisorがあり、それが各ワーカーを子プロセスとして管理しています。ここではフィード読込とブクマは別々のワーカーで処理しますが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ <code>one_for_all</code> ）にしてあります。再起動戦略の詳細は「<a href=\"https://elixirschool.com/ja/lessons/advanced/otp-supervisors/\" target=\"_blank\" rel=\"noopener noreferrer\">OTPスーパバイザ · Elixir School</a>」を参照下さい。</p>\n<p data-sourcepos=\"69:1-69:197\">下記のように <code>Supervisor.start_link</code> を <code>Keshikimi2.Application.start</code> に適用すると、アプリケーション開始（ <code>mix run</code> ）した時点で監視機構が起動されます。</p>\n<div class=\"code-block\" data-sourcepos=\"71:1-92:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ex</div>\n<div class=\"highlight\"><pre class=\"highlight elixir\"><code><span class=\"no\">Supervisor</span><span class=\"o\">.</span><span class=\"n\">start_link</span><span class=\"p\">(</span>\n  <span class=\"p\">[</span>\n    <span class=\"ss\">:hackney_pool</span><span class=\"o\">.</span><span class=\"n\">child_spec</span><span class=\"p\">(</span><span class=\"ss\">:hatena_bookmark_pool</span><span class=\"p\">,</span> <span class=\"ss\">timeout:</span> <span class=\"mi\">15_000</span><span class=\"p\">,</span> <span class=\"ss\">max_connections:</span> <span class=\"mi\">100</span><span class=\"p\">),</span>\n    <span class=\"c1\"># @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Cachex</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"ss\">:feed</span><span class=\"p\">,</span> <span class=\"p\">[]]),</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Registry</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n\n    <span class=\"c1\"># フィード読込処理 (PubSub)</span>\n    <span class=\"n\">supervisor</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Subscriber</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Worker</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">prefix</span><span class=\"p\">]),</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2Feed</span><span class=\"o\">.</span><span class=\"no\">Publisher</span><span class=\"p\">,</span> <span class=\"p\">[[</span><span class=\"ss\">prefix:</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"ss\">poll_interval:</span> <span class=\"mi\">3_000</span><span class=\"p\">]]),</span>\n\n    <span class=\"c1\"># ブクマ処理</span>\n    <span class=\"n\">worker</span><span class=\"p\">(</span><span class=\"no\">Keshikimi2</span><span class=\"o\">.</span><span class=\"no\">HatenaBookmark</span><span class=\"o\">.</span><span class=\"no\">AddEntry</span><span class=\"p\">,</span> <span class=\"p\">[</span>\n      <span class=\"p\">[</span><span class=\"ss\">prefix:</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"ss\">poll_interval:</span> <span class=\"mi\">3_000</span><span class=\"p\">]</span>\n    <span class=\"p\">])</span>\n  <span class=\"p\">],</span>\n  <span class=\"ss\">strategy:</span> <span class=\"ss\">:one_for_all</span><span class=\"p\">,</span>\n  <span class=\"ss\">name:</span> <span class=\"n\">name</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"94:1-94:37\" id=\"2-2-2\" name=\"2-2-2\">\n<a class=\"anchor\" id=\"非同期処理 Task.async_stream\" name=\"%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%20Task.async_stream\" href=\"#%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%20Task.async_stream\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"非同期処理 Task.async_stream\"> &gt; 非同期処理 Task.async_stream</span></a>非同期処理 Task.async_stream</h3>\n<p data-sourcepos=\"95:1-95:461\">次に、Task.async_stream。配列を引き回すリクエスト処理は <code>Task.async_stream</code> がうってつけです。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいます。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができます。</p>\n<div class=\"code-block\" data-sourcepos=\"97:1-139:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ex</div>\n<div class=\"highlight\"><pre class=\"highlight elixir\"><code><span class=\"no\">Cachex</span><span class=\"o\">.</span><span class=\"n\">keys!</span><span class=\"p\">(</span><span class=\"ss\">:feed</span><span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Enum</span><span class=\"o\">.</span><span class=\"n\">reject</span><span class=\"p\">(</span><span class=\"k\">fn</span> <span class=\"n\">key</span> <span class=\"o\">-&gt;</span>\n  <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"p\">[</span>\n    <span class=\"s2\">\"excluded_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"excluded_titles\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"corrected_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"redirected_links\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"feed_group\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"archived_links\"</span>\n  <span class=\"p\">]</span>\n<span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Task</span><span class=\"o\">.</span><span class=\"n\">async_stream</span><span class=\"p\">(</span>\n  <span class=\"k\">fn</span> <span class=\"n\">item_link</span> <span class=\"o\">-&gt;</span>\n    <span class=\"n\">with</span> <span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">item_title</span><span class=\"p\">,</span> <span class=\"n\">feed_tags</span><span class=\"p\">]}</span> <span class=\"o\">&lt;-</span> <span class=\"no\">Cachex</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"ss\">:feed</span><span class=\"p\">,</span> <span class=\"n\">item_link</span><span class=\"p\">),</span>\n         <span class=\"ss\">:ok</span> <span class=\"o\">&lt;-</span> <span class=\"n\">validate_all</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">,</span> <span class=\"n\">item_title</span><span class=\"p\">),</span>\n         <span class=\"n\">corrected_link</span> <span class=\"o\">&lt;-</span> <span class=\"n\">correct_all</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">),</span>\n         <span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span> <span class=\"n\">payload</span><span class=\"p\">}</span> <span class=\"o\">&lt;-</span>\n           <span class=\"no\">FormData</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span>\n             <span class=\"p\">%{</span>\n               <span class=\"ss\">url:</span> <span class=\"n\">corrected_link</span><span class=\"p\">,</span>\n               <span class=\"ss\">comment:</span> <span class=\"n\">feed_tags</span> <span class=\"o\">|&gt;</span> <span class=\"no\">Enum</span><span class=\"o\">.</span><span class=\"n\">map_join</span><span class=\"p\">(</span><span class=\"k\">fn</span> <span class=\"n\">tag</span> <span class=\"o\">-&gt;</span> <span class=\"s2\">\"[</span><span class=\"si\">#{</span><span class=\"n\">tag</span><span class=\"si\">}</span><span class=\"s2\">]\"</span> <span class=\"k\">end</span><span class=\"p\">),</span>\n               <span class=\"ss\">rks:</span> <span class=\"no\">System</span><span class=\"o\">.</span><span class=\"n\">get_env</span><span class=\"p\">(</span><span class=\"s2\">\"HATENA_BOOKMARK_RKS\"</span><span class=\"p\">),</span>\n               <span class=\"ss\">private:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n               <span class=\"ss\">keep_original_url:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n               <span class=\"ss\">with_status_op:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n               <span class=\"ss\">from:</span> <span class=\"s2\">\"inplace\"</span><span class=\"p\">,</span>\n               <span class=\"ss\">post_twitter:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n               <span class=\"ss\">post_evernote:</span> <span class=\"mi\">0</span>\n             <span class=\"p\">},</span>\n             <span class=\"ss\">:url_encoded</span><span class=\"p\">,</span>\n             <span class=\"ss\">get:</span> <span class=\"no\">false</span>\n           <span class=\"p\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">do_add_entries_to_hb</span><span class=\"p\">(</span><span class=\"n\">payload</span><span class=\"p\">)</span>\n      <span class=\"no\">Logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s2\">\"add entry: </span><span class=\"si\">#{</span><span class=\"n\">item_link</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"n\">archive_link</span><span class=\"p\">(</span><span class=\"n\">item_link</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span><span class=\"p\">,</span>\n  <span class=\"ss\">timeout:</span> <span class=\"mi\">15_000</span>\n<span class=\"p\">)</span>\n<span class=\"o\">|&gt;</span> <span class=\"no\">Stream</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"141:1-141:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"142:1-142:216\">Elixirの非同期処理を使うことではてなブックマークの運用がとても快適になりました。はてなブックマークとの今後の付き合い方は下記のように考えています。</p>\n<ul data-sourcepos=\"144:1-146:0\">\n<li data-sourcepos=\"144:1-144:65\">\n<strong>手動でブクマ:</strong> 気になった記事があるごとに</li>\n<li data-sourcepos=\"145:1-146:0\">\n<strong>ブクマの確認:</strong> 気になるタグごとにまとめて確認</li>\n</ul>\n<p data-sourcepos=\"147:1-147:239\">ブクマの確認については、例えば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「<a href=\"http://b.hatena.ne.jp/nabinno/github\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/github</a>」をみる、という感じの運用です。</p>\n<p data-sourcepos=\"149:1-149:111\">融通が利かない点で途中運用が難しくなる気もしますが、しばらく回してみます。</p>\n","tags":["elixir","hatena-bookmark"],"updated_at":"2021-01-16T01:12:01+09:00","childPublishedDate":{"published_on":"2019-01-01T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_7b757a0db07cde6a337af7df901ab0c5.jpg"}},"relatedPosts":{"edges":[{"node":{"number":55,"relative_category":"blog/backend","fields":{"title":"PositiveSSLをHerokuに適用する","excerpt":"年に1回のSSL更新のイベントです。毎年同じことをすれば良いかというとそうでもなく、販社と卸の都合でSSLの購入方法が微妙に変わります。とは言え、毎年一から調べ直すのも手間なので備忘として記しておきます。  > PROBLEMPROBLEM \n\n- HerokuのSSLの期限がきた  > SOLUTIONSOLUTION \n\n- というわけで、いつも使っているSSL販売代理店SSLs.com（NameCheap社）でPositiveSSL（運用Comodo社）を購入しHerokuに適用します。  > HOWTOHOWTO \n\n1. 証明書を購入する SSL販売代理店であればどこでもいいのですが、昔から使っているので \n2. SSL販売代理店であればどこでもいいのですが、昔から使っているので\n3. 秘密鍵と署名リクエストをつくる 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key 署名リクエスト openssl req -new -key server.key -out server.csr ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました \n4. 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048\n5. 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key\n6. 署名リクエスト openssl req -new -key server.key -out server.csr\n7. ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました\n8. 証明書発行を申請する SSL販売代理店より署名リクエストserver.csrと関連情報を送信します \n9. SSL販売代理店より署名リクエストserver.csrと関連情報を送信します\n10. ドメイン保持の証明をする PositiveSSLの運用会社Comodoに対しドメイン保持の証明します 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります \n11. PositiveSSLの運用会社Comodoに対しドメイン保持の証明します\n12. 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります\n13. Heroku用の証明書をつくる 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n14. 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます\n15. Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt\n16. Herokuに証明書を適用する 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n17. 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key \n18. heroku addons:add ssl:endpoint\n19. heroku certs:add server.crt server.key\n20. 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n21. heroku certs:update server.crt server.key  > WRAPUPWRAPUP \n\nこのあたりが自動化されれば良いと思いつつ、自動化されたらこのあたりを調べるモチベーションがなくなるので年に一回のリハビリイベントとして位置づけておきます、はい。  > 後日談後日談 \n\n現在はAutomated Certificate Management (ACM) 機能が用意されています。そちらを使う方が手間・実費ともにリーズナブルで、リハビリさえもいらなくなりました。以下適用方法。 \n\n1. ACMを有効化します。有効化するまでしばし時間がかかるので watch コマンドをつけて様子見します watch heroku certs:auto:enable \n2. watch heroku certs:auto:enable\n3. 手動で追加した証明書があるか確認します heroku certs \n4. heroku certs\n5. もし手動で追加した証明書がある場合は当該証明書を削除します heroku certs:remove --name foo-bar \n6. heroku certs:remove --name foo-bar"},"name":"[2017-04-23]PositiveSSLをHerokuに適用する","tags":[],"childPublishedDate":{"published_on":"2017-04-23T00:00:00.000Z","published_on_unix":1492905600}}},{"node":{"number":140,"relative_category":"blog/backend","fields":{"title":"提供していない決済方法を業務で取り扱う際に気をつけること","excerpt":"ECプロダクトを扱っている際にどうしても出てくる銀行振込。プロダクト立ち上げ時は、銀行振込が第一にあるターゲット層を除いて、コストの高い銀行振込は実装せずに裏メニューとして扱うのが通例だと思います。今回は、当該ケースの課題を取り上げて、その解決策を示します。単純な話なのですが、時間が経つにつれて業務が硬直化してスケーリングに影響してくるので事前に手を打っておくと良いと思います。   > PROBLEMPROBLEM \n\n- 銀行振込を通常決済方法でしか提供していないケースの場合 人力でトランザクションをはる必要があり、その処理の隙間で想定外の支払い、あるいは、二重決済が行われる可能性がある また、不整合処理を実施するCSあるいはそれに付随する担当に権限が集中しすぎ、統制上難しい運用になる \n- 人力でトランザクションをはる必要があり、その処理の隙間で想定外の支払い、あるいは、二重決済が行われる可能性がある\n- また、不整合処理を実施するCSあるいはそれに付随する担当に権限が集中しすぎ、統制上難しい運用になる  > 通常のケース通常のケース \n\n  > 不整合が起きるケース「銀行振込と通常決済が同時に実行」不整合が起きるケース「銀行振込と通常決済が同時に実行」 \n\n  > SOLUTIONSOLUTION \n\nと言うわけで、解決方法を整理してみました。答えは単純で銀行振込の決済ロックをシステム側に実装するというだけの話です。ただ、振込確認を人力で行っている場合は、銀行振込を決済方法として表側に出すのは難しいので問い合わせタイミングでロックできるよう問い合わせ窓口を工夫する必要があります。プロダクトのUXに関わってくる話なので簡単に実装するだけで済まないのが悩ましいところですが、粘り強く進めるしかないです。 \n\n  > WRAPUPWRAPUP \n\nECプロダクトがスケールしてくると決済方法が増え、業務処理が複雑になってきます。決済の適正性は統制上重要になってくるので決済の処理量に応じて、リスクアセスメントで拾い上げ適切な実装にしていきたいものですね。"},"name":"[2022-05-02]提供していない決済方法を業務で取り扱う際に気をつけること","tags":["payment-service"],"childPublishedDate":{"published_on":"2022-05-02T00:00:00.000Z","published_on_unix":1651449600}}},{"node":{"number":139,"relative_category":"blog/backend","fields":{"title":"ヘルステック界隈のエンジニアが気をつけるべき個人情報の扱い","excerpt":"ヘルステックでエンジニアをしている方であればデータの扱いには苦労していることと思います。CISOがつくったデータセグメンテーションがどういう意図で成り立っているのか、整理されていない現場だと読み解きに時間がかかります。現場に入って早々 何も知らないエンジニアとしては、緩めな方針よりは保守的に設計していく方が後々のトラブルが少なく安全です。   > PROBLEMPROBLEM \n\n- 要配慮個人情報について、厚労省医政局発「医療情報システムの安全管理に関するガイドライン」1を見ると「 医療・健康情報を[..]医師等以外の者が分析等を実施することは許されるものではない 」と書かれている ここでいう「 医療・健康情報 」は要配慮個人情報の中の具体的に何を指しているのか分かりづらい 「 医師等 」の「 等 」が何を指すのか分かりづらい 厚労省医政局の発令0912001号「診療情報の提供等に関する指針」2から推察するに、「 医療・健康情報 」は診療録、「 医師等 」は医療系有資格者を指している 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象 \n- ここでいう「 医療・健康情報 」は要配慮個人情報の中の具体的に何を指しているのか分かりづらい\n- 「 医師等 」の「 等 」が何を指すのか分かりづらい\n- 厚労省医政局の発令0912001号「診療情報の提供等に関する指針」2から推察するに、「 医療・健康情報 」は診療録、「 医師等 」は医療系有資格者を指している 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象 \n- 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象\n- また、データアクセス対象を緩めると、教育が不十分な人が故意に流出させ刑法上の秘密漏示罪3に問われる可能性がある 秘密漏示罪は身分犯ではあるが歯科医師のように解釈の余地もあり範囲が不透明 \n- 秘密漏示罪は身分犯ではあるが歯科医師のように解釈の余地もあり範囲が不透明  > SOLUTIONSOLUTION \n\nというわけで、ヘルステックに関わる個人情報の扱いを整理してみました。 \n\n課題は上記の通りで、時代の流れとともに医療情報の整備が進んでいる状況です。善管注意の責務を負ったエンジニアとしては医療系有資格者以外への診療録の情報提供は、例え、同僚であっても連結可能匿名（仮名加工）ではなく匿名加工で対応すべきでしょう。ゆくゆくは会社として次世代医療基盤法4を適用し、医療分野の研究開発に資するよう体制を構築することが望ましいと考えています。  > 加工なし加工なし \n\n学術研究等をのぞき第三者提供は本人同意が必要となるため、ユースケースは限定されます。各々の個人情報の種類によりアクセス出来る人が変わってきます。また、守秘義務が課せられる範囲が広く、行為によっては秘密漏示罪や不正アクセス禁止法5の罰則の対象になります。     診療録 診療録を除いた要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内 (医療関連有資格者) 社内 社内, 社外   利用目的の必要性 (公表有無) 必要 必要 必要   利用目的の必要性 (変更可否) 関連性を有する合理的な範囲 関連性を有する合理的な範囲 関連性を有する合理的な範囲   目的外利用 不可 不可 不可   第三者提供 (可否) 可 可 可   第三者提供 (本人同意) 必要 (オプトインのみ) 必要 (オプトインのみ) 必要 (オプトアウト)   個人の開示請求 応じる 応じる 応じる   漏洩時の報告 必須 必須 必須     > 仮名加工仮名加工 \n\n診療録に関する規定は次世代医療基盤法でまとめられているので、あえて規定が曖昧な仮名加工（連結可能匿名）をつかうのは望ましくありません。ユースケースとして要配慮個人情報を除いた個人情報の統計分析に限られるでしょう。     診療録を除いた要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内 社内   利用目的の必要性 (公表有無) 必要 必要   利用目的の必要性 (変更可否) 際限なく変更可能 際限なく変更可能   目的外利用 不可 不可   第三者提供 (可否) 不可 不可   個人の開示請求 応じない 応じない   漏洩時の報告 なし なし     > 匿名加工匿名加工 \n\n診療録は本人のオプトアウトありですが、基本本人同意なしで利用可能です。ただ、診療録は可変長文字列の上、特異な記述として最も気をつける対象になります。データマスキングの実装は手厚く行っていく必要があります。     診療録を含んだ要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内, 社外 社内, 社外   利用目的の必要性 (公表有無) 不要 不要   第三者提供 (可否) 可 可   第三者提供 (本人同意) 不要 (オプトアウトあり) 不要   個人の開示請求 応じない 応じない   漏洩時の報告 なし なし     > WRAPUPWRAPUP \n\nポイントをかいつまんでまとめてみました。エンジニア視点のため、考慮漏れの箇所があるかも知れませんが、フィードバックや各種レギュレーションの経過を元に更新していければと思います。  \n\n1. https://www.mhlw.go.jp/stf/shingi/0000516275.html ↩ \n2. https://www.mhlw.go.jp/web/t_doc?dataId=00tb3403&dataType=1&page%20No=1 ↩ \n3. https://elaws.e-gov.go.jp/document?lawid=140AC0000000045 ↩ \n4. https://elaws.e-gov.go.jp/document?lawid=429AC0000000028 ↩ \n5. https://elaws.e-gov.go.jp/document?lawid=411AC0000000128 ↩"},"name":"[2022-04-24]ヘルステック界隈のエンジニアが気をつけるべき個人情報の扱い","tags":["privacy","data-masking","data-engineering","health-informatics"],"childPublishedDate":{"published_on":"2022-04-24T00:00:00.000Z","published_on_unix":1650758400}}}]}},"pageContext":{"number":62}},"staticQueryHashes":[]}