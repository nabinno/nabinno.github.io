{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/75","result":{"data":{"esaPost":{"number":75,"relative_category":"blog/backend","fields":{"title":"CDKで管理する今どきのJenkins","excerpt":"先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。  > PROBLEMPROBLEM \n\n- インフラ系タスクがコード管理されていないので属人化しやすい 可能なら当該タスクはインフラ担当から手離れして欲しい 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- 可能なら当該タスクはインフラ担当から手離れして欲しい\n- 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- ヘルスチェックエラーにひっかかったら自動で再起動してほしい  > SOLUTIONSOLUTION \n\nというわけで、モダンなJenkins2系をAWS CDKで敷設してみました。  > 1. 構成1. 構成 \n\n大方の構成は「nabinno/jenkins-cdk-on-ec2」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。 \n\n使用技術スタック \n\n- Jenkins\n- Amazon ECS（Amazon EC2）\n- Application Load Balancer\n- Amazon EFS   > 2. CDKによるJenkinsの敷設2. CDKによるJenkinsの敷設 \n\nCDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。  > 2-a. CDKの注意点：リソース名を明示する2-a. CDKの注意点：リソース名を明示する \n\nCDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。 \n\n命名規則は「クラスメソッドさんの記事」を参考に決めるのが定番のようです。下記例になります。    AWSリソース 命名規則     ELB {sysname}-{env}-alb/clb   TargetGroup {sysname}-{env}-tg   EC2 {sysname}-{env}-{type}   SecurityGroup {sysname}-{env}-{type}-sg    \n\nCDKでリソース名を明示するには次のいずれかの方法で対応します。 \n\n- 各クラスのコンストラクトプロパティにある名前を記述する\n- 暗黙的生成されるリソースを明示的に作成する \n\n下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。 ts\n\n// ECS: Service const serviceSecGrp = new ec2.SecurityGroup(this, \"JenkinsMasterServiceSecGrp\", { securityGroupName: \"jenkins-production-master-sg\", vpc: network.vpc, allowAllOutbound: true, }); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(50000), \"from JenkinsWorkerSecurityGroup 50000\"); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(8080), \"from JenkinsWorkerSecurityGroup 8080\"); const jenkinsMasterService = new ecs.Ec2Service(this, \"EC2MasterService\", { serviceName: 'jenkins-production-master-svc', taskDefinition: jenkinsMasterTask, cloudMapOptions: { name: \"master\", dnsRecordType: sd.DnsRecordType.A }, desiredCount: 1, minHealthyPercent: 0, maxHealthyPercent: 100, enableECSManagedTags: true, cluster: ecsCluster.cluster, securityGroups: [serviceSecGrp] });  \n\nなお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。  > 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける \n\nネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるのでcdk.RemovablePolicy.RETAIN、CFnの言うところの \"DeletionPolicy\": \"Retain\" をつけましょう。今回はEFSがその対象になります。 ts\n\nconst efsFilesystem = new efs.CfnFileSystem(this, \"EFSBackend\"); efsFilesystem.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);  \n\n個人的にはRETAINをつけるとcdk destroy cdk deployを気軽に行えなくなるので、RETAINをつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。  > 3. Jenkinsの設定を行う3. Jenkinsの設定を行う \n\nCDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。  > 3-a. Jenkinsでつかっているプラグイン3-a. Jenkinsでつかっているプラグイン \n\n昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。 \n\n- github-oauth\n- role-strategy\n- configuration-as-code\n- blueocean \n\nざっと説明するとgithub-oauthでGitHub認証させ、role-strategyでロールごとの権限付与を行い、configuration-as-codeでそれらの管理設定をコード化します。configuration-as-codeは素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、blueoceanはモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。 \n\nなお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。 sh\n\n$ cat plugins.txt role-strategy:3.1 github-oauth:0.33 thinBackup:1.10 git:4.6.0 authorize-project:1.3.0 configuration-as-code:1.47 blueocean:1.24.4 $ cat Dockerfile [...] COPY plugins.txt /usr/share/jenkins/ref/plugins.txt RUN /usr/local/bin/install-plugins.sh < /usr/share/jenkins/ref/plugins.txt [...]   > 3-b. JenkinsジョブをGitHubで管理する3-b. JenkinsジョブをGitHubで管理する \n\nいよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。 \n\n1. ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、Jenkinsfile を配置\n2. 「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう Where do you store your code? - GitHub Which organization does the repository belong to? - 任意のuserあるいはorganization Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n3. Where do you store your code? - GitHub\n4. Which organization does the repository belong to? - 任意のuserあるいはorganization\n5. Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n\nJenkinsfile の作成方法は「ユーザーハンドブック」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。 Jenkinsfile\n\n pipeline { agent any stages { stage('Show env') { steps { sh '''mysql --version ls -al bin env | sort''' } } stage('Run script') { steps { git(url: 'https://github.com/nabinno/jenkins-jobs', branch: 'master', credentialsId: 'github') sh '''git diff sync-db-from-staging-to-integration | patch -p1 -R -f bin/sync_db_from_staging_to_integration''' } } } environment { STAG_DB_DATABASE = credentials('STAG_DB_DATABASE') STAG_DB_HOSTNAME = credentials('STAG_DB_HOSTNAME') STAG_DB_PASSWORD = credentials('STAG_DB_PASSWORD') STAG_DB_USERNAME = credentials('STAG_DB_USERNAME') INTEG_DB_HOSTNAME = credentials('INTEG_DB_HOSTNAME') INTEG_DB_PASSWORD = credentials('INTEG_DB_PASSWORD') INTEG_DB_USERNAME = credentials('INTEG_DB_USERNAME') INTEG_DB_DATABASE = credentials('INTEG_DB_USERNAME') } }   > WRAPUPWRAPUP \n\n今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。 \n\n1. CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。\n2. Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg"},"wip":false,"body_md":"<img width=\"1280\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\">\r\n\r\n\r\n先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。\r\n\r\n# PROBLEM\r\n- インフラ系タスクがコード管理されていないので属人化しやすい\r\n    - 可能なら当該タスクはインフラ担当から手離れして欲しい\r\n    - 当該タスクは通常のCIワークフローとは異なるので管理する場所がない\r\n        - そういう意味でJenkinsの出番だけどこれはこれで管理が手間\r\n            - ヘルスチェックエラーにひっかかったら自動で再起動してほしい\r\n\r\n# SOLUTION\r\nというわけで、モダンなJenkins2系をAWS CDKで敷設してみました。\r\n\r\n## 1. 構成\r\n大方の構成は「[nabinno/jenkins-cdk-on-ec2](https://github.com/nabinno/jenkins-cdk-on-ec2)」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。\r\n\r\n使用技術スタック\r\n- Jenkins\r\n- Amazon ECS（Amazon EC2）\r\n- Application Load Balancer\r\n- Amazon EFS\r\n\r\n<img width=\"1640\" alt=\"\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\">\r\n\r\n## 2. CDKによるJenkinsの敷設\r\nCDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。\r\n\r\n### 2-a. CDKの注意点：リソース名を明示する\r\nCDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。\r\n\r\n命名規則は「[クラスメソッドさんの記事](https://dev.classmethod.jp/articles/aws-name-rule/)」を参考に決めるのが定番のようです。下記例になります。\r\n\r\n| AWSリソース | 命名規則 |\r\n| --- | --- |\r\n| ELB | {sysname}-{env}-alb/clb |\r\n| TargetGroup | {sysname}-{env}-tg |\r\n| EC2 | {sysname}-{env}-{type} |\r\n| SecurityGroup | {sysname}-{env}-{type}-sg |\r\n\r\nCDKでリソース名を明示するには次のいずれかの方法で対応します。\r\n- 各クラスのコンストラクトプロパティにある名前を記述する\r\n- 暗黙的生成されるリソースを明示的に作成する\r\n\r\n下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。\r\n\r\n```ts\r\n// ECS: Service\r\nconst serviceSecGrp = new ec2.SecurityGroup(this, \"JenkinsMasterServiceSecGrp\", {\r\n  securityGroupName: \"jenkins-production-master-sg\",\r\n  vpc: network.vpc,\r\n  allowAllOutbound: true,\r\n});\r\nserviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(50000), \"from JenkinsWorkerSecurityGroup 50000\");\r\nserviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(8080), \"from JenkinsWorkerSecurityGroup 8080\");\r\n\r\nconst jenkinsMasterService = new ecs.Ec2Service(this, \"EC2MasterService\", {\r\n  serviceName: 'jenkins-production-master-svc',\r\n  taskDefinition: jenkinsMasterTask,\r\n  cloudMapOptions: { name: \"master\", dnsRecordType: sd.DnsRecordType.A },\r\n  desiredCount: 1,\r\n  minHealthyPercent: 0,\r\n  maxHealthyPercent: 100,\r\n  enableECSManagedTags: true,\r\n  cluster: ecsCluster.cluster,\r\n  securityGroups: [serviceSecGrp]\r\n});\r\n```\r\n\r\nなお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。\r\n\r\n### 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\r\nネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるので`cdk.RemovablePolicy.RETAIN`、CFnの言うところの `\"DeletionPolicy\": \"Retain\"` をつけましょう。今回はEFSがその対象になります。\r\n\r\n```ts\r\nconst efsFilesystem = new efs.CfnFileSystem(this, \"EFSBackend\");\r\nefsFilesystem.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);\r\n```\r\n\r\n個人的には`RETAIN`をつけると`cdk destroy` `cdk deploy`を気軽に行えなくなるので、`RETAIN`をつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。\r\n\r\n## 3. Jenkinsの設定を行う\r\nCDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。\r\n\r\n### 3-a. Jenkinsでつかっているプラグイン\r\n昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。\r\n\r\n- github-oauth\r\n- role-strategy\r\n- configuration-as-code\r\n- blueocean\r\n\r\nざっと説明すると`github-oauth`でGitHub認証させ、`role-strategy`でロールごとの権限付与を行い、`configuration-as-code`でそれらの管理設定をコード化します。`configuration-as-code`は素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、`blueocean`はモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。\r\n\r\nなお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。\r\n\r\n```sh\r\n$ cat plugins.txt\r\nrole-strategy:3.1\r\ngithub-oauth:0.33\r\nthinBackup:1.10\r\ngit:4.6.0\r\nauthorize-project:1.3.0\r\nconfiguration-as-code:1.47\r\nblueocean:1.24.4\r\n\r\n$ cat Dockerfile\r\n[...]\r\nCOPY plugins.txt /usr/share/jenkins/ref/plugins.txt\r\nRUN /usr/local/bin/install-plugins.sh < /usr/share/jenkins/ref/plugins.txt\r\n[...]\r\n```\r\n\r\n###  3-b. JenkinsジョブをGitHubで管理する\r\nいよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。\r\n\r\n1. ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、`Jenkinsfile` を配置\r\n1. 「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう\r\n    - Where do you store your code?\t- GitHub\r\n    - Which organization does the repository belong to?\t- 任意のuserあるいはorganization\r\n    - Choose a repository - 任意のレポジトリ（1で作成したレポジトリ）\r\n\r\n`Jenkinsfile` の作成方法は「[ユーザーハンドブック](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/)」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。\r\n\r\n```Jenkinsfile\r\n  \r\npipeline {\r\n  agent any\r\n  stages {\r\n    stage('Show env') {\r\n      steps {\r\n        sh '''mysql --version\r\nls -al bin\r\nenv  | sort'''\r\n      }\r\n    }\r\n\r\n    stage('Run script') {\r\n      steps {\r\n        git(url: 'https://github.com/nabinno/jenkins-jobs', branch: 'master', credentialsId: 'github')\r\n        sh '''git diff sync-db-from-staging-to-integration | patch -p1 -R -f\r\nbin/sync_db_from_staging_to_integration'''\r\n      }\r\n    }\r\n\r\n  }\r\n  environment {\r\n    STAG_DB_DATABASE = credentials('STAG_DB_DATABASE')\r\n    STAG_DB_HOSTNAME = credentials('STAG_DB_HOSTNAME')\r\n    STAG_DB_PASSWORD = credentials('STAG_DB_PASSWORD')\r\n    STAG_DB_USERNAME = credentials('STAG_DB_USERNAME')\r\n    INTEG_DB_HOSTNAME = credentials('INTEG_DB_HOSTNAME')\r\n    INTEG_DB_PASSWORD = credentials('INTEG_DB_PASSWORD')\r\n    INTEG_DB_USERNAME = credentials('INTEG_DB_USERNAME')\r\n    INTEG_DB_DATABASE = credentials('INTEG_DB_USERNAME')\r\n  }\r\n}\r\n```\r\n\r\n# WRAPUP\r\n今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。\r\n\r\n1. CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。\r\n2. Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1280\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\"></a>\n<p data-sourcepos=\"4:1-4:286\">先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。</p>\n<h1 data-sourcepos=\"6:1-6:9\" id=\"1-0-0\" name=\"1-0-0\"><a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"7:1-12:0\">\n<li data-sourcepos=\"7:1-12:0\">インフラ系タスクがコード管理されていないので属人化しやすい\n<ul data-sourcepos=\"8:5-12:0\">\n<li data-sourcepos=\"8:5-8:84\">可能なら当該タスクはインフラ担当から手離れして欲しい</li>\n<li data-sourcepos=\"9:5-12:0\">当該タスクは通常のCIワークフローとは異なるので管理する場所がない\n<ul data-sourcepos=\"10:9-12:0\">\n<li data-sourcepos=\"10:9-12:0\">そういう意味でJenkinsの出番だけどこれはこれで管理が手間\n<ul data-sourcepos=\"11:13-12:0\">\n<li data-sourcepos=\"11:13-12:0\">ヘルスチェックエラーにひっかかったら自動で再起動してほしい</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<h1 data-sourcepos=\"13:1-13:10\" id=\"2-0-0\" name=\"2-0-0\"><a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"14:1-14:84\">というわけで、モダンなJenkins2系をAWS CDKで敷設してみました。</p>\n<h2 data-sourcepos=\"16:1-16:12\" id=\"2-1-0\" name=\"2-1-0\"><a class=\"anchor\" id=\"1. 構成\" name=\"1. 構成\" href=\"#1. 構成\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. 構成\"> &gt; 1. 構成</span></a>1. 構成</h2>\n<p data-sourcepos=\"17:1-17:287\">大方の構成は「<a href=\"https://github.com/nabinno/jenkins-cdk-on-ec2\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/jenkins-cdk-on-ec2</a>」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。</p>\n<p data-sourcepos=\"19:1-19:24\">使用技術スタック</p>\n<ul data-sourcepos=\"20:1-24:0\">\n<li data-sourcepos=\"20:1-20:9\">Jenkins</li>\n<li data-sourcepos=\"21:1-21:28\">Amazon ECS（Amazon EC2）</li>\n<li data-sourcepos=\"22:1-22:27\">Application Load Balancer</li>\n<li data-sourcepos=\"23:1-24:0\">Amazon EFS</li>\n</ul>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1640\" alt=\"\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\"></a>\n<h2 data-sourcepos=\"27:1-27:34\" id=\"2-2-0\" name=\"2-2-0\"><a class=\"anchor\" id=\"2. CDKによるJenkinsの敷設\" name=\"2. CDKによるJenkinsの敷設\" href=\"#2. CDKによるJenkinsの敷設\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. CDKによるJenkinsの敷設\"> &gt; 2. CDKによるJenkinsの敷設</span></a>2. CDKによるJenkinsの敷設</h2>\n<p data-sourcepos=\"28:1-28:170\">CDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。</p>\n<h3 data-sourcepos=\"30:1-30:57\" id=\"2-2-1\" name=\"2-2-1\"><a class=\"anchor\" id=\"2-a. CDKの注意点：リソース名を明示する\" name=\"2-a. CDKの注意点：リソース名を明示する\" href=\"#2-a. CDKの注意点：リソース名を明示する\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2-a. CDKの注意点：リソース名を明示する\"> &gt; 2-a. CDKの注意点：リソース名を明示する</span></a>2-a. CDKの注意点：リソース名を明示する</h3>\n<p data-sourcepos=\"31:1-31:416\">CDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。</p>\n<p data-sourcepos=\"33:1-33:189\">命名規則は「<a href=\"https://dev.classmethod.jp/articles/aws-name-rule/\" target=\"_blank\" rel=\"noopener noreferrer\">クラスメソッドさんの記事</a>」を参考に決めるのが定番のようです。下記例になります。</p>\n<table data-sourcepos=\"35:1-40:45\">\n<thead>\n<tr data-sourcepos=\"35:1-35:34\">\n<th data-sourcepos=\"35:2-35:18\">AWSリソース</th>\n<th data-sourcepos=\"35:20-35:33\">命名規則</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"37:1-37:33\">\n<td data-sourcepos=\"37:2-37:6\">ELB</td>\n<td data-sourcepos=\"37:8-37:32\">{sysname}-{env}-alb/clb</td>\n</tr>\n<tr data-sourcepos=\"38:1-38:36\">\n<td data-sourcepos=\"38:2-38:14\">TargetGroup</td>\n<td data-sourcepos=\"38:16-38:35\">{sysname}-{env}-tg</td>\n</tr>\n<tr data-sourcepos=\"39:1-39:32\">\n<td data-sourcepos=\"39:2-39:6\">EC2</td>\n<td data-sourcepos=\"39:8-39:31\">{sysname}-{env}-{type}</td>\n</tr>\n<tr data-sourcepos=\"40:1-40:45\">\n<td data-sourcepos=\"40:2-40:16\">SecurityGroup</td>\n<td data-sourcepos=\"40:18-40:44\">{sysname}-{env}-{type}-sg</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"42:1-42:90\">CDKでリソース名を明示するには次のいずれかの方法で対応します。</p>\n<ul data-sourcepos=\"43:1-45:0\">\n<li data-sourcepos=\"43:1-43:83\">各クラスのコンストラクトプロパティにある名前を記述する</li>\n<li data-sourcepos=\"44:1-45:0\">暗黙的生成されるリソースを明示的に作成する</li>\n</ul>\n<p data-sourcepos=\"46:1-46:134\">下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。</p>\n<div class=\"code-block\" data-sourcepos=\"48:1-69:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>ts</div><div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"c1\">// ECS: Service</span>\n<span class=\"kd\">const</span> <span class=\"nx\">serviceSecGrp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">SecurityGroup</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">JenkinsMasterServiceSecGrp</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n  <span class=\"na\">securityGroupName</span><span class=\"p\">:</span> <span class=\"dl\">\"</span><span class=\"s2\">jenkins-production-master-sg</span><span class=\"dl\">\"</span><span class=\"p\">,</span>\n  <span class=\"na\">vpc</span><span class=\"p\">:</span> <span class=\"nx\">network</span><span class=\"p\">.</span><span class=\"nx\">vpc</span><span class=\"p\">,</span>\n  <span class=\"na\">allowAllOutbound</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">serviceSecGrp</span><span class=\"p\">.</span><span class=\"nx\">addIngressRule</span><span class=\"p\">(</span><span class=\"nx\">worker</span><span class=\"p\">.</span><span class=\"nx\">workerSecurityGroup</span><span class=\"p\">,</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">Port</span><span class=\"p\">.</span><span class=\"nx\">tcp</span><span class=\"p\">(</span><span class=\"mi\">50000</span><span class=\"p\">),</span> <span class=\"dl\">\"</span><span class=\"s2\">from JenkinsWorkerSecurityGroup 50000</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n<span class=\"nx\">serviceSecGrp</span><span class=\"p\">.</span><span class=\"nx\">addIngressRule</span><span class=\"p\">(</span><span class=\"nx\">worker</span><span class=\"p\">.</span><span class=\"nx\">workerSecurityGroup</span><span class=\"p\">,</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">Port</span><span class=\"p\">.</span><span class=\"nx\">tcp</span><span class=\"p\">(</span><span class=\"mi\">8080</span><span class=\"p\">),</span> <span class=\"dl\">\"</span><span class=\"s2\">from JenkinsWorkerSecurityGroup 8080</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">jenkinsMasterService</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ecs</span><span class=\"p\">.</span><span class=\"nx\">Ec2Service</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">EC2MasterService</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n  <span class=\"na\">serviceName</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">jenkins-production-master-svc</span><span class=\"dl\">'</span><span class=\"p\">,</span>\n  <span class=\"na\">taskDefinition</span><span class=\"p\">:</span> <span class=\"nx\">jenkinsMasterTask</span><span class=\"p\">,</span>\n  <span class=\"na\">cloudMapOptions</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">\"</span><span class=\"s2\">master</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"na\">dnsRecordType</span><span class=\"p\">:</span> <span class=\"nx\">sd</span><span class=\"p\">.</span><span class=\"nx\">DnsRecordType</span><span class=\"p\">.</span><span class=\"nx\">A</span> <span class=\"p\">},</span>\n  <span class=\"na\">desiredCount</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"na\">minHealthyPercent</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n  <span class=\"na\">maxHealthyPercent</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n  <span class=\"na\">enableECSManagedTags</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n  <span class=\"na\">cluster</span><span class=\"p\">:</span> <span class=\"nx\">ecsCluster</span><span class=\"p\">.</span><span class=\"nx\">cluster</span><span class=\"p\">,</span>\n  <span class=\"na\">securityGroups</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"nx\">serviceSecGrp</span><span class=\"p\">]</span>\n<span class=\"p\">});</span>\n</code></pre></div></div>\n<p data-sourcepos=\"71:1-71:457\">なお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。</p>\n<h3 data-sourcepos=\"73:1-73:65\" id=\"2-2-2\" name=\"2-2-2\"><a class=\"anchor\" id=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" name=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" href=\"#2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\"> &gt; 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける</span></a>2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける</h3>\n<p data-sourcepos=\"74:1-74:304\">ネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるので<code>cdk.RemovablePolicy.RETAIN</code>、CFnの言うところの <code>\"DeletionPolicy\": \"Retain\"</code> をつけましょう。今回はEFSがその対象になります。</p>\n<div class=\"code-block\" data-sourcepos=\"76:1-79:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>ts</div><div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"kd\">const</span> <span class=\"nx\">efsFilesystem</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">efs</span><span class=\"p\">.</span><span class=\"nx\">CfnFileSystem</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">EFSBackend</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n<span class=\"nx\">efsFilesystem</span><span class=\"p\">.</span><span class=\"nx\">applyRemovalPolicy</span><span class=\"p\">(</span><span class=\"nx\">cdk</span><span class=\"p\">.</span><span class=\"nx\">RemovalPolicy</span><span class=\"p\">.</span><span class=\"nx\">RETAIN</span><span class=\"p\">);</span>\n</code></pre></div></div>\n<p data-sourcepos=\"81:1-81:217\">個人的には<code>RETAIN</code>をつけると<code>cdk destroy</code> <code>cdk deploy</code>を気軽に行えなくなるので、<code>RETAIN</code>をつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。</p>\n<h2 data-sourcepos=\"83:1-83:31\" id=\"2-3-0\" name=\"2-3-0\"><a class=\"anchor\" id=\"3. Jenkinsの設定を行う\" name=\"3. Jenkinsの設定を行う\" href=\"#3. Jenkinsの設定を行う\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. Jenkinsの設定を行う\"> &gt; 3. Jenkinsの設定を行う</span></a>3. Jenkinsの設定を行う</h2>\n<p data-sourcepos=\"84:1-84:83\">CDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。</p>\n<h3 data-sourcepos=\"86:1-86:52\" id=\"2-3-1\" name=\"2-3-1\"><a class=\"anchor\" id=\"3-a. Jenkinsでつかっているプラグイン\" name=\"3-a. Jenkinsでつかっているプラグイン\" href=\"#3-a. Jenkinsでつかっているプラグイン\" data-position=\"2-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3-a. Jenkinsでつかっているプラグイン\"> &gt; 3-a. Jenkinsでつかっているプラグイン</span></a>3-a. Jenkinsでつかっているプラグイン</h3>\n<p data-sourcepos=\"87:1-87:91\">昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。</p>\n<ul data-sourcepos=\"89:1-93:0\">\n<li data-sourcepos=\"89:1-89:14\">github-oauth</li>\n<li data-sourcepos=\"90:1-90:15\">role-strategy</li>\n<li data-sourcepos=\"91:1-91:23\">configuration-as-code</li>\n<li data-sourcepos=\"92:1-93:0\">blueocean</li>\n</ul>\n<p data-sourcepos=\"94:1-94:515\">ざっと説明すると<code>github-oauth</code>でGitHub認証させ、<code>role-strategy</code>でロールごとの権限付与を行い、<code>configuration-as-code</code>でそれらの管理設定をコード化します。<code>configuration-as-code</code>は素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、<code>blueocean</code>はモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。</p>\n<p data-sourcepos=\"96:1-96:105\">なお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。</p>\n<div class=\"code-block\" data-sourcepos=\"98:1-113:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>sh</div><div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">cat </span>plugins.txt\nrole-strategy:3.1\ngithub-oauth:0.33\nthinBackup:1.10\ngit:4.6.0\nauthorize-project:1.3.0\nconfiguration-as-code:1.47\nblueocean:1.24.4\n\n<span class=\"nv\">$ </span><span class=\"nb\">cat </span>Dockerfile\n<span class=\"o\">[</span>...]\nCOPY plugins.txt /usr/share/jenkins/ref/plugins.txt\nRUN /usr/local/bin/install-plugins.sh &lt; /usr/share/jenkins/ref/plugins.txt\n<span class=\"o\">[</span>...]\n</code></pre></div></div>\n<h3 data-sourcepos=\"115:1-115:50\" id=\"2-3-2\" name=\"2-3-2\"><a class=\"anchor\" id=\"3-b. JenkinsジョブをGitHubで管理する\" name=\"3-b. JenkinsジョブをGitHubで管理する\" href=\"#3-b. JenkinsジョブをGitHubで管理する\" data-position=\"2-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3-b. JenkinsジョブをGitHubで管理する\"> &gt; 3-b. JenkinsジョブをGitHubで管理する</span></a>3-b. JenkinsジョブをGitHubで管理する</h3>\n<p data-sourcepos=\"116:1-116:233\">いよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。</p>\n<ol data-sourcepos=\"118:1-123:0\">\n<li data-sourcepos=\"118:1-118:128\">ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、<code>Jenkinsfile</code> を配置</li>\n<li data-sourcepos=\"119:1-123:0\">「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう\n<ul data-sourcepos=\"120:5-123:0\">\n<li data-sourcepos=\"120:5-120:44\">Where do you store your code?\t- GitHub</li>\n<li data-sourcepos=\"121:5-121:95\">Which organization does the repository belong to?\t- 任意のuserあるいはorganization</li>\n<li data-sourcepos=\"122:5-123:0\">Choose a repository - 任意のレポジトリ（1で作成したレポジトリ）</li>\n</ul>\n</li>\n</ol>\n<p data-sourcepos=\"124:1-124:369\"><code>Jenkinsfile</code> の作成方法は「<a href=\"https://www.jenkins.io/doc/book/pipeline/jenkinsfile/\" target=\"_blank\" rel=\"noopener noreferrer\">ユーザーハンドブック</a>」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。</p>\n<div class=\"code-block\" data-sourcepos=\"126:1-159:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>Jenkinsfile</div><div class=\"highlight\"><pre class=\"highlight groovy\"><code>  \n<span class=\"n\">pipeline</span> <span class=\"o\">{</span>\n  <span class=\"n\">agent</span> <span class=\"n\">any</span>\n  <span class=\"n\">stages</span> <span class=\"o\">{</span>\n    <span class=\"n\">stage</span><span class=\"o\">(</span><span class=\"s1\">'Show env'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">steps</span> <span class=\"o\">{</span>\n        <span class=\"n\">sh</span> <span class=\"s1\">'''mysql --version\nls -al bin\nenv  | sort'''</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">stage</span><span class=\"o\">(</span><span class=\"s1\">'Run script'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">steps</span> <span class=\"o\">{</span>\n        <span class=\"n\">git</span><span class=\"o\">(</span><span class=\"nl\">url:</span> <span class=\"s1\">'https://github.com/nabinno/jenkins-jobs'</span><span class=\"o\">,</span> <span class=\"nl\">branch:</span> <span class=\"s1\">'master'</span><span class=\"o\">,</span> <span class=\"nl\">credentialsId:</span> <span class=\"s1\">'github'</span><span class=\"o\">)</span>\n        <span class=\"n\">sh</span> <span class=\"s1\">'''git diff sync-db-from-staging-to-integration | patch -p1 -R -f\nbin/sync_db_from_staging_to_integration'''</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"o\">}</span>\n  <span class=\"n\">environment</span> <span class=\"o\">{</span>\n    <span class=\"n\">STAG_DB_DATABASE</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_DATABASE'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_HOSTNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_HOSTNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_PASSWORD</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_PASSWORD'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_USERNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_USERNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_HOSTNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_HOSTNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_PASSWORD</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_PASSWORD'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_USERNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_USERNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_DATABASE</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_USERNAME'</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<h1 data-sourcepos=\"161:1-161:8\" id=\"3-0-0\" name=\"3-0-0\"><a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"162:1-162:238\">今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。</p>\n<ol data-sourcepos=\"164:1-165:184\">\n<li data-sourcepos=\"164:1-164:237\">CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。</li>\n<li data-sourcepos=\"165:1-165:184\">Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。</li>\n</ol>\n","tags":["aws-cdk","jenkins","amazon-ecs"],"updated_at":"2021-07-25T12:08:47+09:00","childPublishedDate":{"published_on":"2021-02-24T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_7b757a0db07cde6a337af7df901ab0c5.jpg"}},"relatedPosts":{"edges":[{"node":{"number":129,"relative_category":"blog/organization","fields":{"title":"ATKerneyの課題解決パターンの魅力的な探求","excerpt":"ATKerneyの課題解決パターン は、課題の本質を見極め、効果的な戦略的構造化を通じて解決策を導き出す手法にフォーカスしています。この冒険の旅は、解決者と協力者たちが心を一つにし、課題に立ち向かう様子が情熱的に描かれています。解決者は課題の謎を解き明かすため、協力者たちと共に奮闘します。   > PROBLEMPROBLEM \n\n- 課題のスコープがブレて良い着地にならないケースが多々ある 課題から解決への導出パターンが人によってバラツキがある \n- 課題から解決への導出パターンが人によってバラツキがある  > SOLUTIONSOLUTION \n\n課題の解決者は、課題自体を徹底的に分析することから始めます。この分析フェーズでは、課題の要因と結果の関係を紐解くことに心を注ぎます。解決者は課題の謎めいたカーテンを開ける使命感に駆られ、協力者たちは彼らの情熱と視点を称賛しながら支えます。 \n\n「この課題の核心は一体何なのだろう？どの因果関係が私たちを解決策へと導いていくのか？」と、解決者は情報の海に没頭します。それはまるで、探検家が未知の大地を踏みしめ、古代の地図を辿るように、彼らは課題の隠された謎を解き明かそうと奮闘します。  > 連想の饗宴連想の饗宴 \n\n課題解決において、連想は新たな視点を開拓するための鍵です。業態連想、目的連想、環境連想という三つのパターンを通じて、解決者と協力者たちは独自のアイデアを紡いでいきます。彼らは情報の輝く宝石を見つけ出すように、連想の糸を辿ります。 \n\n「この課題は他の業界でも類似のパターンが見られるかもしれない。」と、解決者は知識と洞察を交換しながら業態連想を磨きます。友情が深まり、会話が響き合いながら、「君のアイデアに刺激を受けたよ。これが成功すれば、私たちのアプローチが一新されるだろう。」    連想のパターン 説明     業態連想 課題の業態分析 -> 同じ業態特性を連想 -> 課題への示唆を見いだす   目的連想 課題の目的を理解 -> 同じ目的をもつ他の事象を連想 -> 課題への示唆を見いだす   環境連想 課題の環境を理解 -> 同じ環境をもつ他の事象を連想 -> 課題への示唆を見いだす     > 洞察の輝き洞察の輝き \n\n洞察のプロセスは、解決者たちによる深い思索と洞察の力強い探求の旅です。現状の洞察、期待値の明確化、解決案の策定という三つのステップを通じて、彼らは新たな発見に胸を躍らせます。この旅は協力者たちの支援と連帯感によって、より豊かなものとなります。 \n\n「この情報をもっと深く掘り下げてみると、予想外のパターンが見えてくる。」と、解決者は驚愕と興奮の入り混じった感情に駆られながら、新たな着想を追求します。協力者たちは共鳴しながら、「君のアイデアによって、私たちの視点が一歩進化したね。」と、感謝の意を示します。 \n\n洞察につかう七つ道具    道具 説明     レンズ 視点を変化させて考える   ものさし 立場を変化させて考える   蛍光ペン 同じ価値観で考える   フォルダ 構造化して考える   自由帳 真の制約を抽出して考える   メモ 直感を信じて考える   ラベル 「一言でいうと何か」を考える     > 構造化の風景構造化の風景 \n\n分析の成果を基に、解決者たちは情報の鳥瞰図を描きます。性質の軸とつながりの軸という基本軸を駆使し、情報の骨組みを構築していきます。協力者たちは緻密な構造と洞察の力に感嘆しながら、解決者たちの熱意に心を打たれます。 \n\n「これは私たちのアイデアが具体化する瞬間だ。」と、解決者たちは目を輝かせ、情報の鳥瞰図に熱心に取り組みます。協力者たちも大興奮し、「君の発想によって、私たちのチームのアプローチが新たな次元に達したね。」と、彼らを賞賛します。    構造化の基本軸 説明     性質の軸 定量軸（数式、規模）、定性軸（種類）   つながりの軸 時間軸（プロセス、トレンド）、空間軸（地域、陸・海などの空間）     > 実装への舞台実装への舞台 \n\n最終段階では、解決策の実現に向けて全員が一丸となって取り組む舞台が設けられます。異なる協力者たちは個性豊かに集結し、アイデアを具現化するためのステップに移行します。この舞台では、個々の協力者が力を発揮し、チーム全体が課題解決への情熱を注ぎ込む様子が浮かび上がります。 \n\n「ここからが本当の戦いだ。みんな、各自の得意分野を活かして、このアイデアを形にしよう！」と、解決者は意気込みを新たにし、協力者たちは力強く頷きます。協力者たちは個性を生かし、アイデアを現実に昇華させるために一丸となります。 \n\n協力者たちのペルソナ    ペルソナ キャラクタ 説明     情報収集者 人類学者 観察者   情報収集者 実験者 プロトタイプ作成者   情報収集者 花粉の運び手 異分野から挑戦者   土台作成者 ハードル選手 障害を乗り越える人   土台作成者 コラボレーター 横断的な解決者   土台作成者 監督 人材調達者   実現者 CXデザイナー CX提供者   実現者 舞台装置家 環境提供者   実現者 介護人 サービス提供者   実現者 語り部 ブランド醸成者     > WRAPUPWRAPUP \n\nATKerneyの課題解決パターンは、解決者と協力者たちの共同作業によって深化しています。分析 (連想、洞察)、構造化、実装の各フェーズを通じて、彼らの感情や洞察に満ちた探求の旅が描かれています。この冒険の過程で、みな成長し、共に乗り越える困難や成功の瞬間が一層深まっていくのです。"},"name":"[2021-12-26]ATKerneyの課題解決パターンの魅力的な探求","tags":["problem-solving","atkerney"],"childPublishedDate":{"published_on":"2021-12-26T00:00:00.000Z","published_on_unix":1640476800}}},{"node":{"number":70,"relative_category":"blog/market","fields":{"title":"就職氷河期とは何だったのか","excerpt":"私はいわゆる就職氷河期世代です。周囲から時折漏れ聞こえる不平のような言葉がありますが、それを単なる不平として片付けるのはもったいない気がします。できれば、その中に新しい視点を見つけ、次のチャンスへ繋げたいと思っています。   > PROBLEMPROBLEM \n\n- リセッション（景気後退）に直面した若者たちは、就職に関する不満や不平を抱えている\n- 周囲から聞こえてくる否定的な声が、彼らの意欲や展望を損ねている可能性がある\n- 経済の不安定性や求人の減少などの要因により、採用マーケットが厳しい状況にある\n- 若者たちが持つ可能性や才能が、現状の困難な状況によって十分に引き出されていない  > SOLUTIONSOLUTION \n\nそこで、リセッションと大卒の就職率の関係について、また、就職氷河期が単なる経済後退だけではなかったのか、その歴史をじっくりと解き明かしてみたいと思います。  > そもそもリセッションとは何か、どのタイミングで起きるのかそもそもリセッションとは何か、どのタイミングで起きるのか \n\nリセッションとは、経済の景気が一時的に悪化し、生産や雇用が減少する現象を指します。これは通常、国内総生産（GDP）が連続する2つの四半期でマイナス成長する状態になることで定義されます。リセッションはさまざまな要因によって引き起こされ、金融危機や需要減少などが主な原因とされています。  > 新卒採用マーケットについて新卒採用マーケットについて \n\n新卒採用マーケットとは、新卒学生が卒業後に就職を選ぶ際に選択できる求人の数や質を指します。景気の好悪や産業の動向などが影響を及ぼし、景気が良い時には多くの求人が出てくる一方、景気が悪化すると求人数が減少し、競争も激化します。  > リセッションと大卒の就職率の関係とその歴史リセッションと大卒の就職率の関係とその歴史 \n\n統計局の「学校基本調査 年次統計総括表 5 就職率（1950年～）」 から得られたデータに基づくチャートを見ると、リセッションが大卒の就職率にどのような影響を与えたのかがはっきりと分かります。     年 イベント 翌々年大卒の就職率 内閣     1987 ブラックマンデー 79.6% 中曽根/竹下   1997 アジア通貨危機 60.1% 橋本内閣   2000-2004 就職氷河期 55.8% 小渕/森内閣   2008 リーマンショック 60.8% 福田内閣   2020 コロナクラッシュ ??? 安倍/管内閣    \n\n1987年のブラックマンデーに起因するリセッションでは、大卒の就職率が79.6%まで落ち込みました。その後もアジア通貨危機やリーマンショック、そして最近のコロナクラッシュによって、大卒の就職率は変動しています。特に2000年から2004年にかけての就職氷河期では、大卒の就職率が55.8%にまで低下しました。  > アジア通貨危機はなぜ尾を引いていたのかアジア通貨危機はなぜ尾を引いていたのか \n\nアジア通貨危機は、1997年にアジア諸国で発生した経済危機であり、その影響は就職氷河期世代にも長期間にわたって影響を及ぼしました。この危機が尾を引いた理由は以下の点にあります。 \n\n1. 金融システムの崩壊: アジア通貨危機は、一部のアジア諸国で急激な通貨の暴落や金融システムの崩壊を引き起こしました。このため、企業や金融機関が多額の損失を被り、経済全体が深刻な打撃を受けました。経済基盤の崩壊は、就職機会の減少や企業の採用停止などをもたらしました。 \n2. 経済の停滞: アジア諸国の経済は通貨危機後、停滞期に入りました。このため、企業の業績が悪化し、新卒採用の余裕がなくなりました。経済の停滞は、若者たちの就職機会を減少させる一因となりました。 \n3. 信用の低下: 通貨危機により多くの企業が経営危機に陥り、信用が低下しました。これによって、企業が採用活動を控える傾向が生まれ、新卒の求人数が減少しました。就職氷河期世代は、この信用の低下によって求人市場が厳しさを増した現実を直面しました。 \n4. 失業率の上昇: アジア通貨危機により多くの企業が倒産し、失業率が上昇しました。失業者が増加する状況は、求職者同士の競争を激化させ、新卒の就職活動を難しくしました。この影響は就職氷河期世代にも及びました。  \n\nこれらの要因により、アジア通貨危機は長期的な影響をもたらし、若者たちの就職機会やキャリア形成に深刻な影響を与えました。しかし、この困難な状況に対して克服の道を見つけ、自己成長と前向きな姿勢を持つことが、就職氷河期世代の未来への道を切り拓く鍵となったのです。  > WRAPUPWRAPUP \n\n今回は、リセッションの歴史とその背後にある要因について深く考察してみました。リセッションと新卒採用マーケットの動向が、大卒の就職率にどのような影響を与えるかを理解することは、今後のキャリアにおいて重要です。常に社会経済の変動に柔軟に対応し、新たな視点を持って未来を切り開いていくことが大切です。"},"name":"[2021-01-23]就職氷河期とは何だったのか","tags":["labor-economics","recession","employment-ice-age"],"childPublishedDate":{"published_on":"2021-01-23T00:00:00.000Z","published_on_unix":1611360000}}},{"node":{"number":90,"relative_category":"blog/backend","fields":{"title":"yubinbango-dataをどうやって生成するか","excerpt":"郵便番号から住所を補完するライブラリ「yubinbango」を継続的に利用するにあたり、当該ライブラリが参照している郵便データ「yubinbango-data」を自前でメンテナンスできるか確認します。   > PROBLEMPROBLEM \n\n- 「yubinbango/yubinbango」を利用するにあたり「yubinbango/yubinbango-data」の更新が継続的に行われるかサービス継続性の懸念がある そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい \n- そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい  > SOLUTIONSOLUTION \n\nというわけで、yubinbango-dataの中身であるken_all.csvとjigyosyo.csvを安定して変換する方法を確認します。  > ken_all.csvを正規化するken_all.csvを正規化する \n\nyubinbango-dataのken_all.csvの部分はアイビスが提供しているzipcloudを参照しているようなので、そちらに合わせて利用します。 sh\n\nsudo apt install nkf { curl -sSL \"http://zipcloud.ibsnet.co.jp/zipcodedata/download?di=1625040649647\" -o ./x_ken_all.zip; unzip -p x_ken_all.zip | nkf -w; rm x_ken_all.zip } >ken_all.csv  \n\nzipcloudを使うことに抵抗がある場合はgokenallもありますが、正規化によって一つの郵便番号に複数の町名番地が存在するため郵便番号をキーとするyubinbango-dataに変換する際には工夫が必要です。 sh\n\ngo get github.com/oirik/gokenall/cmd/kenall { kenall download -x | kenall normalize } >ken_all.csv   > jigyosyo.csvを取得するjigyosyo.csvを取得する \n\njigyosyo.csvは特に正規化は必要ないです。 sh\n\n{ curl -sSL https://www.post.japanpost.jp/zipcode/dl/jigyosyo/zip/jigyosyo.zip -o ./jigyosyo.zip; unzip -p jigyosyo.zip | nkf -w; rm jigyosyo.zip } >jigyosyo.csv   > yubinbango-dataを生成するyubinbango-dataを生成する \n\nken_all.csvとjigyosyo.csvをUNIONしてjqで郵便番号をキーとしたオブジェクトに変換します。一部buildingカラムがnullを持っておりyubinbango-dataと異なる部分はありますが、大凡同等の状態にまで持っていくことが出来ました。 sh\n\nbrew install noborus/tap/trdsql for i in {001..999}; do trdsql -ojson \" SELECT * FROM ( SELECT c3 zip, c8 city, c9 town, NULL building FROM ken_all.csv UNION SELECT c8 zip, c5 city, c6 town, c7 building FROM jigyosyo.csv ) WHERE SUBSTRING(zip,0,4) = '$i' ORDER BY zip ASC \" \\ | jq --compact-output ' . | to_entries | map({ (.value.zip): [1, .value.city, .value.town, .value.building] }) | add ' \\ | sed -E 's/(.+?)/$yubin(\\1);/g' \\ >$i.js; done   > WRAPUPWRAPUP \n\n昔から何かと話題に上がるken_all.csvですが、正規化のサービスに加えCSV用SQLクライアントとjqの登場により思った以上に簡単に変換することができました。"},"name":"[2021-07-25]yubinbango-dataをどうやって生成するか","tags":["yubinbango","ken_all.csv","jq","trdsql"],"childPublishedDate":{"published_on":"2021-07-25T00:00:00.000Z","published_on_unix":1627171200}}}]}},"pageContext":{"number":75}},"staticQueryHashes":[]}