{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/75","result":{"data":{"esaPost":{"number":75,"relative_category":"blog/backend","fields":{"title":"CDKで管理する今どきのJenkins","excerpt":"先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。  > PROBLEMPROBLEM \n\n- インフラ系タスクがコード管理されていないので属人化しやすい 可能なら当該タスクはインフラ担当から手離れして欲しい 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- 可能なら当該タスクはインフラ担当から手離れして欲しい\n- 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- ヘルスチェックエラーにひっかかったら自動で再起動してほしい  > SOLUTIONSOLUTION \n\nというわけで、モダンなJenkins2系をAWS CDKで敷設してみました。  > 1. 構成1. 構成 \n\n大方の構成は「nabinno/jenkins-cdk-on-ec2」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。 \n\n使用技術スタック \n\n- Jenkins\n- Amazon ECS（Amazon EC2）\n- Application Load Balancer\n- Amazon EFS   > 2. CDKによるJenkinsの敷設2. CDKによるJenkinsの敷設 \n\nCDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。  > 2-a. CDKの注意点：リソース名を明示する2-a. CDKの注意点：リソース名を明示する \n\nCDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。 \n\n命名規則は「クラスメソッドさんの記事」を参考に決めるのが定番のようです。下記例になります。    AWSリソース 命名規則     ELB {sysname}-{env}-alb/clb   TargetGroup {sysname}-{env}-tg   EC2 {sysname}-{env}-{type}   SecurityGroup {sysname}-{env}-{type}-sg    \n\nCDKでリソース名を明示するには次のいずれかの方法で対応します。 \n\n- 各クラスのコンストラクトプロパティにある名前を記述する\n- 暗黙的生成されるリソースを明示的に作成する \n\n下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。 ts\n\n// ECS: Service const serviceSecGrp = new ec2.SecurityGroup(this, \"JenkinsMasterServiceSecGrp\", { securityGroupName: \"jenkins-production-master-sg\", vpc: network.vpc, allowAllOutbound: true, }); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(50000), \"from JenkinsWorkerSecurityGroup 50000\"); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(8080), \"from JenkinsWorkerSecurityGroup 8080\"); const jenkinsMasterService = new ecs.Ec2Service(this, \"EC2MasterService\", { serviceName: 'jenkins-production-master-svc', taskDefinition: jenkinsMasterTask, cloudMapOptions: { name: \"master\", dnsRecordType: sd.DnsRecordType.A }, desiredCount: 1, minHealthyPercent: 0, maxHealthyPercent: 100, enableECSManagedTags: true, cluster: ecsCluster.cluster, securityGroups: [serviceSecGrp] });  \n\nなお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。  > 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける \n\nネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるのでcdk.RemovablePolicy.RETAIN、CFnの言うところの \"DeletionPolicy\": \"Retain\" をつけましょう。今回はEFSがその対象になります。 ts\n\nconst efsFilesystem = new efs.CfnFileSystem(this, \"EFSBackend\"); efsFilesystem.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);  \n\n個人的にはRETAINをつけるとcdk destroy cdk deployを気軽に行えなくなるので、RETAINをつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。  > 3. Jenkinsの設定を行う3. Jenkinsの設定を行う \n\nCDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。  > 3-a. Jenkinsでつかっているプラグイン3-a. Jenkinsでつかっているプラグイン \n\n昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。 \n\n- github-oauth\n- role-strategy\n- configuration-as-code\n- blueocean \n\nざっと説明するとgithub-oauthでGitHub認証させ、role-strategyでロールごとの権限付与を行い、configuration-as-codeでそれらの管理設定をコード化します。configuration-as-codeは素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、blueoceanはモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。 \n\nなお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。 sh\n\n$ cat plugins.txt role-strategy:3.1 github-oauth:0.33 thinBackup:1.10 git:4.6.0 authorize-project:1.3.0 configuration-as-code:1.47 blueocean:1.24.4 $ cat Dockerfile [...] COPY plugins.txt /usr/share/jenkins/ref/plugins.txt RUN /usr/local/bin/install-plugins.sh < /usr/share/jenkins/ref/plugins.txt [...]   > 3-b. JenkinsジョブをGitHubで管理する3-b. JenkinsジョブをGitHubで管理する \n\nいよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。 \n\n1. ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、Jenkinsfile を配置\n2. 「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう Where do you store your code? - GitHub Which organization does the repository belong to? - 任意のuserあるいはorganization Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n3. Where do you store your code? - GitHub\n4. Which organization does the repository belong to? - 任意のuserあるいはorganization\n5. Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n\nJenkinsfile の作成方法は「ユーザーハンドブック」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。 Jenkinsfile\n\n pipeline { agent any stages { stage('Show env') { steps { sh '''mysql --version ls -al bin env | sort''' } } stage('Run script') { steps { git(url: 'https://github.com/nabinno/jenkins-jobs', branch: 'master', credentialsId: 'github') sh '''git diff sync-db-from-staging-to-integration | patch -p1 -R -f bin/sync_db_from_staging_to_integration''' } } } environment { STAG_DB_DATABASE = credentials('STAG_DB_DATABASE') STAG_DB_HOSTNAME = credentials('STAG_DB_HOSTNAME') STAG_DB_PASSWORD = credentials('STAG_DB_PASSWORD') STAG_DB_USERNAME = credentials('STAG_DB_USERNAME') INTEG_DB_HOSTNAME = credentials('INTEG_DB_HOSTNAME') INTEG_DB_PASSWORD = credentials('INTEG_DB_PASSWORD') INTEG_DB_USERNAME = credentials('INTEG_DB_USERNAME') INTEG_DB_DATABASE = credentials('INTEG_DB_USERNAME') } }   > WRAPUPWRAPUP \n\n今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。 \n\n1. CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。\n2. Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg"},"wip":false,"body_md":"<img width=\"1280\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\">\r\n\r\n\r\n先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。\r\n\r\n# PROBLEM\r\n- インフラ系タスクがコード管理されていないので属人化しやすい\r\n    - 可能なら当該タスクはインフラ担当から手離れして欲しい\r\n    - 当該タスクは通常のCIワークフローとは異なるので管理する場所がない\r\n        - そういう意味でJenkinsの出番だけどこれはこれで管理が手間\r\n            - ヘルスチェックエラーにひっかかったら自動で再起動してほしい\r\n\r\n# SOLUTION\r\nというわけで、モダンなJenkins2系をAWS CDKで敷設してみました。\r\n\r\n## 1. 構成\r\n大方の構成は「[nabinno/jenkins-cdk-on-ec2](https://github.com/nabinno/jenkins-cdk-on-ec2)」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。\r\n\r\n使用技術スタック\r\n- Jenkins\r\n- Amazon ECS（Amazon EC2）\r\n- Application Load Balancer\r\n- Amazon EFS\r\n\r\n<img width=\"1640\" alt=\"\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\">\r\n\r\n## 2. CDKによるJenkinsの敷設\r\nCDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。\r\n\r\n### 2-a. CDKの注意点：リソース名を明示する\r\nCDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。\r\n\r\n命名規則は「[クラスメソッドさんの記事](https://dev.classmethod.jp/articles/aws-name-rule/)」を参考に決めるのが定番のようです。下記例になります。\r\n\r\n| AWSリソース | 命名規則 |\r\n| --- | --- |\r\n| ELB | {sysname}-{env}-alb/clb |\r\n| TargetGroup | {sysname}-{env}-tg |\r\n| EC2 | {sysname}-{env}-{type} |\r\n| SecurityGroup | {sysname}-{env}-{type}-sg |\r\n\r\nCDKでリソース名を明示するには次のいずれかの方法で対応します。\r\n- 各クラスのコンストラクトプロパティにある名前を記述する\r\n- 暗黙的生成されるリソースを明示的に作成する\r\n\r\n下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。\r\n\r\n```ts\r\n// ECS: Service\r\nconst serviceSecGrp = new ec2.SecurityGroup(this, \"JenkinsMasterServiceSecGrp\", {\r\n  securityGroupName: \"jenkins-production-master-sg\",\r\n  vpc: network.vpc,\r\n  allowAllOutbound: true,\r\n});\r\nserviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(50000), \"from JenkinsWorkerSecurityGroup 50000\");\r\nserviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(8080), \"from JenkinsWorkerSecurityGroup 8080\");\r\n\r\nconst jenkinsMasterService = new ecs.Ec2Service(this, \"EC2MasterService\", {\r\n  serviceName: 'jenkins-production-master-svc',\r\n  taskDefinition: jenkinsMasterTask,\r\n  cloudMapOptions: { name: \"master\", dnsRecordType: sd.DnsRecordType.A },\r\n  desiredCount: 1,\r\n  minHealthyPercent: 0,\r\n  maxHealthyPercent: 100,\r\n  enableECSManagedTags: true,\r\n  cluster: ecsCluster.cluster,\r\n  securityGroups: [serviceSecGrp]\r\n});\r\n```\r\n\r\nなお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。\r\n\r\n### 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\r\nネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるので`cdk.RemovablePolicy.RETAIN`、CFnの言うところの `\"DeletionPolicy\": \"Retain\"` をつけましょう。今回はEFSがその対象になります。\r\n\r\n```ts\r\nconst efsFilesystem = new efs.CfnFileSystem(this, \"EFSBackend\");\r\nefsFilesystem.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);\r\n```\r\n\r\n個人的には`RETAIN`をつけると`cdk destroy` `cdk deploy`を気軽に行えなくなるので、`RETAIN`をつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。\r\n\r\n## 3. Jenkinsの設定を行う\r\nCDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。\r\n\r\n### 3-a. Jenkinsでつかっているプラグイン\r\n昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。\r\n\r\n- github-oauth\r\n- role-strategy\r\n- configuration-as-code\r\n- blueocean\r\n\r\nざっと説明すると`github-oauth`でGitHub認証させ、`role-strategy`でロールごとの権限付与を行い、`configuration-as-code`でそれらの管理設定をコード化します。`configuration-as-code`は素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、`blueocean`はモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。\r\n\r\nなお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。\r\n\r\n```sh\r\n$ cat plugins.txt\r\nrole-strategy:3.1\r\ngithub-oauth:0.33\r\nthinBackup:1.10\r\ngit:4.6.0\r\nauthorize-project:1.3.0\r\nconfiguration-as-code:1.47\r\nblueocean:1.24.4\r\n\r\n$ cat Dockerfile\r\n[...]\r\nCOPY plugins.txt /usr/share/jenkins/ref/plugins.txt\r\nRUN /usr/local/bin/install-plugins.sh < /usr/share/jenkins/ref/plugins.txt\r\n[...]\r\n```\r\n\r\n###  3-b. JenkinsジョブをGitHubで管理する\r\nいよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。\r\n\r\n1. ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、`Jenkinsfile` を配置\r\n1. 「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう\r\n    - Where do you store your code?\t- GitHub\r\n    - Which organization does the repository belong to?\t- 任意のuserあるいはorganization\r\n    - Choose a repository - 任意のレポジトリ（1で作成したレポジトリ）\r\n\r\n`Jenkinsfile` の作成方法は「[ユーザーハンドブック](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/)」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。\r\n\r\n```Jenkinsfile\r\n  \r\npipeline {\r\n  agent any\r\n  stages {\r\n    stage('Show env') {\r\n      steps {\r\n        sh '''mysql --version\r\nls -al bin\r\nenv  | sort'''\r\n      }\r\n    }\r\n\r\n    stage('Run script') {\r\n      steps {\r\n        git(url: 'https://github.com/nabinno/jenkins-jobs', branch: 'master', credentialsId: 'github')\r\n        sh '''git diff sync-db-from-staging-to-integration | patch -p1 -R -f\r\nbin/sync_db_from_staging_to_integration'''\r\n      }\r\n    }\r\n\r\n  }\r\n  environment {\r\n    STAG_DB_DATABASE = credentials('STAG_DB_DATABASE')\r\n    STAG_DB_HOSTNAME = credentials('STAG_DB_HOSTNAME')\r\n    STAG_DB_PASSWORD = credentials('STAG_DB_PASSWORD')\r\n    STAG_DB_USERNAME = credentials('STAG_DB_USERNAME')\r\n    INTEG_DB_HOSTNAME = credentials('INTEG_DB_HOSTNAME')\r\n    INTEG_DB_PASSWORD = credentials('INTEG_DB_PASSWORD')\r\n    INTEG_DB_USERNAME = credentials('INTEG_DB_USERNAME')\r\n    INTEG_DB_DATABASE = credentials('INTEG_DB_USERNAME')\r\n  }\r\n}\r\n```\r\n\r\n# WRAPUP\r\n今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。\r\n\r\n1. CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。\r\n2. Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1280\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/8b15133e-d01d-4e15-9565-af5131404776.jpg\"></a>\n<p data-sourcepos=\"4:1-4:286\">先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。</p>\n<h1 data-sourcepos=\"6:1-6:9\" id=\"1-0-0\" name=\"1-0-0\"><a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"7:1-12:0\">\n<li data-sourcepos=\"7:1-12:0\">インフラ系タスクがコード管理されていないので属人化しやすい\n<ul data-sourcepos=\"8:5-12:0\">\n<li data-sourcepos=\"8:5-8:84\">可能なら当該タスクはインフラ担当から手離れして欲しい</li>\n<li data-sourcepos=\"9:5-12:0\">当該タスクは通常のCIワークフローとは異なるので管理する場所がない\n<ul data-sourcepos=\"10:9-12:0\">\n<li data-sourcepos=\"10:9-12:0\">そういう意味でJenkinsの出番だけどこれはこれで管理が手間\n<ul data-sourcepos=\"11:13-12:0\">\n<li data-sourcepos=\"11:13-12:0\">ヘルスチェックエラーにひっかかったら自動で再起動してほしい</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<h1 data-sourcepos=\"13:1-13:10\" id=\"2-0-0\" name=\"2-0-0\"><a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"14:1-14:84\">というわけで、モダンなJenkins2系をAWS CDKで敷設してみました。</p>\n<h2 data-sourcepos=\"16:1-16:12\" id=\"2-1-0\" name=\"2-1-0\"><a class=\"anchor\" id=\"1. 構成\" name=\"1. 構成\" href=\"#1. 構成\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. 構成\"> &gt; 1. 構成</span></a>1. 構成</h2>\n<p data-sourcepos=\"17:1-17:287\">大方の構成は「<a href=\"https://github.com/nabinno/jenkins-cdk-on-ec2\" target=\"_blank\" rel=\"noopener noreferrer\">nabinno/jenkins-cdk-on-ec2</a>」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。</p>\n<p data-sourcepos=\"19:1-19:24\">使用技術スタック</p>\n<ul data-sourcepos=\"20:1-24:0\">\n<li data-sourcepos=\"20:1-20:9\">Jenkins</li>\n<li data-sourcepos=\"21:1-21:28\">Amazon ECS（Amazon EC2）</li>\n<li data-sourcepos=\"22:1-22:27\">Application Load Balancer</li>\n<li data-sourcepos=\"23:1-24:0\">Amazon EFS</li>\n</ul>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1640\" alt=\"\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/02/23/97367/b442f0d3-3e87-4519-8a06-bbb54a89a175.png\"></a>\n<h2 data-sourcepos=\"27:1-27:34\" id=\"2-2-0\" name=\"2-2-0\"><a class=\"anchor\" id=\"2. CDKによるJenkinsの敷設\" name=\"2. CDKによるJenkinsの敷設\" href=\"#2. CDKによるJenkinsの敷設\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. CDKによるJenkinsの敷設\"> &gt; 2. CDKによるJenkinsの敷設</span></a>2. CDKによるJenkinsの敷設</h2>\n<p data-sourcepos=\"28:1-28:170\">CDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。</p>\n<h3 data-sourcepos=\"30:1-30:57\" id=\"2-2-1\" name=\"2-2-1\"><a class=\"anchor\" id=\"2-a. CDKの注意点：リソース名を明示する\" name=\"2-a. CDKの注意点：リソース名を明示する\" href=\"#2-a. CDKの注意点：リソース名を明示する\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2-a. CDKの注意点：リソース名を明示する\"> &gt; 2-a. CDKの注意点：リソース名を明示する</span></a>2-a. CDKの注意点：リソース名を明示する</h3>\n<p data-sourcepos=\"31:1-31:416\">CDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。</p>\n<p data-sourcepos=\"33:1-33:189\">命名規則は「<a href=\"https://dev.classmethod.jp/articles/aws-name-rule/\" target=\"_blank\" rel=\"noopener noreferrer\">クラスメソッドさんの記事</a>」を参考に決めるのが定番のようです。下記例になります。</p>\n<table data-sourcepos=\"35:1-40:45\">\n<thead>\n<tr data-sourcepos=\"35:1-35:34\">\n<th data-sourcepos=\"35:2-35:18\">AWSリソース</th>\n<th data-sourcepos=\"35:20-35:33\">命名規則</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"37:1-37:33\">\n<td data-sourcepos=\"37:2-37:6\">ELB</td>\n<td data-sourcepos=\"37:8-37:32\">{sysname}-{env}-alb/clb</td>\n</tr>\n<tr data-sourcepos=\"38:1-38:36\">\n<td data-sourcepos=\"38:2-38:14\">TargetGroup</td>\n<td data-sourcepos=\"38:16-38:35\">{sysname}-{env}-tg</td>\n</tr>\n<tr data-sourcepos=\"39:1-39:32\">\n<td data-sourcepos=\"39:2-39:6\">EC2</td>\n<td data-sourcepos=\"39:8-39:31\">{sysname}-{env}-{type}</td>\n</tr>\n<tr data-sourcepos=\"40:1-40:45\">\n<td data-sourcepos=\"40:2-40:16\">SecurityGroup</td>\n<td data-sourcepos=\"40:18-40:44\">{sysname}-{env}-{type}-sg</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"42:1-42:90\">CDKでリソース名を明示するには次のいずれかの方法で対応します。</p>\n<ul data-sourcepos=\"43:1-45:0\">\n<li data-sourcepos=\"43:1-43:83\">各クラスのコンストラクトプロパティにある名前を記述する</li>\n<li data-sourcepos=\"44:1-45:0\">暗黙的生成されるリソースを明示的に作成する</li>\n</ul>\n<p data-sourcepos=\"46:1-46:134\">下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。</p>\n<div class=\"code-block\" data-sourcepos=\"48:1-69:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>ts</div><div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"c1\">// ECS: Service</span>\n<span class=\"kd\">const</span> <span class=\"nx\">serviceSecGrp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">SecurityGroup</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">JenkinsMasterServiceSecGrp</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n  <span class=\"na\">securityGroupName</span><span class=\"p\">:</span> <span class=\"dl\">\"</span><span class=\"s2\">jenkins-production-master-sg</span><span class=\"dl\">\"</span><span class=\"p\">,</span>\n  <span class=\"na\">vpc</span><span class=\"p\">:</span> <span class=\"nx\">network</span><span class=\"p\">.</span><span class=\"nx\">vpc</span><span class=\"p\">,</span>\n  <span class=\"na\">allowAllOutbound</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">serviceSecGrp</span><span class=\"p\">.</span><span class=\"nx\">addIngressRule</span><span class=\"p\">(</span><span class=\"nx\">worker</span><span class=\"p\">.</span><span class=\"nx\">workerSecurityGroup</span><span class=\"p\">,</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">Port</span><span class=\"p\">.</span><span class=\"nx\">tcp</span><span class=\"p\">(</span><span class=\"mi\">50000</span><span class=\"p\">),</span> <span class=\"dl\">\"</span><span class=\"s2\">from JenkinsWorkerSecurityGroup 50000</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n<span class=\"nx\">serviceSecGrp</span><span class=\"p\">.</span><span class=\"nx\">addIngressRule</span><span class=\"p\">(</span><span class=\"nx\">worker</span><span class=\"p\">.</span><span class=\"nx\">workerSecurityGroup</span><span class=\"p\">,</span> <span class=\"nx\">ec2</span><span class=\"p\">.</span><span class=\"nx\">Port</span><span class=\"p\">.</span><span class=\"nx\">tcp</span><span class=\"p\">(</span><span class=\"mi\">8080</span><span class=\"p\">),</span> <span class=\"dl\">\"</span><span class=\"s2\">from JenkinsWorkerSecurityGroup 8080</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">jenkinsMasterService</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ecs</span><span class=\"p\">.</span><span class=\"nx\">Ec2Service</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">EC2MasterService</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n  <span class=\"na\">serviceName</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">jenkins-production-master-svc</span><span class=\"dl\">'</span><span class=\"p\">,</span>\n  <span class=\"na\">taskDefinition</span><span class=\"p\">:</span> <span class=\"nx\">jenkinsMasterTask</span><span class=\"p\">,</span>\n  <span class=\"na\">cloudMapOptions</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">\"</span><span class=\"s2\">master</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"na\">dnsRecordType</span><span class=\"p\">:</span> <span class=\"nx\">sd</span><span class=\"p\">.</span><span class=\"nx\">DnsRecordType</span><span class=\"p\">.</span><span class=\"nx\">A</span> <span class=\"p\">},</span>\n  <span class=\"na\">desiredCount</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"na\">minHealthyPercent</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n  <span class=\"na\">maxHealthyPercent</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n  <span class=\"na\">enableECSManagedTags</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n  <span class=\"na\">cluster</span><span class=\"p\">:</span> <span class=\"nx\">ecsCluster</span><span class=\"p\">.</span><span class=\"nx\">cluster</span><span class=\"p\">,</span>\n  <span class=\"na\">securityGroups</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"nx\">serviceSecGrp</span><span class=\"p\">]</span>\n<span class=\"p\">});</span>\n</code></pre></div></div>\n<p data-sourcepos=\"71:1-71:457\">なお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。</p>\n<h3 data-sourcepos=\"73:1-73:65\" id=\"2-2-2\" name=\"2-2-2\"><a class=\"anchor\" id=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" name=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" href=\"#2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける\"> &gt; 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける</span></a>2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける</h3>\n<p data-sourcepos=\"74:1-74:304\">ネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるので<code>cdk.RemovablePolicy.RETAIN</code>、CFnの言うところの <code>\"DeletionPolicy\": \"Retain\"</code> をつけましょう。今回はEFSがその対象になります。</p>\n<div class=\"code-block\" data-sourcepos=\"76:1-79:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>ts</div><div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"kd\">const</span> <span class=\"nx\">efsFilesystem</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">efs</span><span class=\"p\">.</span><span class=\"nx\">CfnFileSystem</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">EFSBackend</span><span class=\"dl\">\"</span><span class=\"p\">);</span>\n<span class=\"nx\">efsFilesystem</span><span class=\"p\">.</span><span class=\"nx\">applyRemovalPolicy</span><span class=\"p\">(</span><span class=\"nx\">cdk</span><span class=\"p\">.</span><span class=\"nx\">RemovalPolicy</span><span class=\"p\">.</span><span class=\"nx\">RETAIN</span><span class=\"p\">);</span>\n</code></pre></div></div>\n<p data-sourcepos=\"81:1-81:217\">個人的には<code>RETAIN</code>をつけると<code>cdk destroy</code> <code>cdk deploy</code>を気軽に行えなくなるので、<code>RETAIN</code>をつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。</p>\n<h2 data-sourcepos=\"83:1-83:31\" id=\"2-3-0\" name=\"2-3-0\"><a class=\"anchor\" id=\"3. Jenkinsの設定を行う\" name=\"3. Jenkinsの設定を行う\" href=\"#3. Jenkinsの設定を行う\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. Jenkinsの設定を行う\"> &gt; 3. Jenkinsの設定を行う</span></a>3. Jenkinsの設定を行う</h2>\n<p data-sourcepos=\"84:1-84:83\">CDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。</p>\n<h3 data-sourcepos=\"86:1-86:52\" id=\"2-3-1\" name=\"2-3-1\"><a class=\"anchor\" id=\"3-a. Jenkinsでつかっているプラグイン\" name=\"3-a. Jenkinsでつかっているプラグイン\" href=\"#3-a. Jenkinsでつかっているプラグイン\" data-position=\"2-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3-a. Jenkinsでつかっているプラグイン\"> &gt; 3-a. Jenkinsでつかっているプラグイン</span></a>3-a. Jenkinsでつかっているプラグイン</h3>\n<p data-sourcepos=\"87:1-87:91\">昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。</p>\n<ul data-sourcepos=\"89:1-93:0\">\n<li data-sourcepos=\"89:1-89:14\">github-oauth</li>\n<li data-sourcepos=\"90:1-90:15\">role-strategy</li>\n<li data-sourcepos=\"91:1-91:23\">configuration-as-code</li>\n<li data-sourcepos=\"92:1-93:0\">blueocean</li>\n</ul>\n<p data-sourcepos=\"94:1-94:515\">ざっと説明すると<code>github-oauth</code>でGitHub認証させ、<code>role-strategy</code>でロールごとの権限付与を行い、<code>configuration-as-code</code>でそれらの管理設定をコード化します。<code>configuration-as-code</code>は素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、<code>blueocean</code>はモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。</p>\n<p data-sourcepos=\"96:1-96:105\">なお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。</p>\n<div class=\"code-block\" data-sourcepos=\"98:1-113:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>sh</div><div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">cat </span>plugins.txt\nrole-strategy:3.1\ngithub-oauth:0.33\nthinBackup:1.10\ngit:4.6.0\nauthorize-project:1.3.0\nconfiguration-as-code:1.47\nblueocean:1.24.4\n\n<span class=\"nv\">$ </span><span class=\"nb\">cat </span>Dockerfile\n<span class=\"o\">[</span>...]\nCOPY plugins.txt /usr/share/jenkins/ref/plugins.txt\nRUN /usr/local/bin/install-plugins.sh &lt; /usr/share/jenkins/ref/plugins.txt\n<span class=\"o\">[</span>...]\n</code></pre></div></div>\n<h3 data-sourcepos=\"115:1-115:50\" id=\"2-3-2\" name=\"2-3-2\"><a class=\"anchor\" id=\"3-b. JenkinsジョブをGitHubで管理する\" name=\"3-b. JenkinsジョブをGitHubで管理する\" href=\"#3-b. JenkinsジョブをGitHubで管理する\" data-position=\"2-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3-b. JenkinsジョブをGitHubで管理する\"> &gt; 3-b. JenkinsジョブをGitHubで管理する</span></a>3-b. JenkinsジョブをGitHubで管理する</h3>\n<p data-sourcepos=\"116:1-116:233\">いよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。</p>\n<ol data-sourcepos=\"118:1-123:0\">\n<li data-sourcepos=\"118:1-118:128\">ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、<code>Jenkinsfile</code> を配置</li>\n<li data-sourcepos=\"119:1-123:0\">「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう\n<ul data-sourcepos=\"120:5-123:0\">\n<li data-sourcepos=\"120:5-120:44\">Where do you store your code?\t- GitHub</li>\n<li data-sourcepos=\"121:5-121:95\">Which organization does the repository belong to?\t- 任意のuserあるいはorganization</li>\n<li data-sourcepos=\"122:5-123:0\">Choose a repository - 任意のレポジトリ（1で作成したレポジトリ）</li>\n</ul>\n</li>\n</ol>\n<p data-sourcepos=\"124:1-124:369\"><code>Jenkinsfile</code> の作成方法は「<a href=\"https://www.jenkins.io/doc/book/pipeline/jenkinsfile/\" target=\"_blank\" rel=\"noopener noreferrer\">ユーザーハンドブック</a>」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。</p>\n<div class=\"code-block\" data-sourcepos=\"126:1-159:3\"><div class=\"code-filename\"><i class=\"fa fa-file-code-o\"></i>Jenkinsfile</div><div class=\"highlight\"><pre class=\"highlight groovy\"><code>  \n<span class=\"n\">pipeline</span> <span class=\"o\">{</span>\n  <span class=\"n\">agent</span> <span class=\"n\">any</span>\n  <span class=\"n\">stages</span> <span class=\"o\">{</span>\n    <span class=\"n\">stage</span><span class=\"o\">(</span><span class=\"s1\">'Show env'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">steps</span> <span class=\"o\">{</span>\n        <span class=\"n\">sh</span> <span class=\"s1\">'''mysql --version\nls -al bin\nenv  | sort'''</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">stage</span><span class=\"o\">(</span><span class=\"s1\">'Run script'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">steps</span> <span class=\"o\">{</span>\n        <span class=\"n\">git</span><span class=\"o\">(</span><span class=\"nl\">url:</span> <span class=\"s1\">'https://github.com/nabinno/jenkins-jobs'</span><span class=\"o\">,</span> <span class=\"nl\">branch:</span> <span class=\"s1\">'master'</span><span class=\"o\">,</span> <span class=\"nl\">credentialsId:</span> <span class=\"s1\">'github'</span><span class=\"o\">)</span>\n        <span class=\"n\">sh</span> <span class=\"s1\">'''git diff sync-db-from-staging-to-integration | patch -p1 -R -f\nbin/sync_db_from_staging_to_integration'''</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"o\">}</span>\n  <span class=\"n\">environment</span> <span class=\"o\">{</span>\n    <span class=\"n\">STAG_DB_DATABASE</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_DATABASE'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_HOSTNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_HOSTNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_PASSWORD</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_PASSWORD'</span><span class=\"o\">)</span>\n    <span class=\"n\">STAG_DB_USERNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'STAG_DB_USERNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_HOSTNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_HOSTNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_PASSWORD</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_PASSWORD'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_USERNAME</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_USERNAME'</span><span class=\"o\">)</span>\n    <span class=\"n\">INTEG_DB_DATABASE</span> <span class=\"o\">=</span> <span class=\"n\">credentials</span><span class=\"o\">(</span><span class=\"s1\">'INTEG_DB_USERNAME'</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<h1 data-sourcepos=\"161:1-161:8\" id=\"3-0-0\" name=\"3-0-0\"><a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"162:1-162:238\">今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。</p>\n<ol data-sourcepos=\"164:1-165:184\">\n<li data-sourcepos=\"164:1-164:237\">CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。</li>\n<li data-sourcepos=\"165:1-165:184\">Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。</li>\n</ol>\n","tags":["aws-cdk","jenkins","amazon-ecs"],"updated_at":"2021-07-25T12:08:47+09:00","childPublishedDate":{"published_on":"2021-02-24T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":91,"relative_category":"blog/backend","fields":{"title":"Hardware-Accelerated GPU Scheduling機能を使ったWSL2はどのくらいパフォーマンスが向上するか","excerpt":"新しいPC端末を購入したところ「Hardware-Accerlarated GPU Scheduling」機能があることに気づきました。使用したところ気持ち速くなったように感じたのでどのくらいパフォーマンスが向上したか調べてみました。   > PROBLEMPROBLEM \n\n- システム設定で「Hardware-Accerlarated GPU Scheduling（HAGS）」機能を使ったところWSL2のパフォーマンスが体感的に速くなったように感じた 他の端末にもHAGSを展開していきたいので実際にどのらくらいパフォーマンスが向上するか検証したい \n- 他の端末にもHAGSを展開していきたいので実際にどのらくらいパフォーマンスが向上するか検証したい  > SOLUTIONSOLUTION \n\nと言うわけで、以前Phoronixによって書かれた「WSLとWSL2とのベンチマーク比較の記事」を参考にPhoronix Test SuiteでHAGSのオン・オフのベンチマーク比較を行います。  > 検証端末の環境検証端末の環境    Item Content     Processor AMD Ryzen 9 5900X 12-Core (12 Cores / 24 Threads)   Memory 52 GB   Disk 2 x 275GB Virtual Disk   OS Ubuntu 20.04   Kernel 5.4.72-microsoft-standard-WSL2 (x86_64)   Display Server X Server   Compiler GCC 9.3.0   File System ext4   System Layer wsl     > Phoronix Test SuiteをインストールするPhoronix Test Suiteをインストールする sh\n\nbrew install phoronix-test-suite sudo apt install php php-gd php-xml php-curl   > 実行するベンチマークテストを選定する実行するベンチマークテストを選定する \n\nまず実行可能なテストとテストスーツを確認します、テストスーツは関連テストのグループになります。 sh\n\nphoronix-test-suite list-available-tests phoronix-test-suite list-available-suite  \n\n今回は開発する際に関係がある下記のテストを選定しました。テストスーツは数時間では完了しないケースがあったので今回の対象から外しています。 \n\n- pts/build-gcc\n- pts/compress-gzip\n- pts/system-decompress-gzip\n- pts/gnupg\n- pts/mutex\n- pts/openssl\n- pts/git\n- pts/pybench\n- pts/nginx\n- pts/node-web-tooling  > ベンチマーク結果ベンチマーク結果    Item HAGSオン HAGSオフ     pts/build-gcc 717.39 sec 715.56 sec   pts/compress-gzip 29.10 sec 29.36 sec   pts/system-decompress-gzip 2.397 sec 2.427 sec   pts/mutex Lock Shared 15.2 sec 15.2 sec   pts/mutex Unlock spinlock 33.1 sec 33.4 sec   pts/mutex Unlock std::mutex 14.8 sec 14.7 sec   pts/mutex Semaphore Release And Acquire 8.44 sec 8.36 sec   pts/mutex Unlock pthread_mutex 8.45 sec 8.34 sec   pts/openssl 3704.3 sign/sec 3694 sign/sec   pts/git 39.01 sec 38.85 sec   pts/pybench 869 msec 877 msec   pts/nginx 70124.29 req/sec 71919.70 req/sec   pts/node-web-tooling 16.71 sec 17.01 sec     > WRAPUPWRAPUP \n\n残念ながらベンチマーク結果からHAGSのオンとオフの間に大きなパフォーマンスの変化は見られませんでした。通常の開発の場合はほぼ恩恵を受けられないと言って問題ないでしょう。 \n\n結論として、他の端末へのHAGSの展開はお薦めしません。不具合等の口コミも散見されるので使用端末との相性を見ながら導入するのが良さそうです。個人的にはChromeのハードウェアアクセラレーション機能との相性を見つつしばらく運用しようと思います。"},"name":"[2021-08-01]Hardware-Accelerated GPU Scheduling機能を使ったWSL2はどのくらいパフォーマンスが向上するか","tags":[],"childPublishedDate":{"published_on":"2021-08-01T00:00:00.000Z","published_on_unix":1627776000}}},{"node":{"number":89,"relative_category":"blog/backend","fields":{"title":"imi-enrichment-addressは住所のバリデーションチェックでどの程度使えるか","excerpt":"コロナ禍であらゆる流通がオンラインに移行する中、正しい住所を使うことはいっそう求められています。ユーザーが配送用に住所を入力する時そのデータが正しいとどうやって判定するのでしょうか。今回はOSSライブラリimi-enrichment-addressが住所のバリデーションチェックでどの程度使えるか検証してみました。   > PROBLEMPROBLEM \n\n- 住所の不備が至るところで起きている 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい まずはOSSのライブラリで検証したい \n- 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい\n- 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい まずはOSSのライブラリで検証したい \n- まずはOSSのライブラリで検証したい  > SOLUTIONSOLUTION \n\nというわけで、昨年（2020年）経産省IMI（情報共有基盤）から公開された住所変換コンポーネント「IMI-Tool-Project/imi-enrichment-address」がバリデーションチェックでどの程度使えるか検証します。  > imi-enrichment-addressとはimi-enrichment-addressとは \n\n経産省IMIツールプロジェクトで公開された住所変換コンポーネントです。CLIとサーバーが用意されていますが、今回はCLIを見ていきます。 \n\nヘルプを見ると住所を引数として渡すことで処理されることが分かります。 sh\n\n$ npm install -g https://info.gbiz.go.jp/tools/imi_tools/resource/imi-enrichment-address/imi-enrichment-address-2.0.0.tgz $ imi-enrichment-address --help imi-enrichment-address 住所文字列をもとに住所型・場所型の情報を補完します オプション -h, --help このヘルプを表示します -f, --file file 変換対象とする JSON ファイル -s, --string string 変換対象とする住所文字列 -i, --indent number 出力する JSON のインデント (default 2) 実行例 ヘルプの表示 $ imi-enrichment-address -h 文字列の処理 $ imi-enrichment-address -s 霞が関2 ファイルの処理 $ imi-enrichment-address input.json 標準入力の処理 $ cat input.json | imi-enrichment-address  \n\n実行すると正確な住所を渡したときと不正確な住所を渡したときで異なった結果を返すことが分かります。今回はこの正確・不正確の異なった結果を利用して検証していこうと思います。 sh\n\n$ imi-enrichment-address -s 長野県長野市大字長野旭町1108 { \"@context\": \"https://imi.go.jp/ns/core/context.jsonld\", \"@type\": \"場所型\", \"住所\": { \"@type\": \"住所型\", \"表記\": \"長野県長野市大字長野旭町1108\", \"都道府県\": \"長野県\", \"都道府県コード\": \"http://data.e-stat.go.jp/lod/sac/C20000\", \"市区町村\": \"長野市\", \"市区町村コード\": \"http://data.e-stat.go.jp/lod/sac/C20201\", \"町名\": \"大字長野\" }, \"地理座標\": { \"@type\": \"座標型\", \"緯度\": \"36.674892\", \"経度\": \"138.178449\" } } $ imi-enrichment-address -s 長野県長野市旭町1108 { \"@context\": \"https://imi.go.jp/ns/core/context.jsonld\", \"@type\": \"場所型\", \"住所\": { \"@type\": \"住所型\", \"表記\": \"長野県長野市旭町1108\", \"都道府県\": \"長野県\", \"都道府県コード\": \"http://data.e-stat.go.jp/lod/sac/C20000\", \"市区町村\": \"長野市\", \"市区町村コード\": \"http://data.e-stat.go.jp/lod/sac/C20201\" }, \"メタデータ\": { \"@type\": \"文書型\", \"説明\": \"該当する町名が見つかりません\" } }  \n\nなお、GitHubコードを見るとimi-enrichment-addressは街区レベル位置参照情報を利用して実装しています。このことを考えるとバリデーションチェックで積極的につかうのは難しく、ユースケースとしては下記2点に落ち着くと考えます。 \n\n- ユーザーに住所の再確認を促す\n- 入力後の住所不備について人が目検で確認する前段階で利用  > 検証用データ検証用データ \n\nさて、検証に進みましょう。imi-enrichment-addressで検証するデータは簡易に使える住所.jp、その中の事業所住所22402件を使います。他にも検証データはありますが、コストもそれほどかけられないのでコマンドだけで完結するものを選んでいます。 sh\n\n$ curl -sSL http://jusyo.jp/downloads/new/csv/csv_zenkoku.zip -o csv_zenkoku.zip $ unzip csv_zenkoku.zip $ go get github.com/mithrandie/csvq $ csvq -f CSV \"SELECT COUNT(*) FROM zenkoku WHERE 事業所住所 IS NOT NULL\" COUNT(*) 22402   > imi-enrichment-addressで検証用データを確認するimi-enrichment-addressで検証用データを確認する \n\n今回実行したCLIはNodeJSであることと数時間で処理できるという点で逐次で済ませました。 sh\n\n$ for i in $( csvq -f CSV \"SELECT 都道府県,市区町村,事業所住所 FROM zenkoku WHERE 事業所住所 IS NOT NULL\" \\ | sed 's/,//g' \\ | tail +2 \\ ); do imi-enrichment-address -s $i \\ | jq -r ' [ .[\"住所\"][\"表記\"], ( if .[\"地理座標\"] != null then true else false end ), .[\"メタデータ\"][\"説明\"] ] | @csv ' >>output.csv; done &   > バリデーションチェックの結果を確認するバリデーションチェックの結果を確認する \n\nimi-enrichment-addressの出力結果を確認したところ全国で9.25%が無効、下記の通り町名番地の表記揺れに弱いことが分かりました。特に町字（まちあざ）省略によるバリデーションエラーの比率が高く、青森、長野、沖縄等複数の県の住所が実用に耐えない結果となりました。 \n\nバリデーションエラーになった原因 \n\n- 各地方の字・大字の省略\n- 京都の通り上る・下るの表記\n- 北海道の条、線の表記揺れ\n- 茨城、岐阜等の町名省略\n- 茨城、神奈川、岐阜、石川等の区画整理地    都道府県 無効割合（%） 備考     青森県 54.42 字省略により無効   長野県 44.28 字省略により無効   沖縄県 43.55 字省略により無効   大分県 38.96 字省略により無効   京都府 36.86 字省略、通りにより無効   佐賀県 33.33 字省略により無効   奈良県 29.94 字省略により無効   福島県 29.18 字省略により無効   宮崎県 27.71 字省略により無効   埼玉県 23.08 字省略により無効   山口県 22.65 字省略により無効   和歌山県 17.78 字省略により無効   群馬県 17.08 字省略、ノ町により無効   茨城県 15.51 字省略、町名省略、区画整理により無効   熊本県 14.89 字省略により無効   山形県 14.38 字省略により無効   北海道 13.76 字省略、条、線により無効   栃木県 13.6 字省略により無効   新潟県 13.19 字省略により無効   鳥取県 9.57 字省略により無効   全国 9.25    福岡県 9 字省略により無効   三重県 7.74 字省略により無効   愛知県 7.4 字省略により無効   鹿児島県 7.09 字省略により無効   山梨県 6.8 字省略により無効   宮城県 6.37 字省略により無効   岩手県 6.28 字省略により無効   岐阜県 5.67 字省略、町名省略、区画整理により無効   香川県 4.71 字省略により無効   石川県 4.7 字省略、区画整理により無効   愛媛県 4.39 字省略により無効   秋田県 4.17 字省略により無効   滋賀県 3.76 字省略により無効   広島県 3.74 字省略により無効   高知県 3.38 字省略により無効   大阪府 3.28 字省略により無効   兵庫県 2.71 字省略により無効   島根県 2.04 字省略により無効   岡山県 1.81 字省略により無効   神奈川県 1.72 字省略、区画整理により無効   徳島県 1.64 字省略により無効   富山県 1.14 字省略により無効   静岡県 1.06 字省略、町名省略、区画整理により無効   東京都 0.89 字省略により無効   福井県 0.71 字省略により無効   千葉県 0.64 字省略により無効   長崎県 0      > WRAPUPWRAPUP \n\nimi-enrichment-addressは町名番地の判定に素の街区レベル位置参照情報を使用しているため、町字（まちあざ）の省略に弱いことが分かりました。 \n\n- ユーザーに住所の再確認を促す\n- 入力後の住所不備について人が目検で確認する前段階で利用 \n\nまず、想定したユースケースの内1つ「ユーザーに住所の再確認を促す」については、配送で使う住所の場合「町字の省略は影響ない」ので機能として適切ではありません。ユーザーが東京に集中している場合は関係ないですが、「町字が存在するさいたま市、川崎市、名古屋市、広島市、北九州市、福岡市、熊本市等の政令指定都市」や長野市のように住所が町字の組み合わせで2つ以上存在する都市の場合、使い勝手の悪い機能となります。 \n\n次に「入力後の住所不備について人が目検で確認する前段階で利用」については多少は有効に機能するでしょう。ただし、町字が多い地域では上記同様に使い勝手が悪くなります。 \n\n今回の検証の結果、現状の仕様ではimi-enrichment-addressを使うケースは限定せざるを得ず、一旦使用を見送りとします。とは言え、街区レベル位置参照情報にある町名番地から町字を除けば活用範囲が広がる可能性も確認できました。幸いなことにライブラリはMITライセンスで公開されています。"},"name":"[2021-07-24]imi-enrichment-addressは住所のバリデーションチェックでどの程度使えるか","tags":["imi-enrichment-address","mlit-isj"],"childPublishedDate":{"published_on":"2021-07-24T00:00:00.000Z","published_on_unix":1627084800}}},{"node":{"number":68,"relative_category":"blog/organization","fields":{"title":"飲み会に参加するための機材","excerpt":"以前チーム内でリモート懇親会を画策したのですが、食材の調達や経費精算など手間が多すぎて断念しました。ただ、その言い訳は実は本質的ではなく、実際に後ろ向きにさせていたのは「しゃべりながら食べるのがつらい」ということにありました。今回はそれを解決した機材を紹介します。  > PROBLEMPROBLEM \n\n- リモート飲みがつらい 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい 音声が悪すぎて相手にメッセージが伝わらない 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい \n- 有線ヘッドホンだとPCの前に張り付きになりつらい\n- 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい\n- というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい\n- 音声が悪すぎて相手にメッセージが伝わらない\n- 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない\n- 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 最初は楽しいがすぐ飽きる  > SOLUTIONSOLUTION \n\nというわけで、自分がこの1年試行錯誤した末に辿り着いた飲み会参加の機材スタックを共有します。  > オーディオインターフェイスオーディオインターフェイス \n\nオーディオインターフェイスはマイクやギターの音をパソコンに取り込むアナログ・デジタル変換と、取り込んだ音を再生するデジタル・アナログ変換の機能を提供します。 \n\nボイスメモ程度なら必要ないですが、フルリモートで頻繁に会議をしている機会が多いと音質とレイテンシーに多分な影響を与えます。オーディオインターフェイスがない場合、入力時にノイズが乗ったり、出力時に音質が劣化します。また、レイテンシーがひどくなったり音がゆがんだり、下手をするとPCに負荷がかかりフリーズします... \n\n会議を頻繁にする人はとりあえず手に入れたい機材。Steinberg UR22Cが人気です。 \n\n- Steinberg UR22C  > マイクマイク \n\n演説やスピーチ用にダイナミックマイクが使われていますが、オンラインミーティングで使う場合は聞き取りづらいので、何はともあれコンデンサーマイクを使うべきです。 \n\nコンデンサーマイクと言っても、いろいろあります。特にマイクの振動板（ダイアフラム）が大型か小型かで音質の印象が変わるので注意が必要です。私は下記の表のように利用シーンごとに使い分けています。    - 説明 利用シーン     スモールダイアフラム 現実主義。色のない、ニュートラルな音色を提供 ファシリテート   ラージダイアフラム 浪漫主義。音源をより大きく、愛らしいものに変換 発表、音楽活動    \n\nなお、HHKB等の打鍵音が大きいキーボードを利用している方や仕事スペースと家庭スペースとの距離が近い方は、いずれにしてもスモールダイアフラムがお薦めです。スモールダイアフラムはマイクから口元を少しでもずらすと音が入力されずらくなくなるため、期待した音質を提供することが出来ます。 \n\n製品としてはShure Beta87Aが人気です。また、購入する際はマイクスタンドとマイクスポンジもセットで検討すると良いです。マイクの位置を固定し風よけを設置した方が安定した音質に繋がります。 \n\n- Shure Beta87A  > ヘッドホンヘッドホン \n\n食事を取りながら相手の話を聞くには通常のヘッドホンだと食べ物を咀嚼するのに苦労します。口を開けたり閉めたりする際、顎とともにヘッドホンが上下に動くため相手の声が聞き取りづらくなります。 \n\n耳の穴に接しない骨伝導ヘッドホンは、食べ物を咀嚼する際の顎の動きに左右されることがないです。テレワークのヘッドホン多用が外耳炎を引き起こしているという話もあるので、そういう意味で骨伝導ヘッドホンは健康を保つ上でも重要な機材となります。 \n\nまた、使用していて分かったのですが、普段の食事の中でも使うことが出来るので、隙間時間に気軽にメディアに接しやすくなります。例えば、家族と一緒の部屋にいる中、食事を取りながらAWSのWebinarを聞くことができます。 \n\n製品としては業界を牽引しているAfterShokzのAeropexが人気です。今回はオーディオインターフェイスを利用しているので、音質をさらに高めるためにトランスリミッターと組み合わせましょう。 \n\n- AfterShokz Aeropex\n- トランスリミッター TaoTronics aptX-LL  > ビデオビデオ \n\nソーシャルメディアでよく登場するビデオ画像は、表情アップの図（ず）が前面に押し出された絵が一般的ですが、地（じ）の表現が薄く解釈余地がないものが多いです。表情が豊かな方は良いのですが、全員がそういうわけではないので地（じ）の生活の部分に焦点を当てた方が実態に合っています。 \n\n例えば、対面での会話の中では身につけている服装や持ち物等のアトリビュートに焦点が当たりますよね。「その身につけているアクセサリーは何?」「机の上に置いてあるその本、面白そうだね」という会話を思い出してください。 \n\nそういう意味で広角レンズを搭載したアクションカムは望ましい選択です。今時のアクションカムは高解像で鮮やかに表現してくれますし、外にいなくても部屋の中で十分面白い絵になります。 \n\nアクションカムは何でも良いのですが、私は普段「撮れラン」で使っているSony HDR-AS3000をミーティングの際に使っています。 \n\n- Sony HDR-AS3000  > WRAPUPWRAPUP \n\n今回紹介した機材に出会うまで紆余曲折ありましたが、揃えてみて満足しています。 \n\n飲み会でなくても良いですが、機材を揃えた方でいろいろ試してみたい方は一緒に雑談してみませんか。30分雑談会というのを開催しているので、いつでもお気軽にお声がけください。"},"name":"[2021-01-30]飲み会に参加するための機材","tags":["drinkup","team-building"],"childPublishedDate":{"published_on":"2021-01-30T00:00:00.000Z","published_on_unix":1611964800}}}]}},"pageContext":{"number":75}},"staticQueryHashes":[]}