{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/56","result":{"data":{"esaPost":{"number":56,"relative_category":"blog/backend","fields":{"title":"RubyのCSVパースをPyCallで実行する（ベンチマーク）","excerpt":"先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。   > PROBLEMPROBLEM \n\n- 大量のCSVを読み込む際、毎回時間がかかる   > SOLUTIONSOLUTION \n\nというわけで、「Dalibor Nasevicのベンチマーク記事」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り CSV.foreach が速いとの結論でした。    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0      > PyCallのベンチマークPyCallのベンチマーク \n\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。   ruby \n\nrequire_relative './helpers' require 'pycall/import' include PyCall::Import pyimport :pandas, as: :pd print_memory_usage do print_time_spent do csv = pd.read_csv.('data.csv') sum = csv['id'].sum.() puts \"Sum: #{sum}\" end end   \n\nPyCallは pyenv との相性が悪いのでSystemインストールしたPythonでたたきます。   sh \n\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb Sum: 499999500000 Time: 1.49 Memory: 54.99 MB   \n\n結果    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0   6. PyCall 1.49 54.99    \n\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった CSV.foreach より16倍の実行速度となりました。   > WRAPUPWRAPUP \n\nPyCallのオブジェクトが PyObjectとActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。 \n\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png"},"wip":false,"body_md":"<img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\">\r\n\r\n先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。\r\n\r\n# PROBLEM\r\n- 大量のCSVを読み込む際、毎回時間がかかる\r\n\r\n# SOLUTION\r\nというわけで、「[Dalibor Nasevicのベンチマーク記事](https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby)」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り `CSV.foreach` が速いとの結論でした。\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n\r\n## PyCallのベンチマーク\r\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。\r\n\r\n```ruby\r\nrequire_relative './helpers'\r\nrequire 'pycall/import'\r\ninclude PyCall::Import\r\npyimport :pandas, as: :pd\r\n\r\nprint_memory_usage do\r\n  print_time_spent do\r\n    csv = pd.read_csv.('data.csv')\r\n    sum = csv['id'].sum.()\r\n    puts \"Sum: #{sum}\"\r\n  end\r\nend\r\n```\r\n\r\nPyCallは `pyenv` との相性が悪いのでSystemインストールしたPythonでたたきます。\r\n\r\n```sh\r\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb\r\nSum: 499999500000\r\nTime: 1.49\r\nMemory: 54.99 MB\r\n```\r\n\r\n**結果**\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n| 6. PyCall                          |        1.49 |       54.99 |\r\n\r\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった `CSV.foreach` より16倍の実行速度となりました。\r\n\r\n# WRAPUP\r\nPyCallのオブジェクトが `PyObject`とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。\r\n\r\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\"></a>\n<p data-sourcepos=\"3:1-3:290\">先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。</p>\n<h1 data-sourcepos=\"5:1-5:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"6:1-7:0\">\n<li data-sourcepos=\"6:1-7:0\">大量のCSVを読み込む際、毎回時間がかかる</li>\n</ul>\n<h1 data-sourcepos=\"8:1-8:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"9:1-9:307\">というわけで、「<a href=\"https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby\" target=\"_blank\" rel=\"noopener noreferrer\">Dalibor Nasevicのベンチマーク記事</a>」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り <code>CSV.foreach</code> が速いとの結論でした。</p>\n<table data-sourcepos=\"11:1-17:66\">\n<thead>\n<tr data-sourcepos=\"11:1-11:66\">\n<th data-sourcepos=\"11:2-11:37\">kind_of_parse</th>\n<th data-sourcepos=\"11:39-11:51\">time (real)</th>\n<th data-sourcepos=\"11:53-11:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"13:1-13:66\">\n<td data-sourcepos=\"13:2-13:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"13:39-13:51\">39.13</td>\n<td data-sourcepos=\"13:53-13:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"14:1-14:66\">\n<td data-sourcepos=\"14:2-14:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"14:39-14:51\">36.16</td>\n<td data-sourcepos=\"14:53-14:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"15:1-15:66\">\n<td data-sourcepos=\"15:2-15:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"15:39-15:51\">23.39</td>\n<td data-sourcepos=\"15:53-15:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"16:1-16:66\">\n<td data-sourcepos=\"16:2-16:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"16:39-16:51\">24.55</td>\n<td data-sourcepos=\"16:53-16:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"17:1-17:66\">\n<td data-sourcepos=\"17:2-17:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"17:39-17:51\">24.04</td>\n<td data-sourcepos=\"17:53-17:65\">0.0</td>\n</tr>\n</tbody>\n</table>\n<h2 data-sourcepos=\"19:1-19:30\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"PyCallのベンチマーク\" name=\"PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" href=\"#PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PyCallのベンチマーク\"> &gt; PyCallのベンチマーク</span></a>PyCallのベンチマーク</h2>\n<p data-sourcepos=\"20:1-20:111\">それでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。</p>\n<div class=\"code-block\" data-sourcepos=\"22:1-35:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ruby</div>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"nb\">require_relative</span> <span class=\"s1\">'./helpers'</span>\n<span class=\"nb\">require</span> <span class=\"s1\">'pycall/import'</span>\n<span class=\"kp\">include</span> <span class=\"no\">PyCall</span><span class=\"o\">::</span><span class=\"no\">Import</span>\n<span class=\"n\">pyimport</span> <span class=\"ss\">:pandas</span><span class=\"p\">,</span> <span class=\"ss\">as: :pd</span>\n\n<span class=\"n\">print_memory_usage</span> <span class=\"k\">do</span>\n  <span class=\"n\">print_time_spent</span> <span class=\"k\">do</span>\n    <span class=\"n\">csv</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"nf\">read_csv</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"s1\">'data.csv'</span><span class=\"p\">)</span>\n    <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">csv</span><span class=\"p\">[</span><span class=\"s1\">'id'</span><span class=\"p\">].</span><span class=\"nf\">sum</span><span class=\"o\">.</span><span class=\"p\">()</span>\n    <span class=\"nb\">puts</span> <span class=\"s2\">\"Sum: </span><span class=\"si\">#{</span><span class=\"n\">sum</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n</div>\n<p data-sourcepos=\"37:1-37:102\">PyCallは <code>pyenv</code> との相性が悪いのでSystemインストールしたPythonでたたきます。</p>\n<div class=\"code-block\" data-sourcepos=\"39:1-44:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ PYTHON</span><span class=\"o\">=</span>/usr/bin/python3.4 ruby parse_6_pycall.rb\nSum: 499999500000\nTime: 1.49\nMemory: 54.99 MB\n</code></pre></div>\n</div>\n<p data-sourcepos=\"46:1-46:10\"><strong>結果</strong></p>\n<table data-sourcepos=\"48:1-55:66\">\n<thead>\n<tr data-sourcepos=\"48:1-48:66\">\n<th data-sourcepos=\"48:2-48:37\">kind_of_parse</th>\n<th data-sourcepos=\"48:39-48:51\">time (real)</th>\n<th data-sourcepos=\"48:53-48:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"50:1-50:66\">\n<td data-sourcepos=\"50:2-50:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"50:39-50:51\">39.13</td>\n<td data-sourcepos=\"50:53-50:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"51:1-51:66\">\n<td data-sourcepos=\"51:2-51:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"51:39-51:51\">36.16</td>\n<td data-sourcepos=\"51:53-51:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"52:1-52:66\">\n<td data-sourcepos=\"52:2-52:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"52:39-52:51\">23.39</td>\n<td data-sourcepos=\"52:53-52:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"53:1-53:66\">\n<td data-sourcepos=\"53:2-53:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"53:39-53:51\">24.55</td>\n<td data-sourcepos=\"53:53-53:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"54:1-54:66\">\n<td data-sourcepos=\"54:2-54:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"54:39-54:51\">24.04</td>\n<td data-sourcepos=\"54:53-54:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"55:1-55:66\">\n<td data-sourcepos=\"55:2-55:37\">6. PyCall</td>\n<td data-sourcepos=\"55:39-55:51\">1.49</td>\n<td data-sourcepos=\"55:53-55:65\">54.99</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"57:1-57:150\">はい、結果が出ました。Daliborのベンチマーク記事で一番速かった <code>CSV.foreach</code> より16倍の実行速度となりました。</p>\n<h1 data-sourcepos=\"59:1-59:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"60:1-60:248\">PyCallのオブジェクトが <code>PyObject</code>とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。</p>\n<p data-sourcepos=\"62:1-62:105\">ただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。</p>\n","tags":["ruby","benchmark","pycall"],"updated_at":"2021-01-16T10:27:34+09:00","childPublishedDate":{"published_on":"2017-06-05T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_7b757a0db07cde6a337af7df901ab0c5.jpg"}},"relatedPosts":{"edges":[{"node":{"number":55,"relative_category":"blog/backend","fields":{"title":"PositiveSSLをHerokuに適用する","excerpt":"年に1回のSSL更新のイベントです。毎年同じことをすれば良いかというとそうでもなく、販社と卸の都合でSSLの購入方法が微妙に変わります。とは言え、毎年一から調べ直すのも手間なので備忘として記しておきます。  > PROBLEMPROBLEM \n\n- HerokuのSSLの期限がきた  > SOLUTIONSOLUTION \n\n- というわけで、いつも使っているSSL販売代理店SSLs.com（NameCheap社）でPositiveSSL（運用Comodo社）を購入しHerokuに適用します。  > HOWTOHOWTO \n\n1. 証明書を購入する SSL販売代理店であればどこでもいいのですが、昔から使っているので \n2. SSL販売代理店であればどこでもいいのですが、昔から使っているので\n3. 秘密鍵と署名リクエストをつくる 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key 署名リクエスト openssl req -new -key server.key -out server.csr ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました \n4. 秘密鍵 openssl genrsa -des3 -out server.orig.key 2048\n5. 秘密鍵パスワードなしopenssl rsa -in server.orig.key -out server.key\n6. 署名リクエスト openssl req -new -key server.key -out server.csr\n7. ※ 最近このあたりの署名情報は、SSL販売代理店側で生成しているケースが増えてきました\n8. 証明書発行を申請する SSL販売代理店より署名リクエストserver.csrと関連情報を送信します \n9. SSL販売代理店より署名リクエストserver.csrと関連情報を送信します\n10. ドメイン保持の証明をする PositiveSSLの運用会社Comodoに対しドメイン保持の証明します 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります \n11. PositiveSSLの運用会社Comodoに対しドメイン保持の証明します\n12. 証明方法はメールを受信する、あるいは、Webサイトにプレーンテキストを設置するかの2択になります\n13. Heroku用の証明書をつくる 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt \n14. 証明タスクをこなししばらくすると、Comodo社より複数の証明書が送られてきます\n15. Heroku用に証明書をつくる cat www_example_com.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt > server.crt\n16. Herokuに証明書を適用する 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n17. 新規で適用する場合は次のコマンドを実行します heroku addons:add ssl:endpoint heroku certs:add server.crt server.key \n18. heroku addons:add ssl:endpoint\n19. heroku certs:add server.crt server.key\n20. 更新する場合は次のコマンドを実行します heroku certs:update server.crt server.key \n21. heroku certs:update server.crt server.key  > WRAPUPWRAPUP \n\nこのあたりが自動化されれば良いと思いつつ、自動化されたらこのあたりを調べるモチベーションがなくなるので年に一回のリハビリイベントとして位置づけておきます、はい。  > 後日談後日談 \n\n現在はAutomated Certificate Management (ACM) 機能が用意されています。そちらを使う方が手間・実費ともにリーズナブルで、リハビリさえもいらなくなりました。以下適用方法。 \n\n1. ACMを有効化します。有効化するまでしばし時間がかかるので watch コマンドをつけて様子見します watch heroku certs:auto:enable \n2. watch heroku certs:auto:enable\n3. 手動で追加した証明書があるか確認します heroku certs \n4. heroku certs\n5. もし手動で追加した証明書がある場合は当該証明書を削除します heroku certs:remove --name foo-bar \n6. heroku certs:remove --name foo-bar"},"name":"[2017-04-23]PositiveSSLをHerokuに適用する","tags":[],"childPublishedDate":{"published_on":"2017-04-23T00:00:00.000Z","published_on_unix":1492905600}}},{"node":{"number":140,"relative_category":"blog/backend","fields":{"title":"提供していない決済方法を業務で取り扱う際に気をつけること","excerpt":"ECプロダクトを扱っている際にどうしても出てくる銀行振込。プロダクト立ち上げ時は、銀行振込が第一にあるターゲット層を除いて、コストの高い銀行振込は実装せずに裏メニューとして扱うのが通例だと思います。今回は、当該ケースの課題を取り上げて、その解決策を示します。単純な話なのですが、時間が経つにつれて業務が硬直化してスケーリングに影響してくるので事前に手を打っておくと良いと思います。   > PROBLEMPROBLEM \n\n- 銀行振込を通常決済方法でしか提供していないケースの場合 人力でトランザクションをはる必要があり、その処理の隙間で想定外の支払い、あるいは、二重決済が行われる可能性がある また、不整合処理を実施するCSあるいはそれに付随する担当に権限が集中しすぎ、統制上難しい運用になる \n- 人力でトランザクションをはる必要があり、その処理の隙間で想定外の支払い、あるいは、二重決済が行われる可能性がある\n- また、不整合処理を実施するCSあるいはそれに付随する担当に権限が集中しすぎ、統制上難しい運用になる  > 通常のケース通常のケース \n\n  > 不整合が起きるケース「銀行振込と通常決済が同時に実行」不整合が起きるケース「銀行振込と通常決済が同時に実行」 \n\n  > SOLUTIONSOLUTION \n\nと言うわけで、解決方法を整理してみました。答えは単純で銀行振込の決済ロックをシステム側に実装するというだけの話です。ただ、振込確認を人力で行っている場合は、銀行振込を決済方法として表側に出すのは難しいので問い合わせタイミングでロックできるよう問い合わせ窓口を工夫する必要があります。プロダクトのUXに関わってくる話なので簡単に実装するだけで済まないのが悩ましいところですが、粘り強く進めるしかないです。 \n\n  > WRAPUPWRAPUP \n\nECプロダクトがスケールしてくると決済方法が増え、業務処理が複雑になってきます。決済の適正性は統制上重要になってくるので決済の処理量に応じて、リスクアセスメントで拾い上げ適切な実装にしていきたいものですね。"},"name":"[2022-05-02]提供していない決済方法を業務で取り扱う際に気をつけること","tags":["payment-service"],"childPublishedDate":{"published_on":"2022-05-02T00:00:00.000Z","published_on_unix":1651449600}}},{"node":{"number":139,"relative_category":"blog/backend","fields":{"title":"ヘルステック界隈のエンジニアが気をつけるべき個人情報の扱い","excerpt":"ヘルステックでエンジニアをしている方であればデータの扱いには苦労していることと思います。CISOがつくったデータセグメンテーションがどういう意図で成り立っているのか、整理されていない現場だと読み解きに時間がかかります。現場に入って早々 何も知らないエンジニアとしては、緩めな方針よりは保守的に設計していく方が後々のトラブルが少なく安全です。   > PROBLEMPROBLEM \n\n- 要配慮個人情報について、厚労省医政局発「医療情報システムの安全管理に関するガイドライン」1を見ると「 医療・健康情報を[..]医師等以外の者が分析等を実施することは許されるものではない 」と書かれている ここでいう「 医療・健康情報 」は要配慮個人情報の中の具体的に何を指しているのか分かりづらい 「 医師等 」の「 等 」が何を指すのか分かりづらい 厚労省医政局の発令0912001号「診療情報の提供等に関する指針」2から推察するに、「 医療・健康情報 」は診療録、「 医師等 」は医療系有資格者を指している 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象 \n- ここでいう「 医療・健康情報 」は要配慮個人情報の中の具体的に何を指しているのか分かりづらい\n- 「 医師等 」の「 等 」が何を指すのか分かりづらい\n- 厚労省医政局の発令0912001号「診療情報の提供等に関する指針」2から推察するに、「 医療・健康情報 」は診療録、「 医師等 」は医療系有資格者を指している 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象 \n- 医療系有資格者については、個人情報保護法の関連で出された医療・介護分野用「医療・介護関係事業者における個人情報の適切な取扱いのためのガイダンス」に掲載されている守秘義務対象\n- また、データアクセス対象を緩めると、教育が不十分な人が故意に流出させ刑法上の秘密漏示罪3に問われる可能性がある 秘密漏示罪は身分犯ではあるが歯科医師のように解釈の余地もあり範囲が不透明 \n- 秘密漏示罪は身分犯ではあるが歯科医師のように解釈の余地もあり範囲が不透明  > SOLUTIONSOLUTION \n\nというわけで、ヘルステックに関わる個人情報の扱いを整理してみました。 \n\n課題は上記の通りで、時代の流れとともに医療情報の整備が進んでいる状況です。善管注意の責務を負ったエンジニアとしては医療系有資格者以外への診療録の情報提供は、例え、同僚であっても連結可能匿名（仮名加工）ではなく匿名加工で対応すべきでしょう。ゆくゆくは会社として次世代医療基盤法4を適用し、医療分野の研究開発に資するよう体制を構築することが望ましいと考えています。  > 加工なし加工なし \n\n学術研究等をのぞき第三者提供は本人同意が必要となるため、ユースケースは限定されます。各々の個人情報の種類によりアクセス出来る人が変わってきます。また、守秘義務が課せられる範囲が広く、行為によっては秘密漏示罪や不正アクセス禁止法5の罰則の対象になります。     診療録 診療録を除いた要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内 (医療関連有資格者) 社内 社内, 社外   利用目的の必要性 (公表有無) 必要 必要 必要   利用目的の必要性 (変更可否) 関連性を有する合理的な範囲 関連性を有する合理的な範囲 関連性を有する合理的な範囲   目的外利用 不可 不可 不可   第三者提供 (可否) 可 可 可   第三者提供 (本人同意) 必要 (オプトインのみ) 必要 (オプトインのみ) 必要 (オプトアウト)   個人の開示請求 応じる 応じる 応じる   漏洩時の報告 必須 必須 必須     > 仮名加工仮名加工 \n\n診療録に関する規定は次世代医療基盤法でまとめられているので、あえて規定が曖昧な仮名加工（連結可能匿名）をつかうのは望ましくありません。ユースケースとして要配慮個人情報を除いた個人情報の統計分析に限られるでしょう。     診療録を除いた要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内 社内   利用目的の必要性 (公表有無) 必要 必要   利用目的の必要性 (変更可否) 際限なく変更可能 際限なく変更可能   目的外利用 不可 不可   第三者提供 (可否) 不可 不可   個人の開示請求 応じない 応じない   漏洩時の報告 なし なし     > 匿名加工匿名加工 \n\n診療録は本人のオプトアウトありですが、基本本人同意なしで利用可能です。ただ、診療録は可変長文字列の上、特異な記述として最も気をつける対象になります。データマスキングの実装は手厚く行っていく必要があります。     診療録を含んだ要配慮個人情報 要配慮個人情報を除いた個人情報     使用場所 社内, 社外 社内, 社外   利用目的の必要性 (公表有無) 不要 不要   第三者提供 (可否) 可 可   第三者提供 (本人同意) 不要 (オプトアウトあり) 不要   個人の開示請求 応じない 応じない   漏洩時の報告 なし なし     > WRAPUPWRAPUP \n\nポイントをかいつまんでまとめてみました。エンジニア視点のため、考慮漏れの箇所があるかも知れませんが、フィードバックや各種レギュレーションの経過を元に更新していければと思います。  \n\n1. https://www.mhlw.go.jp/stf/shingi/0000516275.html ↩ \n2. https://www.mhlw.go.jp/web/t_doc?dataId=00tb3403&dataType=1&page%20No=1 ↩ \n3. https://elaws.e-gov.go.jp/document?lawid=140AC0000000045 ↩ \n4. https://elaws.e-gov.go.jp/document?lawid=429AC0000000028 ↩ \n5. https://elaws.e-gov.go.jp/document?lawid=411AC0000000128 ↩"},"name":"[2022-04-24]ヘルステック界隈のエンジニアが気をつけるべき個人情報の扱い","tags":["privacy","data-masking","data-engineering","health-informatics"],"childPublishedDate":{"published_on":"2022-04-24T00:00:00.000Z","published_on_unix":1650758400}}}]}},"pageContext":{"number":56}},"staticQueryHashes":[]}