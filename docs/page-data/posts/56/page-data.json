{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/56","result":{"data":{"esaPost":{"number":56,"relative_category":"blog/backend","fields":{"title":"RubyのCSVパースをPyCallで実行する（ベンチマーク）","excerpt":"先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。   > PROBLEMPROBLEM \n\n- 大量のCSVを読み込む際、毎回時間がかかる   > SOLUTIONSOLUTION \n\nというわけで、「Dalibor Nasevicのベンチマーク記事」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り CSV.foreach が速いとの結論でした。    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0      > PyCallのベンチマークPyCallのベンチマーク \n\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。   ruby \n\nrequire_relative './helpers' require 'pycall/import' include PyCall::Import pyimport :pandas, as: :pd print_memory_usage do print_time_spent do csv = pd.read_csv.('data.csv') sum = csv['id'].sum.() puts \"Sum: #{sum}\" end end   \n\nPyCallは pyenv との相性が悪いのでSystemインストールしたPythonでたたきます。   sh \n\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb Sum: 499999500000 Time: 1.49 Memory: 54.99 MB   \n\n結果    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0   6. PyCall 1.49 54.99    \n\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった CSV.foreach より16倍の実行速度となりました。   > WRAPUPWRAPUP \n\nPyCallのオブジェクトが PyObjectとActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。 \n\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png"},"wip":false,"body_md":"<img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\">\r\n\r\n先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。\r\n\r\n# PROBLEM\r\n- 大量のCSVを読み込む際、毎回時間がかかる\r\n\r\n# SOLUTION\r\nというわけで、「[Dalibor Nasevicのベンチマーク記事](https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby)」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り `CSV.foreach` が速いとの結論でした。\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n\r\n## PyCallのベンチマーク\r\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。\r\n\r\n```ruby\r\nrequire_relative './helpers'\r\nrequire 'pycall/import'\r\ninclude PyCall::Import\r\npyimport :pandas, as: :pd\r\n\r\nprint_memory_usage do\r\n  print_time_spent do\r\n    csv = pd.read_csv.('data.csv')\r\n    sum = csv['id'].sum.()\r\n    puts \"Sum: #{sum}\"\r\n  end\r\nend\r\n```\r\n\r\nPyCallは `pyenv` との相性が悪いのでSystemインストールしたPythonでたたきます。\r\n\r\n```sh\r\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb\r\nSum: 499999500000\r\nTime: 1.49\r\nMemory: 54.99 MB\r\n```\r\n\r\n**結果**\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n| 6. PyCall                          |        1.49 |       54.99 |\r\n\r\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった `CSV.foreach` より16倍の実行速度となりました。\r\n\r\n# WRAPUP\r\nPyCallのオブジェクトが `PyObject`とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。\r\n\r\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\"></a>\n<p data-sourcepos=\"3:1-3:290\">先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。</p>\n<h1 data-sourcepos=\"5:1-5:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"6:1-7:0\">\n<li data-sourcepos=\"6:1-7:0\">大量のCSVを読み込む際、毎回時間がかかる</li>\n</ul>\n<h1 data-sourcepos=\"8:1-8:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"9:1-9:307\">というわけで、「<a href=\"https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby\" target=\"_blank\" rel=\"noopener noreferrer\">Dalibor Nasevicのベンチマーク記事</a>」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り <code>CSV.foreach</code> が速いとの結論でした。</p>\n<table data-sourcepos=\"11:1-17:66\">\n<thead>\n<tr data-sourcepos=\"11:1-11:66\">\n<th data-sourcepos=\"11:2-11:37\">kind_of_parse</th>\n<th data-sourcepos=\"11:39-11:51\">time (real)</th>\n<th data-sourcepos=\"11:53-11:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"13:1-13:66\">\n<td data-sourcepos=\"13:2-13:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"13:39-13:51\">39.13</td>\n<td data-sourcepos=\"13:53-13:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"14:1-14:66\">\n<td data-sourcepos=\"14:2-14:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"14:39-14:51\">36.16</td>\n<td data-sourcepos=\"14:53-14:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"15:1-15:66\">\n<td data-sourcepos=\"15:2-15:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"15:39-15:51\">23.39</td>\n<td data-sourcepos=\"15:53-15:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"16:1-16:66\">\n<td data-sourcepos=\"16:2-16:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"16:39-16:51\">24.55</td>\n<td data-sourcepos=\"16:53-16:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"17:1-17:66\">\n<td data-sourcepos=\"17:2-17:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"17:39-17:51\">24.04</td>\n<td data-sourcepos=\"17:53-17:65\">0.0</td>\n</tr>\n</tbody>\n</table>\n<h2 data-sourcepos=\"19:1-19:30\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"PyCallのベンチマーク\" name=\"PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" href=\"#PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PyCallのベンチマーク\"> &gt; PyCallのベンチマーク</span></a>PyCallのベンチマーク</h2>\n<p data-sourcepos=\"20:1-20:111\">それでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。</p>\n<div class=\"code-block\" data-sourcepos=\"22:1-35:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ruby</div>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"nb\">require_relative</span> <span class=\"s1\">'./helpers'</span>\n<span class=\"nb\">require</span> <span class=\"s1\">'pycall/import'</span>\n<span class=\"kp\">include</span> <span class=\"no\">PyCall</span><span class=\"o\">::</span><span class=\"no\">Import</span>\n<span class=\"n\">pyimport</span> <span class=\"ss\">:pandas</span><span class=\"p\">,</span> <span class=\"ss\">as: :pd</span>\n\n<span class=\"n\">print_memory_usage</span> <span class=\"k\">do</span>\n  <span class=\"n\">print_time_spent</span> <span class=\"k\">do</span>\n    <span class=\"n\">csv</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"nf\">read_csv</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"s1\">'data.csv'</span><span class=\"p\">)</span>\n    <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">csv</span><span class=\"p\">[</span><span class=\"s1\">'id'</span><span class=\"p\">].</span><span class=\"nf\">sum</span><span class=\"o\">.</span><span class=\"p\">()</span>\n    <span class=\"nb\">puts</span> <span class=\"s2\">\"Sum: </span><span class=\"si\">#{</span><span class=\"n\">sum</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n</div>\n<p data-sourcepos=\"37:1-37:102\">PyCallは <code>pyenv</code> との相性が悪いのでSystemインストールしたPythonでたたきます。</p>\n<div class=\"code-block\" data-sourcepos=\"39:1-44:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ PYTHON</span><span class=\"o\">=</span>/usr/bin/python3.4 ruby parse_6_pycall.rb\nSum: 499999500000\nTime: 1.49\nMemory: 54.99 MB\n</code></pre></div>\n</div>\n<p data-sourcepos=\"46:1-46:10\"><strong>結果</strong></p>\n<table data-sourcepos=\"48:1-55:66\">\n<thead>\n<tr data-sourcepos=\"48:1-48:66\">\n<th data-sourcepos=\"48:2-48:37\">kind_of_parse</th>\n<th data-sourcepos=\"48:39-48:51\">time (real)</th>\n<th data-sourcepos=\"48:53-48:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"50:1-50:66\">\n<td data-sourcepos=\"50:2-50:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"50:39-50:51\">39.13</td>\n<td data-sourcepos=\"50:53-50:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"51:1-51:66\">\n<td data-sourcepos=\"51:2-51:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"51:39-51:51\">36.16</td>\n<td data-sourcepos=\"51:53-51:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"52:1-52:66\">\n<td data-sourcepos=\"52:2-52:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"52:39-52:51\">23.39</td>\n<td data-sourcepos=\"52:53-52:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"53:1-53:66\">\n<td data-sourcepos=\"53:2-53:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"53:39-53:51\">24.55</td>\n<td data-sourcepos=\"53:53-53:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"54:1-54:66\">\n<td data-sourcepos=\"54:2-54:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"54:39-54:51\">24.04</td>\n<td data-sourcepos=\"54:53-54:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"55:1-55:66\">\n<td data-sourcepos=\"55:2-55:37\">6. PyCall</td>\n<td data-sourcepos=\"55:39-55:51\">1.49</td>\n<td data-sourcepos=\"55:53-55:65\">54.99</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"57:1-57:150\">はい、結果が出ました。Daliborのベンチマーク記事で一番速かった <code>CSV.foreach</code> より16倍の実行速度となりました。</p>\n<h1 data-sourcepos=\"59:1-59:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"60:1-60:248\">PyCallのオブジェクトが <code>PyObject</code>とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。</p>\n<p data-sourcepos=\"62:1-62:105\">ただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。</p>\n","tags":["ruby","benchmark","pycall"],"updated_at":"2021-01-16T10:27:34+09:00","childPublishedDate":{"published_on":"2017-06-05T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":60,"relative_category":"blog/backend","fields":{"title":"連載 Rails2Phoenix 2 認証機能を実装する","excerpt":"連載「Rails2Phoenix」になります、前回は「UmbrellaプロジェクトをHerokuにデプロイする 」でした。今回は前回課題としてあがった認証機能の実装を試みたいと思います。   > PROBLEMPROBLEM \n\n- サービスについて 拡張にともない技術スタックがふえるのを抑えたい スケーラビリティのためのコストを抑えたい パフォーマンスをあげたい \n- 拡張にともない技術スタックがふえるのを抑えたい\n- スケーラビリティのためのコストを抑えたい\n- パフォーマンスをあげたい   > SOLUTIONSOLUTION \n\nというわけで、現在つかっているRailsをPhoenixに変更することにしました。方針は以下の通りで、今回はRails/Deviseの認証機能をPhoenixで実装する流れを取り上げます。 \n\n方針 \n\n- Railsから徐々にPhoenixに移行できるように いままでとおなじPaaS（Heroku） いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく いままでとおなじDB 移行完了までDBマイグレーションをしない \n- いままでとおなじPaaS（Heroku）\n- いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく \n- ブランチ戦略は phoenix/base をベースに\n- 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく\n- いままでとおなじDB 移行完了までDBマイグレーションをしない \n- 移行完了までDBマイグレーションをしない\n- Phoenixは今後の拡張性をかんがえてUmbrellaプロジェクトで   > Guardianを実装するGuardianを実装する \n\nまず、参考にしたのはBlackodeのguardian_authです。ただ、Guardianのバージョンがふるいので1.0へのマイグレーション記事をもとにアレンジしてあります。認証に関係しそうな構成は下記の通り。 \n\nロジック \n\n- MyApp.Account\n- MyApp.Account.Registration\n- MyApp.Account.User\n- MyApp.Auth.Guardian\n- MyApp.Auth.ErrorHandler\n- MyApp.Auth.Pipeline\n- MyApp.Auth.AfterPipeline\n- MyApp.Auth.Session \n\nコントローラ \n\n- MyAppWeb.RegistrationController\n- MyAppWeb.SessionController   > シリアライザとエラーハンドラの設定シリアライザとエラーハンドラの設定 \n\nGuardian1.0から直接ではなくモジュールを介して参照するようになりました。下記のように各モジュールを用意してコンフィグに割り当てます。   elixir \n\n# apps/my_app/lib/my_app/auth/guardian.ex defmodule MyApp.Auth.Guardian do use Guardian, otp_app: :my_app alias MyApp.Account def subject_for_token(resource, _claims), do: {:ok, to_string(resource.id)} def subject_for_token(_, _), do: {:error, :reason_for_error} def resource_from_claims(claims), do: {:ok, Account.get_user!(claims[\"sub\"])} def resource_from_claims(_claims), do: {:error, :reason_for_error} end     elixir \n\n# apps/my_app/lib/my_app/auth/error_handler.ex defmodule MyApp.Auth.ErrorHandler do import Plug.Conn def auth_error(conn, {type, _reason}, _opts) do body = Poison.encode!(%{message: to_string(type)}) send_resp(conn, 401, body) end end     elixir \n\n# apps/my_app/config/config.exs config :my_app, MyApp.Auth.Guardian, issuer: \"MyApp\", ttl: {30, :days}, allowed_drift: 2000, # optionals allowed_algos: [\"HS512\"], verify_module: MyApp.Auth.Guardian.JWT, verify_issuer: true, secret_key: System.get_env(\"GUARDIAN_SECRET\") || \"secret_key\"     > ルーターの設定ルーターの設定 \n\n認証のパイプラインは、認証中と認証後のものを用意しコンフィグとルーターに割り当てます。 \n\nルータースコープ内のパイプラインくみあわせについて、ここでは未ログインスコープには認証前・認証中パイプライン、ログイン済スコープには認証前・認証中・認証後パイプラインを適用しています。こうすることでどのスコープにも認証リソースをロードすることができ、かつ、認証も担保することができるようになります。具体的にいうと、ルート / などの同一URLで未ログインスコープとログイン済スコープの切り替えができるようになります。   elixir \n\n# apps/my_app/lib/my_app/auth/pipeline.ex defmodule MyApp.Auth.Pipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.VerifySession, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.VerifyHeader, claims: %{\"typ\" => \"access\"}) plug(Guardian.Plug.LoadResource, allow_blank: true) end     elixir \n\n# apps/my_app/lib/my_app/auth/after_pipeline.ex defmodule MyApp.Auth.AfterPipeline do use Guardian.Plug.Pipeline, otp_app: :my_app plug(Guardian.Plug.EnsureAuthenticated) end     elixir \n\n# apps/my_app/lib/my_app_web/router.ex defmodule MyAppWeb.Router do use MyAppWeb, :router pipeline :browser do plug(:accepts, [\"html\"]) plug(:fetch_session) plug(:fetch_flash) plug(:protect_from_forgery) plug(:put_secure_browser_headers) end pipeline :browser_auth do plug(MyApp.Auth.Pipeline) end pipeline :browser_auth_after do plug(MyApp.Auth.AfterPipeline) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth]) post(\"/registration\", RegistrationController, :create) get(\"/login\", SessionController, :new) post(\"/login\", SessionController, :create) get(\"/logout\", SessionController, :delete) end scope \"/\", MyAppWeb do pipe_through([:browser, :browser_auth, :browser_auth_after]) get(\"/edit\", RegistrationController, :edit) put(\"/edit\", RegistrationController, :update) get(\"/users\", UserController, :index) resources \"/\", UserController, only: [:show, :delete], param: \"username\" end end     elixir \n\n# apps/my_app/config/config.exs config :MyApp, MyApp.Auth.Pipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler config :MyApp, MyApp.Auth.AferPipeline, module: MyApp.Auth.Guardian, error_handler: MyApp.Auth.ErrorHandler     > 登録登録 \n\n登録は登録用のロジック（ユーザーモデルと登録サービス）とコントローラを用意します。 \n\nこのあたりはDevise/Railsとあまり変わりません。他のアクション「新規パスワード発行」「メールアドレス確認」等も同様の構成をとろうと思っています。   elixir \n\n# apps/my_app/lib/my_app_web/controller/registration_controller.ex def create(conn, user_params) do changeset = User.registration_changeset(%User{}, user_params) case Registration.create(changeset, Repo) do {:ok, user} -> conn |> MyApp.Auth.login(user) |> put_flash(:info, \"Your account was created successfully\") |> redirect(to: page_path(conn, :home)) {:error, changeset} -> conn |> put_flash(:error, \"Unable to create account: Try again\") |> render(MyAppWeb.PageView, \"home.html\", changeset: changeset) end end     elixir \n\n# apps/my_app/lib/my_app/auth/auth.ex def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end     elixir \n\n# apps/my_app/lib/my_app/account/registration.ex def create(changeset, repo) do changeset |> repo.insert() end     > ログイン・ログアウトログイン・ログアウト \n\nログイン・ログアウトはセッション用のサービスとコントローラで実装します。   elixir \n\n# apps/my_app/lib/my_app_web/controller/session_controller.ex @doc \"Logged in [POST /login]\" def create(conn, %{\"email\" => email, \"password\" => password}) do case Session.authenticate_user(email, password) do {:ok, user} -> conn |> Session.login(user) |> put_flash(:info, \"Logged in successfully\") |> redirect(to: page_path(conn, :home)) {:error, _reason} -> conn |> put_flash(:error, \"Wrong username/password\") |> render(\"new.html\") end end @doc \"Logged out [DELETE /logout]\" def delete(conn, _params) do conn |> Session.logout() |> put_flash(:info, \"Logged out successfully.\") |> redirect(to: \"/\") end     elixir \n\n# apps/my_app/lib/my_app/auth/session.ex defmodule MyApp.Auth.Session do import Ecto.Query import Plug.Conn import Comeonin.Bcrypt, only: [checkpw: 2, dummy_checkpw: 0] alias MyApp.Repo alias MyApp.Auth.Guardian alias MyApp.Account.User def login(conn, %User{} = user) do conn |> Guardian.Plug.sign_in(user) |> assign(:current_user, user) end def logout(conn), do: Guardian.Plug.sign_out(conn) def authenticate_user(email, given_password) do query = Ecto.Query.from(u in User, where: u.email == ^email) Repo.one(query) |> check_password(given_password) end def current_user(conn), do: Guardian.Plug.current_resource(conn, []) def logged_in?(conn), do: Guardian.Plug.authenticated?(conn, []) defp check_password(nil, _), do: {:error, \"Incorrect username or password\"} defp check_password(user, given_password) do case Comeonin.Bcrypt.checkpw(given_password, user.encrypted_password) do true -> {:ok, user} false -> {:error, \"Incorrect email or password\"} end end end   \n\nDevise/Railsのビューヘルパーはビューマクロで適用します。   elixir \n\n# apps/my_app/lib/my_app_web.ex def view do quote do # .. import Okuribi.Auth.Session, only: [current_user: 1, logged_in?: 1] end end   \n\nあるいは、put_assigns関数をはやしてコントローラマクロに適用します。   elixir \n\n# apps/my_app/lib/my_app/auth/session.ex def put_assigns(%{private: %{phoenix_action: action}} = conn, settings) do current_resource = Guardian.Plug.current_resource(conn) settings = if current_resource, do: settings[:sign_in][action] || [], else: settings[:sign_out][action] || [] conn |> assign(:current_user, current_resource) |> assign(:page_title, settings[:page_title]) |> assign(:page_description, settings[:page_description]) end     elixir \n\n# apps/my_app/lib/my_app_web.ex def controller do quote do # .. import Okuribi.Auth, only: [put_assigns: 2] end end   \n\nassignsひとつでアクセスできるので、下記のようにコントローラでまとめて指定することでRailsのActionView::Helpers::CaptureHelper#provideの代わりに使えます。   elixir \n\n# apps/my_app/lib/my_app_web/controller/*_controller.ex @page %{ sign_in: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_in.page_title\"), page_description: \"\" } }, sign_out: %{ new: %{ page_title: dgettext(\"views\", \"pages.home.signed_out.page_title\"), page_description: \"\" } } } plug(:put_assigns, @page when action in [:home])     > その他その他 \n\nRailsのビューをPhoenixのテンプレートに移植するには下記の変換を地道に行っていきます。 \n\n- Rails ActionView::Helpers::FormHelper#form_for(record, options={}, &block) ActionView::Helpers::FormHelper#text_field(object_name, method, options={}) ActionView::Helpers::FormHelper#file_field(object_name, method, options={}) ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={}) ActionView::Helpers::FormHelper#password_field(object_name, method, options={}) ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={}) ActionView::Helpers::FormBuilder#submit(value=nil, options={}) ActionView::Helpers::TranslationHelper#t \n- ActionView::Helpers::FormHelper#form_for(record, options={}, &block)\n- ActionView::Helpers::FormHelper#text_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#file_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#hidden_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#password_field(object_name, method, options={})\n- ActionView::Helpers::FormHelper#radio_button(object_name, method, tag_value, options={})\n- ActionView::Helpers::FormBuilder#submit(value=nil, options={})\n- ActionView::Helpers::TranslationHelper#t\n- Phoenix Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun) Phoenix.HTML.Form.text_input(form, field, opts \\\\ []) Phoenix.HTML.Form.file_input(form, field, opts \\\\ []) Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ []) Phoenix.HTML.Form.password_input(form, field, opts \\\\ []) Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ []) Phoenix.HTML.Form.submit(opts, opts \\\\ []) Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{}) \n- Phoenix.HTML.Form.form_for(form_data, action, options \\\\ [], fun)\n- Phoenix.HTML.Form.text_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.file_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.hidden_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.password_input(form, field, opts \\\\ [])\n- Phoenix.HTML.Form.radio_button(form, field, value, opts \\\\ [])\n- Phoenix.HTML.Form.submit(opts, opts \\\\ [])\n- Gettext.dgettext(backend, domain, msgid, bindings \\\\ %{})   > WRAPUPWRAPUP \n\n前回もそうですが、コードのマイグレーションはまあ地味な作業ですよね。とまれ、認証機能を実装できたので良しとしましょう。"},"name":"[2018-05-20]連載 Rails2Phoenix 2 認証機能を実装する","tags":["phoenix-framework","elixir","ruby-on-rails","ruby","wercker","heroku","authentication","guardian"],"childPublishedDate":{"published_on":"2018-05-20T00:00:00.000Z","published_on_unix":1526774400}}},{"node":{"number":59,"relative_category":"blog/backend","fields":{"title":"連載 Rails2Phoenix 1 UmbrellaプロジェクトをHerokuにデプロイする","excerpt":"使い慣れたRailsのプロジェクトを拡張したいのですが、その都度技術スタックを増やす必要があり、この点をどうにかクリアしたいと考えています。連載「Rails2Phoenix」になります、今回はフレームワークをElixir製のPhoenix Frameworkへと変更を試みました。   > PROBLEMPROBLEM \n\n- サービスについて 拡張にともない技術スタックがふえるのを抑えたい スケーラビリティのためのコストを抑えたい パフォーマンスをあげたい \n- 拡張にともない技術スタックがふえるのを抑えたい\n- スケーラビリティのためのコストを抑えたい\n- パフォーマンスをあげたい   > SOLUTIONSOLUTION \n\nというわけで、現在つかっているRailsをPhoenixに変更することにしました。方針は以下の通りで、今回はRailsから移行中のPhoenix UmbrellaプロジェクトをHerokuにデプロイする流れをとりあげます。 \n\n方針 \n\n- Railsから徐々にPhoenixに移行できるように いままでとおなじPaaS（Heroku） いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく いままでとおなじDB 移行完了までDBマイグレーションをしない \n- いままでとおなじPaaS（Heroku）\n- いままでとおなじレポジトリ ブランチ戦略は phoenix/base をベースに 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく \n- ブランチ戦略は phoenix/base をベースに\n- 気軽に参照できるようにRails関連ファイルは可能な限りのこしておく\n- いままでとおなじDB 移行完了までDBマイグレーションをしない \n- 移行完了までDBマイグレーションをしない\n- Phoenixは今後の拡張性をかんがえてUmbrellaプロジェクトで   > HerokuへのデプロイのながれHerokuへのデプロイのながれ \n\n基本的にドキュメント通り。   > Phoenixアプリケーションを作成Phoenixアプリケーションを作成 \n\nまず、こんな感じでPhoenixの骨組みをつくります。Phoenix関連のファイル apps/, deps/, config/config.exs, mix.exs, mix.lock が追加されます。   sh \n\n> cd rails_project > mix new . --umbrella > (cd ./apps && mix phx.new phoenix_app)   \n\n次に、既存のRailsでつくられたスキーマをPhoenixに移植します。Ripperをつかうとはかどります。ちなみに手動でスキーマをつくりたい場合は、CLI mix phx.gen.schema --no-migration Blog.Post blog_posts title:string で作成します。   rb \n\n# lib/tasks/convert_to_phoenix.rake # こちらはスキーマ移植タスクをPhoenix1.3用に改めたもの require 'ripper' require 'erb' require 'fileutils' namespace :db do namespace :schema do desc 'Convert schema from Rails to Phoenix' task convert_to_phoenix: :environment do ConvertSchemaForPhoenixService.call end end end class ConvertSchemaForPhoenixService class << self def call FileUtils.mkdir_p(File.join('tmp', 'models')) extract_activerecord_define_block( Ripper.sexp( Rails.root .join('db', 'schema.rb') .read ) ).select(&method(:create_table_block?)) .map(&method(:configuration)) .each do |conf| project_name = 'PhoenixApp' table_name = conf[:table_name] table_columns = conf[:table_columns].reject(&method(:reject_condition)) .map do |c| case c[:column_type] when 'text' then c[:column_type] = ':string' when 'datetime' then c[:column_type] = ':naive_datetime' when 'inet' then c[:column_type] = 'EctoNetwork.INET' else c[:column_type] = \":#{c[:column_type]}\" end c end File.write( File.join('tmp', 'models', \"#{conf[:table_name].singularize}.ex\"), template.result(binding) ) end end private def extract_activerecord_define_block(sexp) sexp.dig(1, 0, 2, 2) end def create_table_block?(activerecord_define_block_element_sexp) activerecord_define_block_element_sexp.dig(1, 1, 1) == 'create_table' rescue false end def extract_table_name(create_table_block_sexp) create_table_block_sexp.dig(1, 2, 1, 0, 1, 1, 1) end def extract_table_columns(create_table_block_sexp) create_table_block_sexp.dig(2, 2) end def extract_column_type(table_column_sexp) table_column_sexp.dig(3, 1) end def extract_column_name(table_column_sexp) # Return value of `t.index` is array like ['user_id']. if table_column_sexp.dig(4, 1, 0, 0) == :array return table_column_sexp.dig(4, 1, 0, 1).map { |e| e.dig(1, 1, 1) } end table_column_sexp.dig(4, 1, 0, 1, 1, 1) end def extract_column_option(table_column_sexp) # If is not `column_option`, then `table_column_sexp.dig(4, 1, 1, # 1)` method return nil. Set blank array ([]) for avoiding nil. table_column_sexp.dig(4, 1, 1, 1) || [] end def extract_option_key(column_option_sexp) # Remove colon for avoiding `null:`. column_option_sexp.dig(1, 1).gsub(/:\\z/, '') end def extract_option_value(column_option_sexp) if column_option_sexp.dig(2, 0) == :array return Array(column_option_sexp.dig(2, 1)).map { |e| e.dig(1, 1, 1) } end element = column_option_sexp.dig(2, 1) if element.class != Array return element end case element.dig(0) when :kw then element.dig(1) when :string_content then element.dig(1, 1) || '' end end def template ERB.new(<<'__EOD__', nil, '-') defmodule <%= project_name %>.<%= table_name.classify %> do use Ecto.Schema import Ecto.Changeset alias <%= project_name %>.<%= table_name.classify %> schema \"<%= table_name %>\" do<% table_columns.each do |c| %> field :<%= c[:column_name] -%>, <%= c[:column_type] -%> <% end %> timestamps inserted_at: :created_at end @doc false def changeset(%<%= table_name.classify %>{} = <%= table_name.singularize %>, attrs) do <%= table_name.singularize %> |> cast(attrs, [<%= table_columns.map { |c| \":\" << c[:column_name] }.join(\", \") -%>]) # |> validate_required([<%= table_columns.map { |c| \":\" << c[:column_name] }.join(\", \") -%>]) end end __EOD__ end def configuration(table) { table_name: extract_table_name(table), table_columns: extract_table_columns(table).map do |c| { column_name: extract_column_name(c), column_type: extract_column_type(c), column_option: Hash[extract_column_option(c).map { |o| [extract_option_key(o), extract_option_value(o)] }] } end } end def reject_condition(column) column[:column_name] =~ /\\A(created|updated)_at\\z/ || column[:column_type] == 'index' end end end     sh \n\n> rails db:schema:convert_to_phoenix   \n\n最後に、既存DBへはこんな感じで接続します。   config \n\n# rails_project/apps/phoenix_app/config/dev.exs config :phoenix_app, PhoenixApp.Repo, adapter: Ecto.Adapters.Postgres, url: System.get_env(\"DATABASE_URL\"), pool_size: 10, ssl: true     sh \n\n> (cd ./apps/phoenix_app/assets && npm install) > mix deps.get > mix phx.server     > デプロイのパイプラインを追加デプロイのパイプラインを追加 \n\nさて、既存のCI（Wercker）も更新しましょう。今回はPhoenix関連ブランチが更新された場合にのみ、関連パイプラインを走らせるように下記のように変更しました。 \n\nBEFORE \n\n- build (all branch) deploy.prod (master branch) \n- deploy.prod (master branch) \n\nAFTER \n\n- build (all branch) deploy.prod (master branch) deploy.phoenix.prod (phoenix/base branch) \n- deploy.prod (master branch)\n- deploy.phoenix.prod (phoenix/base branch)   yaml \n\n# wercker.yml deploy-phoenix-prod-heroku: steps: - add-ssh-key: host: github.com keyname: GITHUB - add-to-known_hosts: hostname: github.com fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 - heroku-deploy: key: $HEROKU_KEY user: $HEROKU_USER app-name: $HEROKU_APP_NAME install-toolbelt: true after-steps: - wantedly/pretty-slack-notify: webhook_url: ${SLACK_WEBHOOK_URL} channel: general     > Herokuアプリケーションを作成Herokuアプリケーションを作成 \n\n基本ドキュメントの説明通りです。Phoenix Umbrellaプロジェクトの注意点としては、ディレクトリの差異くらいでそれ以外は同じです。つまり、これ rails_project/config/prod.exs をこう rails_project/apps/phoenix_app/config/prod.exs 変更します。 \n\n1. Herokuアプリにビルドパックを適用   sh \n\n> heroku create --buildpack https://github.com/HashNuke/heroku-buildpack-elixir.git > heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git   \n\n2. 起動設定を準備   config \n\n# rails_project/elixir_buildpack.config erlang_version=19.1 elixir_version=1.4.2 always_rebuild=false pre_compile=\"pwd\" post_compile=\"pwd\" runtime_path=/app config_vars_to_export=(DATABASE_URL) config_vars_to_export=(DATABASE_POOL_SIZE)     config \n\n# rails_project/phoenix_static_buildpack.config phoenix_relative_path=apps/phoenix_app     config \n\n# rails_project/Procfile web: MIX_ENV=prod mix phx.server   \n\n3. 環境変数を適用 \n\nデータベース関連。   config \n\n# rails_project/apps/phoenix_app/config/prod.exs config :phoenix_app, PhoenixApp.Repo, adapter: Ecto.Adapters.Postgres, url: System.get_env(\"DATABASE_URL\"), pool_size: String.to_integer(System.get_env(\"DATABASE_POOL_SIZE\") || 10), ssl: true     sh \n\nheroku config:set DATABASE_URL=foo heroku config:set DATABASE_POOL_SIZE=bar   \n\nクレデンシャル関連。   sh \n\n> heroku config:set HEROKU_API_KEY=$(heroku auth:token) > heroku config:set SECRET_KEY_BASE=$(mix phx.gen.secret)     > WRAPUPWRAPUP \n\n大枠は想定通りすんなり進めることが出来ましたが、課題もいくつか出てきました。まずは認証機能。こちらは次回のテーマで取り上げようと思いますが、Railsの認証ライブラリほど充実していないので自前でいくつか用意する必要がありそうです。次にビジネスロジック。これは元のRailsの実装が悪かったので致し方ないのですが、移植するのに時間がかかりそうです。先にRails側を整理してから進めた方が良いかもしれません。"},"name":"[2018-01-08]連載 Rails2Phoenix 1 UmbrellaプロジェクトをHerokuにデプロイする","tags":["phoenix-framework","elixir","ruby-on-rails","ruby","wercker","heroku"],"childPublishedDate":{"published_on":"2018-01-08T00:00:00.000Z","published_on_unix":1515369600}}},{"node":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。可読性が高いシンタックスを持ち、ワンバイナリーをクロスコンパイルでき、かつ、クライアント用のUIコンポーネントを標準ライブラリに備えたプログラミング言語です。その野心的な挑戦にすぐに虜になりました。新年早々の恋です。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- 今回作ったコード https://github.com/nabinno/esa.red    > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、 docs.red-lang.org とRed by Exampleをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装しました。 \n\n- 実装した糖衣構文 nabinno/red-elixir  \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。"},"name":"[2019-03-31]イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","tags":["red","esa"],"childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z","published_on_unix":1553990400}}}]}},"pageContext":{"number":56}},"staticQueryHashes":[]}