{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/56","result":{"data":{"esaPost":{"number":56,"relative_category":"blog/backend","fields":{"title":"RubyのCSVパースをPyCallで実行する（ベンチマーク）","excerpt":"先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。   > PROBLEMPROBLEM \n\n- 大量のCSVを読み込む際、毎回時間がかかる   > SOLUTIONSOLUTION \n\nというわけで、「Dalibor Nasevicのベンチマーク記事」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り CSV.foreach が速いとの結論でした。    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0      > PyCallのベンチマークPyCallのベンチマーク \n\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。   ruby \n\nrequire_relative './helpers' require 'pycall/import' include PyCall::Import pyimport :pandas, as: :pd print_memory_usage do print_time_spent do csv = pd.read_csv.('data.csv') sum = csv['id'].sum.() puts \"Sum: #{sum}\" end end   \n\nPyCallは pyenv との相性が悪いのでSystemインストールしたPythonでたたきます。   sh \n\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb Sum: 499999500000 Time: 1.49 Memory: 54.99 MB   \n\n結果    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0   6. PyCall 1.49 54.99    \n\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった CSV.foreach より16倍の実行速度となりました。   > WRAPUPWRAPUP \n\nPyCallのオブジェクトが PyObjectとActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。 \n\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png"},"wip":false,"body_md":"<img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\">\r\n\r\n先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。\r\n\r\n# PROBLEM\r\n- 大量のCSVを読み込む際、毎回時間がかかる\r\n\r\n# SOLUTION\r\nというわけで、「[Dalibor Nasevicのベンチマーク記事](https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby)」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り `CSV.foreach` が速いとの結論でした。\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n\r\n## PyCallのベンチマーク\r\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。\r\n\r\n```ruby\r\nrequire_relative './helpers'\r\nrequire 'pycall/import'\r\ninclude PyCall::Import\r\npyimport :pandas, as: :pd\r\n\r\nprint_memory_usage do\r\n  print_time_spent do\r\n    csv = pd.read_csv.('data.csv')\r\n    sum = csv['id'].sum.()\r\n    puts \"Sum: #{sum}\"\r\n  end\r\nend\r\n```\r\n\r\nPyCallは `pyenv` との相性が悪いのでSystemインストールしたPythonでたたきます。\r\n\r\n```sh\r\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb\r\nSum: 499999500000\r\nTime: 1.49\r\nMemory: 54.99 MB\r\n```\r\n\r\n**結果**\r\n\r\n| kind_of_parse                      | time (real) | memory (MB) |\r\n|------------------------------------|-------------|-------------|\r\n| 1. `CSV.read`                      |       39.13 |       866.6 |\r\n| 2. `CSV.parse`                     |       36.16 |      936.87 |\r\n| 3. line by line from String Object |       23.39 |       73.42 |\r\n| 4. line by line from IO Object     |       24.55 |         0.0 |\r\n| 5. `CSV.foreach`                   |       24.04 |         0.0 |\r\n| 6. PyCall                          |        1.49 |       54.99 |\r\n\r\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった `CSV.foreach` より16倍の実行速度となりました。\r\n\r\n# WRAPUP\r\nPyCallのオブジェクトが `PyObject`とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。\r\n\r\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1920\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/11/97367/180665c6-7370-4579-8340-7be6254834e8.png\"></a>\n<p data-sourcepos=\"3:1-3:290\">先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。</p>\n<h1 data-sourcepos=\"5:1-5:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"6:1-7:0\">\n<li data-sourcepos=\"6:1-7:0\">大量のCSVを読み込む際、毎回時間がかかる</li>\n</ul>\n<h1 data-sourcepos=\"8:1-8:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"9:1-9:307\">というわけで、「<a href=\"https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby\" target=\"_blank\" rel=\"noopener noreferrer\">Dalibor Nasevicのベンチマーク記事</a>」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り <code>CSV.foreach</code> が速いとの結論でした。</p>\n<table data-sourcepos=\"11:1-17:66\">\n<thead>\n<tr data-sourcepos=\"11:1-11:66\">\n<th data-sourcepos=\"11:2-11:37\">kind_of_parse</th>\n<th data-sourcepos=\"11:39-11:51\">time (real)</th>\n<th data-sourcepos=\"11:53-11:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"13:1-13:66\">\n<td data-sourcepos=\"13:2-13:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"13:39-13:51\">39.13</td>\n<td data-sourcepos=\"13:53-13:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"14:1-14:66\">\n<td data-sourcepos=\"14:2-14:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"14:39-14:51\">36.16</td>\n<td data-sourcepos=\"14:53-14:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"15:1-15:66\">\n<td data-sourcepos=\"15:2-15:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"15:39-15:51\">23.39</td>\n<td data-sourcepos=\"15:53-15:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"16:1-16:66\">\n<td data-sourcepos=\"16:2-16:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"16:39-16:51\">24.55</td>\n<td data-sourcepos=\"16:53-16:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"17:1-17:66\">\n<td data-sourcepos=\"17:2-17:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"17:39-17:51\">24.04</td>\n<td data-sourcepos=\"17:53-17:65\">0.0</td>\n</tr>\n</tbody>\n</table>\n<h2 data-sourcepos=\"19:1-19:30\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"PyCallのベンチマーク\" name=\"PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" href=\"#PyCall%E3%81%AE%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PyCallのベンチマーク\"> &gt; PyCallのベンチマーク</span></a>PyCallのベンチマーク</h2>\n<p data-sourcepos=\"20:1-20:111\">それでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。</p>\n<div class=\"code-block\" data-sourcepos=\"22:1-35:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>ruby</div>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"nb\">require_relative</span> <span class=\"s1\">'./helpers'</span>\n<span class=\"nb\">require</span> <span class=\"s1\">'pycall/import'</span>\n<span class=\"kp\">include</span> <span class=\"no\">PyCall</span><span class=\"o\">::</span><span class=\"no\">Import</span>\n<span class=\"n\">pyimport</span> <span class=\"ss\">:pandas</span><span class=\"p\">,</span> <span class=\"ss\">as: :pd</span>\n\n<span class=\"n\">print_memory_usage</span> <span class=\"k\">do</span>\n  <span class=\"n\">print_time_spent</span> <span class=\"k\">do</span>\n    <span class=\"n\">csv</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"nf\">read_csv</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"s1\">'data.csv'</span><span class=\"p\">)</span>\n    <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">csv</span><span class=\"p\">[</span><span class=\"s1\">'id'</span><span class=\"p\">].</span><span class=\"nf\">sum</span><span class=\"o\">.</span><span class=\"p\">()</span>\n    <span class=\"nb\">puts</span> <span class=\"s2\">\"Sum: </span><span class=\"si\">#{</span><span class=\"n\">sum</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n</div>\n<p data-sourcepos=\"37:1-37:102\">PyCallは <code>pyenv</code> との相性が悪いのでSystemインストールしたPythonでたたきます。</p>\n<div class=\"code-block\" data-sourcepos=\"39:1-44:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>sh</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ PYTHON</span><span class=\"o\">=</span>/usr/bin/python3.4 ruby parse_6_pycall.rb\nSum: 499999500000\nTime: 1.49\nMemory: 54.99 MB\n</code></pre></div>\n</div>\n<p data-sourcepos=\"46:1-46:10\"><strong>結果</strong></p>\n<table data-sourcepos=\"48:1-55:66\">\n<thead>\n<tr data-sourcepos=\"48:1-48:66\">\n<th data-sourcepos=\"48:2-48:37\">kind_of_parse</th>\n<th data-sourcepos=\"48:39-48:51\">time (real)</th>\n<th data-sourcepos=\"48:53-48:65\">memory (MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr data-sourcepos=\"50:1-50:66\">\n<td data-sourcepos=\"50:2-50:37\">1. <code>CSV.read</code>\n</td>\n<td data-sourcepos=\"50:39-50:51\">39.13</td>\n<td data-sourcepos=\"50:53-50:65\">866.6</td>\n</tr>\n<tr data-sourcepos=\"51:1-51:66\">\n<td data-sourcepos=\"51:2-51:37\">2. <code>CSV.parse</code>\n</td>\n<td data-sourcepos=\"51:39-51:51\">36.16</td>\n<td data-sourcepos=\"51:53-51:65\">936.87</td>\n</tr>\n<tr data-sourcepos=\"52:1-52:66\">\n<td data-sourcepos=\"52:2-52:37\">3. line by line from String Object</td>\n<td data-sourcepos=\"52:39-52:51\">23.39</td>\n<td data-sourcepos=\"52:53-52:65\">73.42</td>\n</tr>\n<tr data-sourcepos=\"53:1-53:66\">\n<td data-sourcepos=\"53:2-53:37\">4. line by line from IO Object</td>\n<td data-sourcepos=\"53:39-53:51\">24.55</td>\n<td data-sourcepos=\"53:53-53:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"54:1-54:66\">\n<td data-sourcepos=\"54:2-54:37\">5. <code>CSV.foreach</code>\n</td>\n<td data-sourcepos=\"54:39-54:51\">24.04</td>\n<td data-sourcepos=\"54:53-54:65\">0.0</td>\n</tr>\n<tr data-sourcepos=\"55:1-55:66\">\n<td data-sourcepos=\"55:2-55:37\">6. PyCall</td>\n<td data-sourcepos=\"55:39-55:51\">1.49</td>\n<td data-sourcepos=\"55:53-55:65\">54.99</td>\n</tr>\n</tbody>\n</table>\n<p data-sourcepos=\"57:1-57:150\">はい、結果が出ました。Daliborのベンチマーク記事で一番速かった <code>CSV.foreach</code> より16倍の実行速度となりました。</p>\n<h1 data-sourcepos=\"59:1-59:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"60:1-60:248\">PyCallのオブジェクトが <code>PyObject</code>とActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。</p>\n<p data-sourcepos=\"62:1-62:105\">ただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。</p>\n","tags":["ruby","benchmark","pycall"],"updated_at":"2021-01-16T10:27:34+09:00","childPublishedDate":{"published_on":"2017-06-05T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_7b757a0db07cde6a337af7df901ab0c5.jpg"}},"relatedPosts":{"edges":[{"node":{"number":70,"relative_category":"blog/market","fields":{"title":"就職氷河期とは何だったのか","excerpt":"私はいわゆる就職氷河期世代です。周囲から時折漏れ聞こえる不平のような言葉がありますが、それを単なる不平として片付けるのはもったいない気がします。できれば、その中に新しい視点を見つけ、次のチャンスへ繋げたいと思っています。   > PROBLEMPROBLEM \n\n- リセッション（景気後退）に直面した若者たちは、就職に関する不満や不平を抱えている\n- 周囲から聞こえてくる否定的な声が、彼らの意欲や展望を損ねている可能性がある\n- 経済の不安定性や求人の減少などの要因により、採用マーケットが厳しい状況にある\n- 若者たちが持つ可能性や才能が、現状の困難な状況によって十分に引き出されていない  > SOLUTIONSOLUTION \n\nそこで、リセッションと大卒の就職率の関係について、また、就職氷河期が単なる経済後退だけではなかったのか、その歴史をじっくりと解き明かしてみたいと思います。  > そもそもリセッションとは何か、どのタイミングで起きるのかそもそもリセッションとは何か、どのタイミングで起きるのか \n\nリセッションとは、経済の景気が一時的に悪化し、生産や雇用が減少する現象を指します。これは通常、国内総生産（GDP）が連続する2つの四半期でマイナス成長する状態になることで定義されます。リセッションはさまざまな要因によって引き起こされ、金融危機や需要減少などが主な原因とされています。  > 新卒採用マーケットについて新卒採用マーケットについて \n\n新卒採用マーケットとは、新卒学生が卒業後に就職を選ぶ際に選択できる求人の数や質を指します。景気の好悪や産業の動向などが影響を及ぼし、景気が良い時には多くの求人が出てくる一方、景気が悪化すると求人数が減少し、競争も激化します。  > リセッションと大卒の就職率の関係とその歴史リセッションと大卒の就職率の関係とその歴史 \n\n統計局の「学校基本調査 年次統計総括表 5 就職率（1950年～）」 から得られたデータに基づくチャートを見ると、リセッションが大卒の就職率にどのような影響を与えたのかがはっきりと分かります。     年 イベント 翌々年大卒の就職率 内閣     1987 ブラックマンデー 79.6% 中曽根/竹下   1997 アジア通貨危機 60.1% 橋本内閣   2000-2004 就職氷河期 55.8% 小渕/森内閣   2008 リーマンショック 60.8% 福田内閣   2020 コロナクラッシュ ??? 安倍/管内閣    \n\n1987年のブラックマンデーに起因するリセッションでは、大卒の就職率が79.6%まで落ち込みました。その後もアジア通貨危機やリーマンショック、そして最近のコロナクラッシュによって、大卒の就職率は変動しています。特に2000年から2004年にかけての就職氷河期では、大卒の就職率が55.8%にまで低下しました。  > アジア通貨危機はなぜ尾を引いていたのかアジア通貨危機はなぜ尾を引いていたのか \n\nアジア通貨危機は、1997年にアジア諸国で発生した経済危機であり、その影響は就職氷河期世代にも長期間にわたって影響を及ぼしました。この危機が尾を引いた理由は以下の点にあります。 \n\n1. 金融システムの崩壊: アジア通貨危機は、一部のアジア諸国で急激な通貨の暴落や金融システムの崩壊を引き起こしました。このため、企業や金融機関が多額の損失を被り、経済全体が深刻な打撃を受けました。経済基盤の崩壊は、就職機会の減少や企業の採用停止などをもたらしました。 \n2. 経済の停滞: アジア諸国の経済は通貨危機後、停滞期に入りました。このため、企業の業績が悪化し、新卒採用の余裕がなくなりました。経済の停滞は、若者たちの就職機会を減少させる一因となりました。 \n3. 信用の低下: 通貨危機により多くの企業が経営危機に陥り、信用が低下しました。これによって、企業が採用活動を控える傾向が生まれ、新卒の求人数が減少しました。就職氷河期世代は、この信用の低下によって求人市場が厳しさを増した現実を直面しました。 \n4. 失業率の上昇: アジア通貨危機により多くの企業が倒産し、失業率が上昇しました。失業者が増加する状況は、求職者同士の競争を激化させ、新卒の就職活動を難しくしました。この影響は就職氷河期世代にも及びました。  \n\nこれらの要因により、アジア通貨危機は長期的な影響をもたらし、若者たちの就職機会やキャリア形成に深刻な影響を与えました。しかし、この困難な状況に対して克服の道を見つけ、自己成長と前向きな姿勢を持つことが、就職氷河期世代の未来への道を切り拓く鍵となったのです。  > WRAPUPWRAPUP \n\n今回は、リセッションの歴史とその背後にある要因について深く考察してみました。リセッションと新卒採用マーケットの動向が、大卒の就職率にどのような影響を与えるかを理解することは、今後のキャリアにおいて重要です。常に社会経済の変動に柔軟に対応し、新たな視点を持って未来を切り開いていくことが大切です。"},"name":"[2021-01-23]就職氷河期とは何だったのか","tags":["labor-economics","recession","employment-ice-age"],"childPublishedDate":{"published_on":"2021-01-23T00:00:00.000Z","published_on_unix":1611360000}}},{"node":{"number":90,"relative_category":"blog/backend","fields":{"title":"yubinbango-dataをどうやって生成するか","excerpt":"郵便番号から住所を補完するライブラリ「yubinbango」を継続的に利用するにあたり、当該ライブラリが参照している郵便データ「yubinbango-data」を自前でメンテナンスできるか確認します。   > PROBLEMPROBLEM \n\n- 「yubinbango/yubinbango」を利用するにあたり「yubinbango/yubinbango-data」の更新が継続的に行われるかサービス継続性の懸念がある そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい \n- そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい  > SOLUTIONSOLUTION \n\nというわけで、yubinbango-dataの中身であるken_all.csvとjigyosyo.csvを安定して変換する方法を確認します。  > ken_all.csvを正規化するken_all.csvを正規化する \n\nyubinbango-dataのken_all.csvの部分はアイビスが提供しているzipcloudを参照しているようなので、そちらに合わせて利用します。 sh\n\nsudo apt install nkf { curl -sSL \"http://zipcloud.ibsnet.co.jp/zipcodedata/download?di=1625040649647\" -o ./x_ken_all.zip; unzip -p x_ken_all.zip | nkf -w; rm x_ken_all.zip } >ken_all.csv  \n\nzipcloudを使うことに抵抗がある場合はgokenallもありますが、正規化によって一つの郵便番号に複数の町名番地が存在するため郵便番号をキーとするyubinbango-dataに変換する際には工夫が必要です。 sh\n\ngo get github.com/oirik/gokenall/cmd/kenall { kenall download -x | kenall normalize } >ken_all.csv   > jigyosyo.csvを取得するjigyosyo.csvを取得する \n\njigyosyo.csvは特に正規化は必要ないです。 sh\n\n{ curl -sSL https://www.post.japanpost.jp/zipcode/dl/jigyosyo/zip/jigyosyo.zip -o ./jigyosyo.zip; unzip -p jigyosyo.zip | nkf -w; rm jigyosyo.zip } >jigyosyo.csv   > yubinbango-dataを生成するyubinbango-dataを生成する \n\nken_all.csvとjigyosyo.csvをUNIONしてjqで郵便番号をキーとしたオブジェクトに変換します。一部buildingカラムがnullを持っておりyubinbango-dataと異なる部分はありますが、大凡同等の状態にまで持っていくことが出来ました。 sh\n\nbrew install noborus/tap/trdsql for i in {001..999}; do trdsql -ojson \" SELECT * FROM ( SELECT c3 zip, c8 city, c9 town, NULL building FROM ken_all.csv UNION SELECT c8 zip, c5 city, c6 town, c7 building FROM jigyosyo.csv ) WHERE SUBSTRING(zip,0,4) = '$i' ORDER BY zip ASC \" \\ | jq --compact-output ' . | to_entries | map({ (.value.zip): [1, .value.city, .value.town, .value.building] }) | add ' \\ | sed -E 's/(.+?)/$yubin(\\1);/g' \\ >$i.js; done   > WRAPUPWRAPUP \n\n昔から何かと話題に上がるken_all.csvですが、正規化のサービスに加えCSV用SQLクライアントとjqの登場により思った以上に簡単に変換することができました。"},"name":"[2021-07-25]yubinbango-dataをどうやって生成するか","tags":["yubinbango","ken_all.csv","jq","trdsql"],"childPublishedDate":{"published_on":"2021-07-25T00:00:00.000Z","published_on_unix":1627171200}}},{"node":{"number":67,"relative_category":"blog/frontend","fields":{"title":"esaをHeadless CMSとして使う","excerpt":"最近仕事の同僚からHeadless CMS という言葉を聞いていて「自分には関係ないな」と距離を取っていたのですが、なぜか回り回って自分からHeadless CMSを作ることになりました。世の中何が起きるか分からないですね。   > PROBLEMPROBLEM \n\n- ブログを普段書かない人なのだが、よそ向けに情報発信する必要が出てきた とは言っても、今までMarkdownをJekyllで管理していたので画像を貼り付けるのが手間でモチベーションが大きく下がっていた さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった \n- とは言っても、今までMarkdownをJekyllで管理していたので画像を貼り付けるのが手間でモチベーションが大きく下がっていた さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった \n- さらにPlantUMLを出力するのも手間、試行錯誤した末にいずれも付け焼き刃で、esaの操作感に勝てるものはなかった  > SOLUTIONSOLUTION \n\nというわけで、esaをHeadless CMSとして使うことにしました。 \n\nやってることは昔のMovableTypeそのもので懐かしかったです。コンテンツを別システムで管理しビルドサーバーに当該コンテンツを流し込みリビルド、最後にホストサーバーにアップロードというワークフロー。今はJAMStackの文脈で語られているようです。 \n\nこのHeadless CMSが昔と違うのはコンテンツ作成に集中できること。CI周りが発達したので一度ワークフローを組み立てれば後は自動でコンテンツを生成できます。  > やり方やり方 \n\n- esa.io でゆるふわ情報共有 - Middleman Blog への Export サンプル付き #esa_io - Qiita\n- 技術ブログを支える技術（Gatsby + esaio） - mottox2 blog\n- Next.jsとesaを使った個人サイト構築 | corocn.dev \n\nそれほど時間をかけられなかったので、上記3記事の中で手軽さを考慮しmottox2さんのソースコードを拝借しました。ありがとうございます。 \n\n- 作ったレポジトリ：nabinno/nabinno.github.io: On Blahfe - Nab's Github Pages  > シークエンス図シークエンス図 \n\n私が手を入れたのはコンポーネントを削りGatsby Blog Starterに寄せたのと、デプロイ方法を使い慣れたCircleCIに変えたくらいです。 \n\nGitHub PagesにはVercelのような便利なWebhookがないので、esaで実装されたGitHub Webhook連携を使いそれをトリガーにCircleCIジョブを走らせています。 \n\n  > CircleCIジョブCircleCIジョブ \n\nまた、CircleCIジョブは何の変哲もないもので、NodeJSを叩いてGitプッシュしているくらいです。先ほどのGitHub Webhookと似た感じの泥臭いワークフローは [skip ci] コメントの追加があります。当該コメントを入れないとジョブが再帰的に走り続けるので出口で明示してあります。 yml\n\nversion: 2.1 jobs: build_deploy: docker: - image: circleci/node:12.4 steps: - checkout - run: name: Install NPM command: npm install - run: name: Build command: npm run clean && npm run build - add_ssh_keys: fingerprints: - \"{foo}\" - deploy: name: Deploy command: | git config --global user.email \"nab+circleci@blahfe.com\" git config --global user.name \"nabinno+circleci\" git add . git commit -m \"[skip ci]Run npm run clean && npm run build.\" git push origin master workflows: build_deploy: jobs: - build_deploy: filters: branches: only: master   > WRAPUPWRAPUP \n\nとまあ大した作業内容ではないのですが、久しぶりに昔懐かしのMovableTypeのリビルドを思い出しつつ、副産物として全く縁遠かったNetlifyとVercelの位置づけを薄らと感じ取れました。"},"name":"[2021-01-18]esaをHeadless CMSとして使う","tags":["gatsby","esa","headless-cms","cms"],"childPublishedDate":{"published_on":"2021-01-18T00:00:00.000Z","published_on_unix":1610928000}}}]}},"pageContext":{"number":56}},"staticQueryHashes":[]}