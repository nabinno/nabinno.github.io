{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/58","result":{"data":{"esaPost":{"number":58,"relative_category":"blog/backend","fields":{"title":"WSL（Windows Subsystem for Linux）でDockerをつかったWebアプリケーション開発をおこなう際の注意点","excerpt":"これは無宗教ななびの  が書くDocker Advent Calendar 2017用記事です。前日はinductorさんの「Docker Meetupの中身まとめ」でした  （写真はクリスマスを日本にひろめた明治屋 ）   > PROBLEMPROBLEM \n\n- macOSとWindowsでWebアプリケーション開発をする際に 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- ただ、実際どこまで開発ができるかわからんしなあ   > SOLUTIONSOLUTION \n\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。 \n\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。 \n\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。   > 対象環境対象環境 \n\n- Windows 10 Pro 1709 16299.64 Hyper-V 10.0.16299.15 Docker for Windows 17.09.0-ce-win33 Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Hyper-V 10.0.16299.15\n- Docker for Windows 17.09.0-ce-win33\n- Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Docker Client 1.12.6   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- Windows Subsystem for Linuxをインストールしてみよう！ \n\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。 \n\n1. apt WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します \n2. WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\n3. anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます \n4. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n5. exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\n6. nix ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n7. ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n8. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。 \n\n- WSLtty Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 \n- ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\n- EmacsでCtrl-SPC set-mark が機能する\n- 画面サイズの変更が柔軟\n- Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- PowerShellなどほかのコンソールの呼び出しが面倒\n- ConEmu Pros PowerShellなどほかのコンソールの呼び出しが楽 Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- Pros PowerShellなどほかのコンソールの呼び出しが楽 \n- PowerShellなどほかのコンソールの呼び出しが楽\n- Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- ファイルの読込速度がおそい\n- EmacsでCtrl-SPC set-mark が機能しない\n- 画面サイズの変更に制限がある   > WSLttyWSLtty \n\n- mintty/wsltty \n\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは chsh がつかえないのでログイン時につかいたいシェルを指定します。もし、 screen をつかいたい場合は /run/screen ディレクトリを作成してからコマンド指定します。   bat \n\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'   ConEmu \n\n- ConEmu - Handy Windows Terminal \n\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい1のでおすすめしません。 \n\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。   bash \n\n# task parameters /icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\" # task command bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%     > Docker for WindowsのインストールDocker for Windowsのインストール \n\n- Docker For Windows \n\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。 \n\n構成は下記のようになります。  \n\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 DOCKER_HOST をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。 \n\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\n2. WSL上のDockerクライアントに DOCKER_HOST=tcp://0.0.0.0:2375 を設定 \n\nWSLには下記のようなaliasを用意しておくといいでしょう。   bash \n\nexport DOCKER_HOST=tcp://0.0.0.0:2375 alias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\" alias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"     > さて、WSLからDocker for Windowsはどの程度つかえるのかさて、WSLからDocker for Windowsはどの程度つかえるのか \n\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。 \n\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\n2. WSLはLinux形式のパスしか扱えません、C:\\Dev のようなドライブ名にコロンをつけたURIスキーマは扱えません\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません2 \n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります3  \n\nひとつずつ解決方法を見ていきましょう。   > 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません \n\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。   > 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません \n\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。   bash \n\n$ ln -s /mnt/c /C # 開発ディレクトリはこんな感じで参照できます $ ls -al /C/Dev total 0 drwxrwxrwx 0 root root 512 Oct 27 00:54 . drwxrwxrwx 0 root root 512 Dec 8 07:49 .. drwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1 drwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2     > 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません \n\n各OS間での違いを吸収するため、プロジェクトに PRJ_ROOT のような環境変数を用意しましょう。   yaml \n\nservices: app-front: image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front volumes: - ${PRJ_ROOT}/front:/var/www/front     > 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります \n\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました  \n\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。   bash \n\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules $ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules     > WRAPUPWRAPUP \n\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。 \n\n随時、気になる課題が出てきたら追記します。  \n\n1. https://github.com/cmderdev/cmder/issues/901 ↩ \n2. https://github.com/docker/compose/issues/4039#issuecomment-269558432 ↩ \n3. https://github.com/Microsoft/WSL/issues/2448 ↩","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png"},"wip":false,"body_md":"<img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\">\r\n\r\n\r\nこれは無宗教ななびの :construction_worker: が書く[Docker Advent Calendar 2017](https://qiita.com/advent-calendar/2017/docker)用記事です。前日はinductorさんの「[Docker Meetupの中身まとめ](https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e)」でした :whale: （写真は[クリスマスを日本にひろめた明治屋](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3) :christmas_tree:）\r\n\r\n# PROBLEM\r\n- macOSとWindowsでWebアプリケーション開発をする際に\r\n    - 環境が異なって管理しづらい\r\n        - それならDockerで\r\n            - と思ったが、macOSはBashでWindowsはPowerShellなのか\r\n                - せめてPowerShellではなくBash...\r\n                    - となると、いまWindowsでLinux環境をつかうならWSLか\r\n                        - ただ、実際どこまで開発ができるかわからんしなあ\r\n\r\n# SOLUTION\r\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。\r\n\r\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。\r\n\r\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。\r\n\r\n## 対象環境\r\n- Windows 10 Pro 1709 16299.64\r\n    - Hyper-V 10.0.16299.15\r\n    - Docker for Windows 17.09.0-ce-win33\r\n    - Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\r\n        - Docker Client 1.12.6\r\n\r\n## Windowsの開発環境を構築する\r\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。\r\n\r\n### WSLのインストール\r\n- [Windows Subsystem for Linuxをインストールしてみよう！](https://qiita.com/Aruneko/items/c79810b0b015bebf30bb)\r\n\r\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。\r\n1. apt\r\n    - WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\r\n2. [anyenv](https://github.com/riywo/anyenv)\r\n    - プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\r\n    - exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\r\n3. [nix](https://nixos.org/nix/)\r\n    - ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\r\n    - また、aptのバージョンが古すぎるパッケージもnixが最適です\r\n\r\n### ターミナルのインストール\r\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。\r\n\r\n- WSLtty\r\n    - Pros\r\n        - ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\r\n        - EmacsでCtrl-SPC `set-mark` が機能する\r\n        - 画面サイズの変更が柔軟\r\n    - Cons\r\n        - PowerShellなどほかのコンソールの呼び出しが面倒\r\n- ConEmu\r\n    - Pros\r\n        - PowerShellなどほかのコンソールの呼び出しが楽\r\n    - Cons\r\n        - ファイルの読込速度がおそい\r\n        - EmacsでCtrl-SPC `set-mark` が機能しない\r\n        - 画面サイズの変更に制限がある\r\n\r\n### WSLtty\r\n- [mintty/wsltty](https://github.com/mintty/wsltty)\r\n\r\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは `chsh` がつかえないのでログイン時につかいたいシェルを指定します。もし、 `screen` をつかいたい場合は `/run/screen` ディレクトリを作成してからコマンド指定します。\r\n\r\n```bat\r\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'\r\n```\r\n\r\n#### ConEmu\r\n- [ConEmu - Handy Windows Terminal](https://conemu.github.io/)\r\n\r\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい[^1]のでおすすめしません。\r\n\r\n[^1]: [https://github.com/cmderdev/cmder/issues/901](https://github.com/cmderdev/cmder/issues/901)\r\n\r\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。\r\n\r\n```bash\r\n# task parameters\r\n/icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\"\r\n\r\n# task command\r\nbash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%\r\n```\r\n\r\n### Docker for Windowsのインストール\r\n- [Docker For Windows](https://www.docker.com/docker-windows)\r\n\r\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。\r\n\r\n構成は下記のようになります。\r\n\r\n<img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\">\r\n\r\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 `DOCKER_HOST` をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。\r\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\r\n2. WSL上のDockerクライアントに `DOCKER_HOST=tcp://0.0.0.0:2375` を設定\r\n\r\nWSLには下記のようなaliasを用意しておくといいでしょう。\r\n\r\n```bash\r\nexport DOCKER_HOST=tcp://0.0.0.0:2375\r\nalias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\"\r\nalias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"\r\n```\r\n\r\n## さて、WSLからDocker for Windowsはどの程度つかえるのか\r\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。\r\n\r\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n2. WSLはLinux形式のパスしか扱えません、`C:\\Dev` のようなドライブ名にコロンをつけたURIスキーマは扱えません\r\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません[^2]\r\n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります[^3]\r\n\r\n[^2]: [https://github.com/docker/compose/issues/4039#issuecomment-269558432](https://github.com/docker/compose/issues/4039#issuecomment-269558432)\r\n[^3]: [https://github.com/Microsoft/WSL/issues/2448](https://github.com/Microsoft/WSL/issues/2448)\r\n\r\nひとつずつ解決方法を見ていきましょう。\r\n\r\n### 1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。\r\n\r\n### 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\r\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。\r\n\r\n```bash\r\n$ ln -s /mnt/c /C\r\n\r\n# 開発ディレクトリはこんな感じで参照できます\r\n$ ls -al /C/Dev\r\ntotal 0\r\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 .\r\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\r\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\r\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\r\n```\r\n\r\n### 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\r\n各OS間での違いを吸収するため、プロジェクトに `PRJ_ROOT` のような環境変数を用意しましょう。\r\n\r\n```yaml\r\nservices:\r\n  app-front:\r\n    image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front\r\n    volumes:\r\n      - ${PRJ_ROOT}/front:/var/www/front\r\n```\r\n\r\n### 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\r\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました :tada:\r\n\r\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。\r\n\r\n```bash\r\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules\r\n$ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\r\n```\r\n\r\n# WRAPUP\r\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。\r\n\r\n随時、気になる課題が出てきたら追記します。\r\n\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\"></a>\n<p data-sourcepos=\"4:1-4:513\">これは無宗教ななびの <img class=\"emoji\" title=\":construction_worker:\" alt=\":construction_worker:\" src=\"https://assets.esa.io/images/emoji/unicode/1f477.png\"> が書く<a href=\"https://qiita.com/advent-calendar/2017/docker\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Advent Calendar 2017</a>用記事です。前日はinductorさんの「<a href=\"https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Meetupの中身まとめ</a>」でした <img class=\"emoji\" title=\":whale:\" alt=\":whale:\" src=\"https://assets.esa.io/images/emoji/unicode/1f433.png\"> （写真は<a href=\"https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3\" target=\"_blank\" rel=\"noopener noreferrer\">クリスマスを日本にひろめた明治屋</a> <img class=\"emoji\" title=\":christmas_tree:\" alt=\":christmas_tree:\" src=\"https://assets.esa.io/images/emoji/unicode/1f384.png\">）</p>\n<h1 data-sourcepos=\"6:1-6:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"7:1-14:0\">\n<li data-sourcepos=\"7:1-14:0\">macOSとWindowsでWebアプリケーション開発をする際に\n<ul data-sourcepos=\"8:5-14:0\">\n<li data-sourcepos=\"8:5-14:0\">環境が異なって管理しづらい\n<ul data-sourcepos=\"9:9-14:0\">\n<li data-sourcepos=\"9:9-14:0\">それならDockerで\n<ul data-sourcepos=\"10:13-14:0\">\n<li data-sourcepos=\"10:13-14:0\">と思ったが、macOSはBashでWindowsはPowerShellなのか\n<ul data-sourcepos=\"11:17-14:0\">\n<li data-sourcepos=\"11:17-14:0\">せめてPowerShellではなくBash...\n<ul data-sourcepos=\"12:21-14:0\">\n<li data-sourcepos=\"12:21-14:0\">となると、いまWindowsでLinux環境をつかうならWSLか\n<ul data-sourcepos=\"13:25-14:0\">\n<li data-sourcepos=\"13:25-14:0\">ただ、実際どこまで開発ができるかわからんしなあ</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"15:1-15:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"16:1-16:165\">というわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。</p>\n<p data-sourcepos=\"18:1-18:283\">前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。</p>\n<p data-sourcepos=\"20:1-20:135\">要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。</p>\n<h2 data-sourcepos=\"22:1-22:15\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"対象環境\" name=\"%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" href=\"#%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"対象環境\"> &gt; 対象環境</span></a>対象環境</h2>\n<ul data-sourcepos=\"23:1-28:0\">\n<li data-sourcepos=\"23:1-28:0\">Windows 10 Pro 1709 16299.64\n<ul data-sourcepos=\"24:5-28:0\">\n<li data-sourcepos=\"24:5-24:27\">Hyper-V 10.0.16299.15</li>\n<li data-sourcepos=\"25:5-25:41\">Docker for Windows 17.09.0-ce-win33</li>\n<li data-sourcepos=\"26:5-28:0\">Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\n<ul data-sourcepos=\"27:9-28:0\">\n<li data-sourcepos=\"27:9-28:0\">Docker Client 1.12.6</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 data-sourcepos=\"29:1-29:40\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"Windowsの開発環境を構築する\" name=\"Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" href=\"#Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Windowsの開発環境を構築する\"> &gt; Windowsの開発環境を構築する</span></a>Windowsの開発環境を構築する</h2>\n<p data-sourcepos=\"30:1-30:116\">まず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。</p>\n<h3 data-sourcepos=\"32:1-32:28\" id=\"2-2-1\" name=\"2-2-1\">\n<a class=\"anchor\" id=\"WSLのインストール\" name=\"WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLのインストール\"> &gt; WSLのインストール</span></a>WSLのインストール</h3>\n<ul data-sourcepos=\"33:1-34:0\">\n<li data-sourcepos=\"33:1-34:0\"><a href=\"https://qiita.com/Aruneko/items/c79810b0b015bebf30bb\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Subsystem for Linuxをインストールしてみよう！</a></li>\n</ul>\n<p data-sourcepos=\"35:1-35:91\">WSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。</p>\n<ol data-sourcepos=\"36:1-44:0\">\n<li data-sourcepos=\"36:1-37:153\">apt\n<ul data-sourcepos=\"37:5-37:153\">\n<li data-sourcepos=\"37:5-37:153\">WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します</li>\n</ul>\n</li>\n<li data-sourcepos=\"38:1-40:134\">\n<a href=\"https://github.com/riywo/anyenv\" target=\"_blank\" rel=\"noopener noreferrer\">anyenv</a>\n<ul data-sourcepos=\"39:5-40:134\">\n<li data-sourcepos=\"39:5-39:123\">プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう</li>\n<li data-sourcepos=\"40:5-40:134\">exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます</li>\n</ul>\n</li>\n<li data-sourcepos=\"41:1-44:0\">\n<a href=\"https://nixos.org/nix/\" target=\"_blank\" rel=\"noopener noreferrer\">nix</a>\n<ul data-sourcepos=\"42:5-44:0\">\n<li data-sourcepos=\"42:5-42:154\">ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう</li>\n<li data-sourcepos=\"43:5-44:0\">また、aptのバージョンが古すぎるパッケージもnixが最適です</li>\n</ul>\n</li>\n</ol>\n<h3 data-sourcepos=\"45:1-45:40\" id=\"2-2-2\" name=\"2-2-2\">\n<a class=\"anchor\" id=\"ターミナルのインストール\" name=\"%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"ターミナルのインストール\"> &gt; ターミナルのインストール</span></a>ターミナルのインストール</h3>\n<p data-sourcepos=\"46:1-46:174\">WSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。</p>\n<ul data-sourcepos=\"48:1-62:0\">\n<li data-sourcepos=\"48:1-54:74\">WSLtty\n<ul data-sourcepos=\"49:5-54:74\">\n<li data-sourcepos=\"49:5-52:43\">Pros\n<ul data-sourcepos=\"50:9-52:43\">\n<li data-sourcepos=\"50:9-50:87\">ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)</li>\n<li data-sourcepos=\"51:9-51:53\">EmacsでCtrl-SPC <code>set-mark</code> が機能する</li>\n<li data-sourcepos=\"52:9-52:43\">画面サイズの変更が柔軟</li>\n</ul>\n</li>\n<li data-sourcepos=\"53:5-54:74\">Cons\n<ul data-sourcepos=\"54:9-54:74\">\n<li data-sourcepos=\"54:9-54:74\">PowerShellなどほかのコンソールの呼び出しが面倒</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-sourcepos=\"55:1-62:0\">ConEmu\n<ul data-sourcepos=\"56:5-62:0\">\n<li data-sourcepos=\"56:5-57:71\">Pros\n<ul data-sourcepos=\"57:9-57:71\">\n<li data-sourcepos=\"57:9-57:71\">PowerShellなどほかのコンソールの呼び出しが楽</li>\n</ul>\n</li>\n<li data-sourcepos=\"58:5-62:0\">Cons\n<ul data-sourcepos=\"59:9-62:0\">\n<li data-sourcepos=\"59:9-59:49\">ファイルの読込速度がおそい</li>\n<li data-sourcepos=\"60:9-60:56\">EmacsでCtrl-SPC <code>set-mark</code> が機能しない</li>\n<li data-sourcepos=\"61:9-62:0\">画面サイズの変更に制限がある</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 data-sourcepos=\"63:1-63:10\" id=\"2-2-3\" name=\"2-2-3\">\n<a class=\"anchor\" id=\"WSLtty\" name=\"WSLtty\" href=\"#WSLtty\" data-position=\"2-2-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLtty\"> &gt; WSLtty</span></a>WSLtty</h3>\n<ul data-sourcepos=\"64:1-65:0\">\n<li data-sourcepos=\"64:1-65:0\"><a href=\"https://github.com/mintty/wsltty\" target=\"_blank\" rel=\"noopener noreferrer\">mintty/wsltty</a></li>\n</ul>\n<p data-sourcepos=\"66:1-66:477\">WSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは <code>chsh</code> がつかえないのでログイン時につかいたいシェルを指定します。もし、 <code>screen</code> をつかいたい場合は <code>/run/screen</code> ディレクトリを作成してからコマンド指定します。</p>\n<div class=\"code-block\" data-sourcepos=\"68:1-70:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bat</div>\n<div class=\"highlight\"><pre class=\"highlight batchfile\"><code><span class=\"nv\">%LOCALAPPDATA%</span>\\wsltty\\bin\\mintty.exe <span class=\"na\">--wsl -o </span><span class=\"kd\">Locale</span><span class=\"o\">=</span><span class=\"kd\">C</span> <span class=\"na\">-o </span><span class=\"kd\">Charset</span><span class=\"o\">=</span><span class=\"kd\">UTF</span><span class=\"o\">-</span><span class=\"m\">8</span> <span class=\"na\">/bin/wslbridge -t /bin/bash -c </span><span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span>\n</code></pre></div>\n</div>\n<h4 data-sourcepos=\"72:1-72:11\">ConEmu</h4>\n<ul data-sourcepos=\"73:1-74:0\">\n<li data-sourcepos=\"73:1-74:0\"><a href=\"https://conemu.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">ConEmu - Handy Windows Terminal</a></li>\n</ul>\n<p data-sourcepos=\"75:1-75:258\">WSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">1</a></sup>のでおすすめしません。</p>\n<p data-sourcepos=\"79:1-79:127\">ConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。</p>\n<div class=\"code-block\" data-sourcepos=\"81:1-87:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"c\"># task parameters</span>\n/icon <span class=\"s2\">\"C:</span><span class=\"se\">\\P</span><span class=\"s2\">rogram Files</span><span class=\"se\">\\W</span><span class=\"s2\">indowsApps</span><span class=\"se\">\\C</span><span class=\"s2\">anonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc</span><span class=\"se\">\\i</span><span class=\"s2\">mages</span><span class=\"se\">\\i</span><span class=\"s2\">con.ico\"</span>\n\n<span class=\"c\"># task command</span>\nbash <span class=\"nt\">-c</span> <span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span> <span class=\"nt\">-new_console</span>:d:%USERPROFILE%\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"89:1-89:43\" id=\"2-2-4\" name=\"2-2-4\">\n<a class=\"anchor\" id=\"Docker for Windowsのインストール\" name=\"Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Docker for Windowsのインストール\"> &gt; Docker for Windowsのインストール</span></a>Docker for Windowsのインストール</h3>\n<ul data-sourcepos=\"90:1-91:0\">\n<li data-sourcepos=\"90:1-91:0\"><a href=\"https://www.docker.com/docker-windows\" target=\"_blank\" rel=\"noopener noreferrer\">Docker For Windows</a></li>\n</ul>\n<p data-sourcepos=\"92:1-92:202\">WSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。</p>\n<p data-sourcepos=\"94:1-94:42\">構成は下記のようになります。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\"></a>\n<p data-sourcepos=\"98:1-98:240\">DockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 <code>DOCKER_HOST</code> をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。</p>\n<ol data-sourcepos=\"99:1-101:0\">\n<li data-sourcepos=\"99:1-99:118\">Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定</li>\n<li data-sourcepos=\"100:1-101:0\">WSL上のDockerクライアントに <code>DOCKER_HOST=tcp://0.0.0.0:2375</code> を設定</li>\n</ol>\n<p data-sourcepos=\"102:1-102:77\">WSLには下記のようなaliasを用意しておくといいでしょう。</p>\n<div class=\"code-block\" data-sourcepos=\"104:1-108:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nb\">export </span><span class=\"nv\">DOCKER_HOST</span><span class=\"o\">=</span>tcp://0.0.0.0:2375\n<span class=\"nb\">alias </span><span class=\"nv\">docker</span><span class=\"o\">=</span><span class=\"s2\">\"DOCKER_HOST=</span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\"> docker\"</span>\n<span class=\"nb\">alias </span>docker-compose<span class=\"o\">=</span><span class=\"s2\">\"docker-compose -H </span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\">\"</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"110:1-110:72\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\" name=\"%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" href=\"#%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\"> &gt; さて、WSLからDocker for Windowsはどの程度つかえるのか</span></a>さて、WSLからDocker for Windowsはどの程度つかえるのか</h2>\n<p data-sourcepos=\"111:1-111:189\">WSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。</p>\n<ol data-sourcepos=\"113:1-117:0\">\n<li data-sourcepos=\"113:1-113:120\">Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</li>\n<li data-sourcepos=\"114:1-114:146\">WSLはLinux形式のパスしか扱えません、<code>C:\\Dev</code> のようなドライブ名にコロンをつけたURIスキーマは扱えません</li>\n<li data-sourcepos=\"115:1-115:105\">WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">2</a></sup>\n</li>\n<li data-sourcepos=\"116:1-117:0\">WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">3</a></sup>\n</li>\n</ol>\n<p data-sourcepos=\"121:1-121:57\">ひとつずつ解決方法を見ていきましょう。</p>\n<h3 data-sourcepos=\"123:1-123:124\" id=\"2-3-1\" name=\"2-3-1\">\n<a class=\"anchor\" id=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\" name=\"1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\"> &gt; 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません</span></a>1. Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</h3>\n<p data-sourcepos=\"124:1-124:174\">開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。</p>\n<h3 data-sourcepos=\"126:1-126:129\" id=\"2-3-2\" name=\"2-3-2\">\n<a class=\"anchor\" id=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\" name=\"2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\"> &gt; 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</span></a>2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</h3>\n<p data-sourcepos=\"127:1-127:157\">NTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"129:1-139:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /mnt/c /C\n\n<span class=\"c\"># 開発ディレクトリはこんな感じで参照できます</span>\n<span class=\"nv\">$ </span><span class=\"nb\">ls</span> <span class=\"nt\">-al</span> /C/Dev\ntotal 0\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 <span class=\"nb\">.</span>\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"141:1-141:105\" id=\"2-3-3\" name=\"2-3-3\">\n<a class=\"anchor\" id=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\" name=\"3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\"> &gt; 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</span></a>3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</h3>\n<p data-sourcepos=\"142:1-142:128\">各OS間での違いを吸収するため、プロジェクトに <code>PRJ_ROOT</code> のような環境変数を用意しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"144:1-150:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"na\">app-front</span><span class=\"pi\">:</span>\n    <span class=\"na\">image</span><span class=\"pi\">:</span> <span class=\"s\">561534604247952616898.dkr.ecr.amazonaws.com/test/front</span>\n    <span class=\"na\">volumes</span><span class=\"pi\">:</span>\n      <span class=\"pi\">-</span> <span class=\"s\">${PRJ_ROOT}/front:/var/www/front</span>\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"152:1-152:104\" id=\"2-3-4\" name=\"2-3-4\">\n<a class=\"anchor\" id=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\" name=\"4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" href=\"#4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" data-position=\"2-3-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\"> &gt; 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</span></a>4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</h3>\n<p data-sourcepos=\"153:1-153:136\">こちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました <img class=\"emoji\" title=\":tada:\" alt=\":tada:\" src=\"https://assets.esa.io/images/emoji/unicode/1f389.png\"></p>\n<p data-sourcepos=\"155:1-155:160\">もし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"157:1-160:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">mkdir</span> /home/foo/tmp/app-test-1/front/node_modules\n<span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"162:1-162:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"163:1-163:198\">まだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。</p>\n<p data-sourcepos=\"165:1-165:63\">随時、気になる課題が出てきたら追記します。</p>\n<section class=\"footnotes\">\n<ol>\n<li id=\"fn1\">\n<p data-sourcepos=\"77:7-77:98\"><a href=\"https://github.com/cmderdev/cmder/issues/901\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/cmderdev/cmder/issues/901</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\">\n<p data-sourcepos=\"118:7-118:146\"><a href=\"https://github.com/docker/compose/issues/4039#issuecomment-269558432\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/docker/compose/issues/4039#issuecomment-269558432</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\">\n<p data-sourcepos=\"119:7-119:98\"><a href=\"https://github.com/Microsoft/WSL/issues/2448\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Microsoft/WSL/issues/2448</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","tags":["wsl","docker","ubuntu"],"updated_at":"2021-01-12T01:27:16+09:00","childPublishedDate":{"published_on":"2017-12-10T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":90,"relative_category":"blog/backend","fields":{"title":"yubinbango-dataをどうやって生成するか","excerpt":"郵便番号から住所を補完するライブラリ「yubinbango」を継続的に利用するにあたり、当該ライブラリが参照している郵便データ「yubinbango-data」を自前でメンテナンスできるか確認します。   > PROBLEMPROBLEM \n\n- 「yubinbango/yubinbango」を利用するにあたり「yubinbango/yubinbango-data」の更新が継続的に行われるかサービス継続性の懸念がある そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい \n- そこで自前でメンテナンスをする場合の対処方法を事前に知っておきたい  > SOLUTIONSOLUTION \n\nというわけで、yubinbango-dataの中身であるken_all.csvとjigyosyo.csvを安定して変換する方法を確認します。  > ken_all.csvを正規化するken_all.csvを正規化する \n\nyubinbango-dataのken_all.csvの部分はアイビスが提供しているzipcloudを参照しているようなので、そちらに合わせて利用します。 sh\n\nsudo apt install nkf { curl -sSL \"http://zipcloud.ibsnet.co.jp/zipcodedata/download?di=1625040649647\" -o ./x_ken_all.zip; unzip -p x_ken_all.zip | nkf -w; rm x_ken_all.zip } >ken_all.csv  \n\nzipcloudを使うことに抵抗がある場合はgokenallもありますが、正規化によって一つの郵便番号に複数の町名番地が存在するため郵便番号をキーとするyubinbango-dataに変換する際には工夫が必要です。 sh\n\ngo get github.com/oirik/gokenall/cmd/kenall { kenall download -x | kenall normalize } >ken_all.csv   > jigyosyo.csvを取得するjigyosyo.csvを取得する \n\njigyosyo.csvは特に正規化は必要ないです。 sh\n\n{ curl -sSL https://www.post.japanpost.jp/zipcode/dl/jigyosyo/zip/jigyosyo.zip -o ./jigyosyo.zip; unzip -p jigyosyo.zip | nkf -w; rm jigyosyo.zip } >jigyosyo.csv   > yubinbango-dataを生成するyubinbango-dataを生成する \n\nken_all.csvとjigyosyo.csvをUNIONしてjqで郵便番号をキーとしたオブジェクトに変換します。一部buildingカラムがnullを持っておりyubinbango-dataと異なる部分はありますが、大凡同等の状態にまで持っていくことが出来ました。 sh\n\nbrew install noborus/tap/trdsql for i in {001..999}; do trdsql -ojson \" SELECT * FROM ( SELECT c3 zip, c8 city, c9 town, NULL building FROM ken_all.csv UNION SELECT c8 zip, c5 city, c6 town, c7 building FROM jigyosyo.csv ) WHERE SUBSTRING(zip,0,4) = '$i' ORDER BY zip ASC \" \\ | jq --compact-output ' . | to_entries | map({ (.value.zip): [1, .value.city, .value.town, .value.building] }) | add ' \\ | sed -E 's/(.+?)/$yubin(\\1)/g' \\ >$i.js; done   > WRAPUPWRAPUP \n\n昔から何かと話題に上がるken_all.csvですが、正規化のサービスに加えCSV用SQLクライアントとjqの登場により思った以上に簡単に変換することができました。"},"name":"yubinbango-dataをどうやって生成するか","tags":["yubinbango","ken_all.csv","jq","trdsql"],"childPublishedDate":{"published_on":"2021-07-24T17:41:27.000Z","published_on_unix":1627148487}}},{"node":{"number":89,"relative_category":"blog/backend","fields":{"title":"imi-enrichment-addressは住所のバリデーションチェックでどの程度使えるか","excerpt":"コロナ禍であらゆる流通がオンラインに移行する中、正しい住所を使うことはいっそう求められています。ユーザーが配送用に住所を入力する時そのデータが正しいとどうやって判定するのでしょうか。今回はOSSライブラリimi-enrichment-addressが住所のバリデーションチェックでどの程度使えるか検証してみました。   > PROBLEMPROBLEM \n\n- 住所の不備が至るところで起きている 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい まずはOSSのライブラリをで検証したい \n- 特に町名番地の抜けもれや不備が多くこの点をどうにか拾いたい\n- 可能ならユーザーの入力時点でFEあるいはBE側でバリデーションチェックしたい まずはOSSのライブラリをで検証したい \n- まずはOSSのライブラリをで検証したい  > SOLUTIONSOLUTION \n\nというわけで、昨年（2020年）経産省IMI（情報共有基盤）から公開された住所変換コンポーネント「IMI-Tool-Project/imi-enrichment-address」がバリデーションチェックでどの程度使えるか検証します。  > imi-enrichment-addressとはimi-enrichment-addressとは \n\n経産省IMIツールプロジェクトで公開された住所変換コンポーネントです。CLIとサーバーが用意されていますが、今回はCLIを見ていきます。 \n\nヘルプを見ると住所を引数として渡すことで処理されることが分かります。 sh\n\n$ npm install -g https://info.gbiz.go.jp/tools/imi_tools/resource/imi-enrichment-address/imi-enrichment-address-2.0.0.tgz $ imi-enrichment-address --help imi-enrichment-address 住所文字列をもとに住所型・場所型の情報を補完します オプション -h, --help このヘルプを表示します -f, --file file 変換対象とする JSON ファイル -s, --string string 変換対象とする住所文字列 -i, --indent number 出力する JSON のインデント (default 2) 実行例 ヘルプの表示 $ imi-enrichment-address -h 文字列の処理 $ imi-enrichment-address -s 霞が関2 ファイルの処理 $ imi-enrichment-address input.json 標準入力の処理 $ cat input.json | imi-enrichment-address  \n\n実行すると正確な住所を渡したときと不正確な住所を渡したときで異なった結果を返すことが分かります。今回はこの正確・不正確の異なった結果を利用して検証していこうと思います。 sh\n\n$ imi-enrichment-address -s 長野県長野市大字長野旭町1108 { \"@context\": \"https://imi.go.jp/ns/core/context.jsonld\", \"@type\": \"場所型\", \"住所\": { \"@type\": \"住所型\", \"表記\": \"長野県長野市大字長野旭町1108\", \"都道府県\": \"長野県\", \"都道府県コード\": \"http://data.e-stat.go.jp/lod/sac/C20000\", \"市区町村\": \"長野市\", \"市区町村コード\": \"http://data.e-stat.go.jp/lod/sac/C20201\", \"町名\": \"大字長野\" }, \"地理座標\": { \"@type\": \"座標型\", \"緯度\": \"36.674892\", \"経度\": \"138.178449\" } } $ imi-enrichment-address -s 長野県長野市旭町1108 { \"@context\": \"https://imi.go.jp/ns/core/context.jsonld\", \"@type\": \"場所型\", \"住所\": { \"@type\": \"住所型\", \"表記\": \"長野県長野市旭町1108\", \"都道府県\": \"長野県\", \"都道府県コード\": \"http://data.e-stat.go.jp/lod/sac/C20000\", \"市区町村\": \"長野市\", \"市区町村コード\": \"http://data.e-stat.go.jp/lod/sac/C20201\" }, \"メタデータ\": { \"@type\": \"文書型\", \"説明\": \"該当する町名が見つかりません\" } }  \n\nなお、GitHubコードを見るとimi-enrichment-addressは街区レベル位置参照情報を利用して実装しています。このことを考えるとバリデーションチェックで積極的につかうのは難しく、ユースケースとしては下記2点に落ち着くと考えます。 \n\n- ユーザーに住所の再確認を促す\n- 入力後の住所不備について人が目検で確認する前段階で利用  > 検証用データ検証用データ \n\nさて、検証に進みましょう。imi-enrichment-addressで検証するデータは簡易に使える住所.jp、その中の事業所住所22402件を使います。他にも検証データはありますが、コストもそれほどかけられないのでコマンドだけで完結するものを選んでいます。 sh\n\n$ curl -sSL http://jusyo.jp/downloads/new/csv/csv_zenkoku.zip -o csv_zenkoku.zip $ unzip csv_zenkoku.zip $ go get github.com/mithrandie/csvq $ csvq -f CSV \"SELECT COUNT(*) FROM zenkoku WHERE 事業所住所 IS NOT NULL\" COUNT(*) 22402   > imi-enrichment-addressで検証用データを確認するimi-enrichment-addressで検証用データを確認する \n\n今回実行したCLIはNodeJSであることと数時間で処理できるという点で逐次で済ませました。 sh\n\n$ for i in $( csvq -f CSV \"SELECT 都道府県,市区町村,事業所住所 FROM zenkoku WHERE 事業所住所 IS NOT NULL\" \\ | sed 's/,//g' \\ | tail +2 \\ ); do imi-enrichment-address -s $i \\ | jq -r ' [ .[\"住所\"][\"表記\"], ( if .[\"地理座標\"] != null then true else false end ), .[\"メタデータ\"][\"説明\"] ] | @csv ' >>output.csv; done &   > バリデーションチェックの結果を確認するバリデーションチェックの結果を確認する \n\nimi-enrichment-addressの出力結果を確認したところ全国で9.25%が無効、下記の通り町名番地の表記揺れに弱いことが分かりました。特に町字（まちあざ）省略によるバリデーションエラーの比率が高く、青森、長野、沖縄等複数の県の住所が実用に耐えない結果となりました。 \n\nバリデーションエラーになった原因 \n\n- 各地方の字・大字の省略\n- 京都の通り上る・下るの表記\n- 北海道の条、線の表記揺れ\n- 茨城、岐阜等の町名省略\n- 茨城、神奈川、岐阜、石川等の区画整理地    都道府県 無効割合（%） 備考     青森県 54.42 字省略により無効   長野県 44.28 字省略により無効   沖縄県 43.55 字省略により無効   大分県 38.96 字省略により無効   京都府 36.86 字省略、通りにより無効   佐賀県 33.33 字省略により無効   奈良県 29.94 字省略により無効   福島県 29.18 字省略により無効   宮崎県 27.71 字省略により無効   埼玉県 23.08 字省略により無効   山口県 22.65 字省略により無効   和歌山県 17.78 字省略により無効   群馬県 17.08 字省略、ノ町により無効   茨城県 15.51 字省略、町名省略、区画整理により無効   熊本県 14.89 字省略により無効   山形県 14.38 字省略により無効   北海道 13.76 字省略、条、線により無効   栃木県 13.6 字省略により無効   新潟県 13.19 字省略により無効   鳥取県 9.57 字省略により無効   全国 9.25    福岡県 9 字省略により無効   三重県 7.74 字省略により無効   愛知県 7.4 字省略により無効   鹿児島県 7.09 字省略により無効   山梨県 6.8 字省略により無効   宮城県 6.37 字省略により無効   岩手県 6.28 字省略により無効   岐阜県 5.67 字省略、町名省略、区画整理により無効   香川県 4.71 字省略により無効   石川県 4.7 字省略、区画整理により無効   愛媛県 4.39 字省略により無効   秋田県 4.17 字省略により無効   滋賀県 3.76 字省略により無効   広島県 3.74 字省略により無効   高知県 3.38 字省略により無効   大阪府 3.28 字省略により無効   兵庫県 2.71 字省略により無効   島根県 2.04 字省略により無効   岡山県 1.81 字省略により無効   神奈川県 1.72 字省略、区画整理により無効   徳島県 1.64 字省略により無効   富山県 1.14 字省略により無効   静岡県 1.06 字省略、町名省略、区画整理により無効   東京都 0.89 字省略により無効   福井県 0.71 字省略により無効   千葉県 0.64 字省略により無効   長崎県 0      > WRAPUPWRAPUP \n\nimi-enrichment-addressは町名番地の判定に素の街区レベル位置参照情報を使用しているため、町字（まちあざ）の省略に弱いことが分かりました。 \n\n- ユーザーに住所の再確認を促す\n- 入力後の住所不備について人が目検で確認する前段階で利用 \n\nまず、想定したユースケースの内1つ「ユーザーに住所の再確認を促す」については、配送で使う住所の場合「町字の省略は影響ない」ので機能として適切ではありません。ユーザーが東京に集中している場合は関係ないですが、「町字が存在するさいたま市、川崎市、名古屋市、広島市、北九州市、福岡市、熊本市等の政令指定都市」や長野市のように住所が町字の組み合わせで2つ以上存在する都市の場合、使い勝手の悪い機能となります。 \n\n次に「入力後の住所不備について人が目検で確認する前段階で利用」については多少は有効に機能するでしょう。ただし、町字が多い地域では上記同様に使い勝手が悪くなります。 \n\n今回の検証の結果、現状の仕様ではimi-enrichment-addressを使うケースは限定せざるを得ず、一旦使用を見送りとします。とは言え、街区レベル位置参照情報にある町名番地から町字を除けば活用範囲が広がる可能性も確認できました。幸いなことにライブラリはMITライセンスで公開されています。"},"name":"imi-enrichment-addressは住所のバリデーションチェックでどの程度使えるか","tags":["imi-enrichment-address","mlit-isj"],"childPublishedDate":{"published_on":"2021-07-24T17:28:34.000Z","published_on_unix":1627147714}}},{"node":{"number":80,"relative_category":"blog/backend","fields":{"title":"AWS Organizationsを別のAWSアカウントに移行する","excerpt":"最近のAWSはCDKの発表に代表されるようにインフラ以外の開発者が触りやすい環境が整ってきています。ただ、こうした機能やリソースを存分に享受するにはIAM管理だけでは不足しており、AWSアカウントの管理方針を大枠で整理する必要が出てきました。今回は深く考えずに使っていたOrganizationsを整理する際にはまったポイントを記していきます。    > PROBLEMPROBLEM \n\n- 初期の頃につくったAWSアカウントにコンソリ請求の便利さからとりあえずOrganizations機能をつけてみた その後、当該アカウントに異なるワークロードのリソースを加えすぎてスケールしづらい構成になってきた 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- その後、当該アカウントに異なるワークロードのリソースを加えすぎてスケールしづらい構成になってきた 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- 例えば 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた \n- 開発環境をAWSアカウント単位で分けられないためIAMや開発サイクルが複雑になり開発スピードに支障が出てきた\n- セキュリティ上望ましくないシステム構成について改修のハードルが上がってきた   > SOLUTIONSOLUTION \n\nというわけで、一旦Organizations機能を解除して新しく作成したAWS管理アカウントに移行していくことにしました。一つ一つの作業は単純なのですが意外と時間がかかることが分かったので備忘として残しておきます。 \n\nOrganizationsのOU構成はサムネイル画像のBEFORE/AFTERの通りです。 \n\nBEFORE：Organization Unitの構成は全然考えずとりあえず追加していました。 \n\n- Foo - AWS Organizationsのオーナーアカウントであり、異なるワークロードや環境が混在しているアカウント\n- Bar - お試し用アカウント1\n- Buzz - お試し用アカウント2 \n\nAFTER：こちらの記事「Best Practices for Organizational Units with AWS Organizations | AWS Management & Governance Blog」を参考に構成しました。 \n\n- Foundation Management - AWS Organizationsのオーナーアカウント Security Infrastructure \n- Management - AWS Organizationsのオーナーアカウント\n- Security\n- Infrastructure\n- Workload Prod Foo Stg FooStg Integ FooInteg \n- Prod Foo \n- Foo\n- Stg FooStg \n- FooStg\n- Integ FooInteg \n- FooInteg\n- Sandbox BarSandbox BuzzSandbox \n- BarSandbox\n- BuzzSandbox   > Organizationsを別アカウントに移行する方法Organizationsを別アカウントに移行する方法 \n\nやったことはこちらの記事「2 つの AWS Organizations 間でアカウントを移動する」の通りですが、いくつかはまるポイントが書かれていないのでそちらも合わせて記します。まず注意点として3つあります。 \n\n一つ目は、Organizationsの移行期間中は請求の種類が3種類になる可能性があります。具体的には「古いOrganizationsによるコンソリ請求」「スタンドアロンのAWSアカウントによる請求」「新しいOrganizationsによるコンソリ請求」です。会社組織としてAWSを利用している場合は経理側との連携が必要になってくるでしょう。 \n\n二つ目は、古いOrganizationsから追加作成されたメンバーアカウントには請求情報の追加と電話番号の認証を行う必要があります。前者の請求情報の追加はそれほど手間ではないのですが、後者の電話番号の認証はAWSサポートを介すため1アカウントごとに3日から1週間ほど時間がかかります。詳細の対応方法はこちらの記事「組織からのメンバーアカウントのリンク解除のエラーを解決する」を参照下さい。 \n\n三つ目は、新しいOrganizationsでは先に制限緩和を行っておきましょう。新しいOrganizationsを作成する際はおそらく古いOrganizationsの時よりもにメンバーアカウントが増えることと思います。特にベストプラクティスのOrganization Unitでアカウントを分けていくとあっという間にデフォルト制限の10を超える可能性が高いです。 \n\n次に移行手順ですが、上記の注意点をクリアしたらほぼ単純作業になります。 \n\n1. 古いOrganizationからメンバーアカウントを削除\n2. 新しいOrganizationからメンバーアカウントに招待を送信\n3. メンバーアカウントで新しいOrganizationへの招待を受け入れる\n4. （全てのメンバーアカウントを削除し終わった後に）古いOrganizationsを削除\n5. 古いOrganizationsの管理アカウントをメンバーアカウントとして新しい Organization に招待   > WRAPUPWRAPUP \n\n昨今のAWSの動きを見ると、インフラ以外の開発者にもAWSを気軽に使えるようになってきており、Organizations機能を使うこと前提にサービスが展開されているようです。なのでこうした恩恵をうけるためにもOrganizationsのベストプラクティスに則ったアカウント構成にする必要があります。 \n\n一応の注意点としては、Organizationsが便利だからといってOrganizationsからメンバーアカウントを追加することは止めた方がいいです。Organizations移行の注意点から分かる通り、Organizationsから追加されたメンバーアカウントには請求情報追加も電話番号認証も行われません。いざ別のOrganizationsに移行する際に想定外の手間と時間をかけないよう、常にスタンドアロンでAWSアカウントを作成するようにしましょう。 \n\nさて、Organizationsの勘所が見えてきたら次はAWS SSOという便利な機能が待っています。AWSを楽しみましょう。"},"name":"AWS Organizationsを別のAWSアカウントに移行する","tags":["aws-organizations"],"childPublishedDate":{"published_on":"2021-05-13T11:39:28.000Z","published_on_unix":1620905968}}}]}},"pageContext":{"number":58}},"staticQueryHashes":[]}