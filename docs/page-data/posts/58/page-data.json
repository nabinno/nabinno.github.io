{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/58","result":{"data":{"esaPost":{"number":58,"relative_category":"blog/backend","fields":{"title":"WSL（Windows Subsystem for Linux）でDockerをつかったWebアプリケーション開発をおこなう際の注意点","excerpt":"これは無宗教ななびの  が書くDocker Advent Calendar 2017用記事です。前日はinductorさんの「Docker Meetupの中身まとめ」でした  （写真はクリスマスを日本にひろめた明治屋 ）   > PROBLEMPROBLEM \n\n- macOSとWindowsでWebアプリケーション開発をする際に 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- ただ、実際どこまで開発ができるかわからんしなあ   > SOLUTIONSOLUTION \n\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。 \n\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。 \n\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。   > 対象環境対象環境 \n\n- Windows 10 Pro 1709 16299.64 Hyper-V 10.0.16299.15 Docker for Windows 17.09.0-ce-win33 Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Hyper-V 10.0.16299.15\n- Docker for Windows 17.09.0-ce-win33\n- Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Docker Client 1.12.6   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- Windows Subsystem for Linuxをインストールしてみよう！ \n\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。 \n\n1. apt WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します \n2. WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\n3. anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます \n4. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n5. exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\n6. nix ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n7. ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n8. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。 \n\n- WSLtty Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 \n- ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\n- EmacsでCtrl-SPC set-mark が機能する\n- 画面サイズの変更が柔軟\n- Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- PowerShellなどほかのコンソールの呼び出しが面倒\n- ConEmu Pros PowerShellなどほかのコンソールの呼び出しが楽 Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- Pros PowerShellなどほかのコンソールの呼び出しが楽 \n- PowerShellなどほかのコンソールの呼び出しが楽\n- Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- ファイルの読込速度がおそい\n- EmacsでCtrl-SPC set-mark が機能しない\n- 画面サイズの変更に制限がある   > WSLttyWSLtty \n\n- mintty/wsltty \n\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは chsh がつかえないのでログイン時につかいたいシェルを指定します。もし、 screen をつかいたい場合は /run/screen ディレクトリを作成してからコマンド指定します。   bat \n\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'   ConEmu \n\n- ConEmu - Handy Windows Terminal \n\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい1のでおすすめしません。 \n\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。   bash \n\n# task parameters /icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\" # task command bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%     > Docker for WindowsのインストールDocker for Windowsのインストール \n\n- Docker For Windows \n\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。 \n\n構成は下記のようになります。  \n\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 DOCKER_HOST をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。 \n\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\n2. WSL上のDockerクライアントに DOCKER_HOST=tcp://0.0.0.0:2375 を設定 \n\nWSLには下記のようなaliasを用意しておくといいでしょう。   bash \n\nexport DOCKER_HOST=tcp://0.0.0.0:2375 alias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\" alias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"     > さて、WSLからDocker for Windowsはどの程度つかえるのかさて、WSLからDocker for Windowsはどの程度つかえるのか \n\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。 \n\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\n2. WSLはLinux形式のパスしか扱えません、C:\\Dev のようなドライブ名にコロンをつけたURIスキーマは扱えません\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません2 \n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります3  \n\nひとつずつ解決方法を見ていきましょう。   > 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません \n\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。   > 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません \n\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。   bash \n\n$ ln -s /mnt/c /C # 開発ディレクトリはこんな感じで参照できます $ ls -al /C/Dev total 0 drwxrwxrwx 0 root root 512 Oct 27 00:54 . drwxrwxrwx 0 root root 512 Dec 8 07:49 .. drwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1 drwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2     > 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません \n\n各OS間での違いを吸収するため、プロジェクトに PRJ_ROOT のような環境変数を用意しましょう。   yaml \n\nservices: app-front: image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front volumes: - ${PRJ_ROOT}/front:/var/www/front     > 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります \n\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました  \n\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。   bash \n\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules $ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules     > WRAPUPWRAPUP \n\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。 \n\n随時、気になる課題が出てきたら追記します。  \n\n1. https://github.com/cmderdev/cmder/issues/901 ↩ \n2. https://github.com/docker/compose/issues/4039#issuecomment-269558432 ↩ \n3. https://github.com/Microsoft/WSL/issues/2448 ↩","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png"},"wip":false,"body_md":"<img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\">\r\n\r\n\r\nこれは無宗教ななびの :construction_worker: が書く[Docker Advent Calendar 2017](https://qiita.com/advent-calendar/2017/docker)用記事です。前日はinductorさんの「[Docker Meetupの中身まとめ](https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e)」でした :whale: （写真は[クリスマスを日本にひろめた明治屋](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3) :christmas_tree:）\r\n\r\n# PROBLEM\r\n- macOSとWindowsでWebアプリケーション開発をする際に\r\n    - 環境が異なって管理しづらい\r\n        - それならDockerで\r\n            - と思ったが、macOSはBashでWindowsはPowerShellなのか\r\n                - せめてPowerShellではなくBash...\r\n                    - となると、いまWindowsでLinux環境をつかうならWSLか\r\n                        - ただ、実際どこまで開発ができるかわからんしなあ\r\n\r\n# SOLUTION\r\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。\r\n\r\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。\r\n\r\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。\r\n\r\n## 対象環境\r\n- Windows 10 Pro 1709 16299.64\r\n    - Hyper-V 10.0.16299.15\r\n    - Docker for Windows 17.09.0-ce-win33\r\n    - Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\r\n        - Docker Client 1.12.6\r\n\r\n## Windowsの開発環境を構築する\r\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。\r\n\r\n### WSLのインストール\r\n- [Windows Subsystem for Linuxをインストールしてみよう！](https://qiita.com/Aruneko/items/c79810b0b015bebf30bb)\r\n\r\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。\r\n1. apt\r\n    - WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\r\n2. [anyenv](https://github.com/riywo/anyenv)\r\n    - プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\r\n    - exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\r\n3. [nix](https://nixos.org/nix/)\r\n    - ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\r\n    - また、aptのバージョンが古すぎるパッケージもnixが最適です\r\n\r\n### ターミナルのインストール\r\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。\r\n\r\n- WSLtty\r\n    - Pros\r\n        - ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\r\n        - EmacsでCtrl-SPC `set-mark` が機能する\r\n        - 画面サイズの変更が柔軟\r\n    - Cons\r\n        - PowerShellなどほかのコンソールの呼び出しが面倒\r\n- ConEmu\r\n    - Pros\r\n        - PowerShellなどほかのコンソールの呼び出しが楽\r\n    - Cons\r\n        - ファイルの読込速度がおそい\r\n        - EmacsでCtrl-SPC `set-mark` が機能しない\r\n        - 画面サイズの変更に制限がある\r\n\r\n### WSLtty\r\n- [mintty/wsltty](https://github.com/mintty/wsltty)\r\n\r\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは `chsh` がつかえないのでログイン時につかいたいシェルを指定します。もし、 `screen` をつかいたい場合は `/run/screen` ディレクトリを作成してからコマンド指定します。\r\n\r\n```bat\r\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'\r\n```\r\n\r\n#### ConEmu\r\n- [ConEmu - Handy Windows Terminal](https://conemu.github.io/)\r\n\r\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい[^1]のでおすすめしません。\r\n\r\n[^1]: [https://github.com/cmderdev/cmder/issues/901](https://github.com/cmderdev/cmder/issues/901)\r\n\r\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。\r\n\r\n```bash\r\n# task parameters\r\n/icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\"\r\n\r\n# task command\r\nbash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%\r\n```\r\n\r\n### Docker for Windowsのインストール\r\n- [Docker For Windows](https://www.docker.com/docker-windows)\r\n\r\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。\r\n\r\n構成は下記のようになります。\r\n\r\n<img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\">\r\n\r\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 `DOCKER_HOST` をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。\r\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\r\n2. WSL上のDockerクライアントに `DOCKER_HOST=tcp://0.0.0.0:2375` を設定\r\n\r\nWSLには下記のようなaliasを用意しておくといいでしょう。\r\n\r\n```bash\r\nexport DOCKER_HOST=tcp://0.0.0.0:2375\r\nalias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\"\r\nalias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"\r\n```\r\n\r\n## さて、WSLからDocker for Windowsはどの程度つかえるのか\r\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。\r\n\r\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n2. WSLはLinux形式のパスしか扱えません、`C:\\Dev` のようなドライブ名にコロンをつけたURIスキーマは扱えません\r\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません[^2]\r\n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります[^3]\r\n\r\n[^2]: [https://github.com/docker/compose/issues/4039#issuecomment-269558432](https://github.com/docker/compose/issues/4039#issuecomment-269558432)\r\n[^3]: [https://github.com/Microsoft/WSL/issues/2448](https://github.com/Microsoft/WSL/issues/2448)\r\n\r\nひとつずつ解決方法を見ていきましょう。\r\n\r\n### 1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。\r\n\r\n### 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\r\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。\r\n\r\n```bash\r\n$ ln -s /mnt/c /C\r\n\r\n# 開発ディレクトリはこんな感じで参照できます\r\n$ ls -al /C/Dev\r\ntotal 0\r\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 .\r\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\r\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\r\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\r\n```\r\n\r\n### 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\r\n各OS間での違いを吸収するため、プロジェクトに `PRJ_ROOT` のような環境変数を用意しましょう。\r\n\r\n```yaml\r\nservices:\r\n  app-front:\r\n    image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front\r\n    volumes:\r\n      - ${PRJ_ROOT}/front:/var/www/front\r\n```\r\n\r\n### 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\r\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました :tada:\r\n\r\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。\r\n\r\n```bash\r\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules\r\n$ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\r\n```\r\n\r\n# WRAPUP\r\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。\r\n\r\n随時、気になる課題が出てきたら追記します。\r\n\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\"></a>\n<p data-sourcepos=\"4:1-4:513\">これは無宗教ななびの <img class=\"emoji\" title=\":construction_worker:\" alt=\":construction_worker:\" src=\"https://assets.esa.io/images/emoji/unicode/1f477.png\"> が書く<a href=\"https://qiita.com/advent-calendar/2017/docker\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Advent Calendar 2017</a>用記事です。前日はinductorさんの「<a href=\"https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Meetupの中身まとめ</a>」でした <img class=\"emoji\" title=\":whale:\" alt=\":whale:\" src=\"https://assets.esa.io/images/emoji/unicode/1f433.png\"> （写真は<a href=\"https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3\" target=\"_blank\" rel=\"noopener noreferrer\">クリスマスを日本にひろめた明治屋</a> <img class=\"emoji\" title=\":christmas_tree:\" alt=\":christmas_tree:\" src=\"https://assets.esa.io/images/emoji/unicode/1f384.png\">）</p>\n<h1 data-sourcepos=\"6:1-6:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"7:1-14:0\">\n<li data-sourcepos=\"7:1-14:0\">macOSとWindowsでWebアプリケーション開発をする際に\n<ul data-sourcepos=\"8:5-14:0\">\n<li data-sourcepos=\"8:5-14:0\">環境が異なって管理しづらい\n<ul data-sourcepos=\"9:9-14:0\">\n<li data-sourcepos=\"9:9-14:0\">それならDockerで\n<ul data-sourcepos=\"10:13-14:0\">\n<li data-sourcepos=\"10:13-14:0\">と思ったが、macOSはBashでWindowsはPowerShellなのか\n<ul data-sourcepos=\"11:17-14:0\">\n<li data-sourcepos=\"11:17-14:0\">せめてPowerShellではなくBash...\n<ul data-sourcepos=\"12:21-14:0\">\n<li data-sourcepos=\"12:21-14:0\">となると、いまWindowsでLinux環境をつかうならWSLか\n<ul data-sourcepos=\"13:25-14:0\">\n<li data-sourcepos=\"13:25-14:0\">ただ、実際どこまで開発ができるかわからんしなあ</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"15:1-15:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"16:1-16:165\">というわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。</p>\n<p data-sourcepos=\"18:1-18:283\">前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。</p>\n<p data-sourcepos=\"20:1-20:135\">要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。</p>\n<h2 data-sourcepos=\"22:1-22:15\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"対象環境\" name=\"%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" href=\"#%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"対象環境\"> &gt; 対象環境</span></a>対象環境</h2>\n<ul data-sourcepos=\"23:1-28:0\">\n<li data-sourcepos=\"23:1-28:0\">Windows 10 Pro 1709 16299.64\n<ul data-sourcepos=\"24:5-28:0\">\n<li data-sourcepos=\"24:5-24:27\">Hyper-V 10.0.16299.15</li>\n<li data-sourcepos=\"25:5-25:41\">Docker for Windows 17.09.0-ce-win33</li>\n<li data-sourcepos=\"26:5-28:0\">Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\n<ul data-sourcepos=\"27:9-28:0\">\n<li data-sourcepos=\"27:9-28:0\">Docker Client 1.12.6</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 data-sourcepos=\"29:1-29:40\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"Windowsの開発環境を構築する\" name=\"Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" href=\"#Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Windowsの開発環境を構築する\"> &gt; Windowsの開発環境を構築する</span></a>Windowsの開発環境を構築する</h2>\n<p data-sourcepos=\"30:1-30:116\">まず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。</p>\n<h3 data-sourcepos=\"32:1-32:28\" id=\"2-2-1\" name=\"2-2-1\">\n<a class=\"anchor\" id=\"WSLのインストール\" name=\"WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLのインストール\"> &gt; WSLのインストール</span></a>WSLのインストール</h3>\n<ul data-sourcepos=\"33:1-34:0\">\n<li data-sourcepos=\"33:1-34:0\"><a href=\"https://qiita.com/Aruneko/items/c79810b0b015bebf30bb\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Subsystem for Linuxをインストールしてみよう！</a></li>\n</ul>\n<p data-sourcepos=\"35:1-35:91\">WSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。</p>\n<ol data-sourcepos=\"36:1-44:0\">\n<li data-sourcepos=\"36:1-37:153\">apt\n<ul data-sourcepos=\"37:5-37:153\">\n<li data-sourcepos=\"37:5-37:153\">WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します</li>\n</ul>\n</li>\n<li data-sourcepos=\"38:1-40:134\">\n<a href=\"https://github.com/riywo/anyenv\" target=\"_blank\" rel=\"noopener noreferrer\">anyenv</a>\n<ul data-sourcepos=\"39:5-40:134\">\n<li data-sourcepos=\"39:5-39:123\">プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう</li>\n<li data-sourcepos=\"40:5-40:134\">exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます</li>\n</ul>\n</li>\n<li data-sourcepos=\"41:1-44:0\">\n<a href=\"https://nixos.org/nix/\" target=\"_blank\" rel=\"noopener noreferrer\">nix</a>\n<ul data-sourcepos=\"42:5-44:0\">\n<li data-sourcepos=\"42:5-42:154\">ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう</li>\n<li data-sourcepos=\"43:5-44:0\">また、aptのバージョンが古すぎるパッケージもnixが最適です</li>\n</ul>\n</li>\n</ol>\n<h3 data-sourcepos=\"45:1-45:40\" id=\"2-2-2\" name=\"2-2-2\">\n<a class=\"anchor\" id=\"ターミナルのインストール\" name=\"%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"ターミナルのインストール\"> &gt; ターミナルのインストール</span></a>ターミナルのインストール</h3>\n<p data-sourcepos=\"46:1-46:174\">WSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。</p>\n<ul data-sourcepos=\"48:1-62:0\">\n<li data-sourcepos=\"48:1-54:74\">WSLtty\n<ul data-sourcepos=\"49:5-54:74\">\n<li data-sourcepos=\"49:5-52:43\">Pros\n<ul data-sourcepos=\"50:9-52:43\">\n<li data-sourcepos=\"50:9-50:87\">ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)</li>\n<li data-sourcepos=\"51:9-51:53\">EmacsでCtrl-SPC <code>set-mark</code> が機能する</li>\n<li data-sourcepos=\"52:9-52:43\">画面サイズの変更が柔軟</li>\n</ul>\n</li>\n<li data-sourcepos=\"53:5-54:74\">Cons\n<ul data-sourcepos=\"54:9-54:74\">\n<li data-sourcepos=\"54:9-54:74\">PowerShellなどほかのコンソールの呼び出しが面倒</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-sourcepos=\"55:1-62:0\">ConEmu\n<ul data-sourcepos=\"56:5-62:0\">\n<li data-sourcepos=\"56:5-57:71\">Pros\n<ul data-sourcepos=\"57:9-57:71\">\n<li data-sourcepos=\"57:9-57:71\">PowerShellなどほかのコンソールの呼び出しが楽</li>\n</ul>\n</li>\n<li data-sourcepos=\"58:5-62:0\">Cons\n<ul data-sourcepos=\"59:9-62:0\">\n<li data-sourcepos=\"59:9-59:49\">ファイルの読込速度がおそい</li>\n<li data-sourcepos=\"60:9-60:56\">EmacsでCtrl-SPC <code>set-mark</code> が機能しない</li>\n<li data-sourcepos=\"61:9-62:0\">画面サイズの変更に制限がある</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 data-sourcepos=\"63:1-63:10\" id=\"2-2-3\" name=\"2-2-3\">\n<a class=\"anchor\" id=\"WSLtty\" name=\"WSLtty\" href=\"#WSLtty\" data-position=\"2-2-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLtty\"> &gt; WSLtty</span></a>WSLtty</h3>\n<ul data-sourcepos=\"64:1-65:0\">\n<li data-sourcepos=\"64:1-65:0\"><a href=\"https://github.com/mintty/wsltty\" target=\"_blank\" rel=\"noopener noreferrer\">mintty/wsltty</a></li>\n</ul>\n<p data-sourcepos=\"66:1-66:477\">WSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは <code>chsh</code> がつかえないのでログイン時につかいたいシェルを指定します。もし、 <code>screen</code> をつかいたい場合は <code>/run/screen</code> ディレクトリを作成してからコマンド指定します。</p>\n<div class=\"code-block\" data-sourcepos=\"68:1-70:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bat</div>\n<div class=\"highlight\"><pre class=\"highlight batchfile\"><code><span class=\"nv\">%LOCALAPPDATA%</span>\\wsltty\\bin\\mintty.exe <span class=\"na\">--wsl -o </span><span class=\"kd\">Locale</span><span class=\"o\">=</span><span class=\"kd\">C</span> <span class=\"na\">-o </span><span class=\"kd\">Charset</span><span class=\"o\">=</span><span class=\"kd\">UTF</span><span class=\"o\">-</span><span class=\"m\">8</span> <span class=\"na\">/bin/wslbridge -t /bin/bash -c </span><span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span>\n</code></pre></div>\n</div>\n<h4 data-sourcepos=\"72:1-72:11\">ConEmu</h4>\n<ul data-sourcepos=\"73:1-74:0\">\n<li data-sourcepos=\"73:1-74:0\"><a href=\"https://conemu.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">ConEmu - Handy Windows Terminal</a></li>\n</ul>\n<p data-sourcepos=\"75:1-75:258\">WSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">1</a></sup>のでおすすめしません。</p>\n<p data-sourcepos=\"79:1-79:127\">ConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。</p>\n<div class=\"code-block\" data-sourcepos=\"81:1-87:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"c\"># task parameters</span>\n/icon <span class=\"s2\">\"C:</span><span class=\"se\">\\P</span><span class=\"s2\">rogram Files</span><span class=\"se\">\\W</span><span class=\"s2\">indowsApps</span><span class=\"se\">\\C</span><span class=\"s2\">anonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc</span><span class=\"se\">\\i</span><span class=\"s2\">mages</span><span class=\"se\">\\i</span><span class=\"s2\">con.ico\"</span>\n\n<span class=\"c\"># task command</span>\nbash <span class=\"nt\">-c</span> <span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span> <span class=\"nt\">-new_console</span>:d:%USERPROFILE%\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"89:1-89:43\" id=\"2-2-4\" name=\"2-2-4\">\n<a class=\"anchor\" id=\"Docker for Windowsのインストール\" name=\"Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Docker for Windowsのインストール\"> &gt; Docker for Windowsのインストール</span></a>Docker for Windowsのインストール</h3>\n<ul data-sourcepos=\"90:1-91:0\">\n<li data-sourcepos=\"90:1-91:0\"><a href=\"https://www.docker.com/docker-windows\" target=\"_blank\" rel=\"noopener noreferrer\">Docker For Windows</a></li>\n</ul>\n<p data-sourcepos=\"92:1-92:202\">WSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。</p>\n<p data-sourcepos=\"94:1-94:42\">構成は下記のようになります。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\"></a>\n<p data-sourcepos=\"98:1-98:240\">DockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 <code>DOCKER_HOST</code> をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。</p>\n<ol data-sourcepos=\"99:1-101:0\">\n<li data-sourcepos=\"99:1-99:118\">Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定</li>\n<li data-sourcepos=\"100:1-101:0\">WSL上のDockerクライアントに <code>DOCKER_HOST=tcp://0.0.0.0:2375</code> を設定</li>\n</ol>\n<p data-sourcepos=\"102:1-102:77\">WSLには下記のようなaliasを用意しておくといいでしょう。</p>\n<div class=\"code-block\" data-sourcepos=\"104:1-108:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nb\">export </span><span class=\"nv\">DOCKER_HOST</span><span class=\"o\">=</span>tcp://0.0.0.0:2375\n<span class=\"nb\">alias </span><span class=\"nv\">docker</span><span class=\"o\">=</span><span class=\"s2\">\"DOCKER_HOST=</span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\"> docker\"</span>\n<span class=\"nb\">alias </span>docker-compose<span class=\"o\">=</span><span class=\"s2\">\"docker-compose -H </span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\">\"</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"110:1-110:72\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\" name=\"%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" href=\"#%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\"> &gt; さて、WSLからDocker for Windowsはどの程度つかえるのか</span></a>さて、WSLからDocker for Windowsはどの程度つかえるのか</h2>\n<p data-sourcepos=\"111:1-111:189\">WSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。</p>\n<ol data-sourcepos=\"113:1-117:0\">\n<li data-sourcepos=\"113:1-113:120\">Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</li>\n<li data-sourcepos=\"114:1-114:146\">WSLはLinux形式のパスしか扱えません、<code>C:\\Dev</code> のようなドライブ名にコロンをつけたURIスキーマは扱えません</li>\n<li data-sourcepos=\"115:1-115:105\">WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">2</a></sup>\n</li>\n<li data-sourcepos=\"116:1-117:0\">WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">3</a></sup>\n</li>\n</ol>\n<p data-sourcepos=\"121:1-121:57\">ひとつずつ解決方法を見ていきましょう。</p>\n<h3 data-sourcepos=\"123:1-123:124\" id=\"2-3-1\" name=\"2-3-1\">\n<a class=\"anchor\" id=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\" name=\"1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\"> &gt; 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません</span></a>1. Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</h3>\n<p data-sourcepos=\"124:1-124:174\">開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。</p>\n<h3 data-sourcepos=\"126:1-126:129\" id=\"2-3-2\" name=\"2-3-2\">\n<a class=\"anchor\" id=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\" name=\"2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\"> &gt; 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</span></a>2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</h3>\n<p data-sourcepos=\"127:1-127:157\">NTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"129:1-139:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /mnt/c /C\n\n<span class=\"c\"># 開発ディレクトリはこんな感じで参照できます</span>\n<span class=\"nv\">$ </span><span class=\"nb\">ls</span> <span class=\"nt\">-al</span> /C/Dev\ntotal 0\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 <span class=\"nb\">.</span>\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"141:1-141:105\" id=\"2-3-3\" name=\"2-3-3\">\n<a class=\"anchor\" id=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\" name=\"3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\"> &gt; 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</span></a>3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</h3>\n<p data-sourcepos=\"142:1-142:128\">各OS間での違いを吸収するため、プロジェクトに <code>PRJ_ROOT</code> のような環境変数を用意しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"144:1-150:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"na\">app-front</span><span class=\"pi\">:</span>\n    <span class=\"na\">image</span><span class=\"pi\">:</span> <span class=\"s\">561534604247952616898.dkr.ecr.amazonaws.com/test/front</span>\n    <span class=\"na\">volumes</span><span class=\"pi\">:</span>\n      <span class=\"pi\">-</span> <span class=\"s\">${PRJ_ROOT}/front:/var/www/front</span>\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"152:1-152:104\" id=\"2-3-4\" name=\"2-3-4\">\n<a class=\"anchor\" id=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\" name=\"4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" href=\"#4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" data-position=\"2-3-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\"> &gt; 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</span></a>4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</h3>\n<p data-sourcepos=\"153:1-153:136\">こちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました <img class=\"emoji\" title=\":tada:\" alt=\":tada:\" src=\"https://assets.esa.io/images/emoji/unicode/1f389.png\"></p>\n<p data-sourcepos=\"155:1-155:160\">もし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"157:1-160:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">mkdir</span> /home/foo/tmp/app-test-1/front/node_modules\n<span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"162:1-162:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"163:1-163:198\">まだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。</p>\n<p data-sourcepos=\"165:1-165:63\">随時、気になる課題が出てきたら追記します。</p>\n<section class=\"footnotes\">\n<ol>\n<li id=\"fn1\">\n<p data-sourcepos=\"77:7-77:98\"><a href=\"https://github.com/cmderdev/cmder/issues/901\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/cmderdev/cmder/issues/901</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\">\n<p data-sourcepos=\"118:7-118:146\"><a href=\"https://github.com/docker/compose/issues/4039#issuecomment-269558432\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/docker/compose/issues/4039#issuecomment-269558432</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\">\n<p data-sourcepos=\"119:7-119:98\"><a href=\"https://github.com/Microsoft/WSL/issues/2448\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Microsoft/WSL/issues/2448</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","tags":["wsl","docker","ubuntu"],"updated_at":"2021-01-12T01:27:16+09:00","childPublishedDate":{"published_on":"2017-12-10T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":56,"relative_category":"blog/backend","fields":{"title":"RubyのCSVパースをPyCallで実行する（ベンチマーク）","excerpt":"先日RubyからPythonにアクセスできるPyCallというライブラリの存在を知り、ぜひともベンチマークを取りたいと思った次第です。現状RubyのCSVの読み込みに不満を持っており、そこをどうにか解消したいと考えています。   > PROBLEMPROBLEM \n\n- 大量のCSVを読み込む際、毎回時間がかかる   > SOLUTIONSOLUTION \n\nというわけで、「Dalibor Nasevicのベンチマーク記事」にPyCallのベンチマークをくわえて比較してみることにしました。記事では下記の通り CSV.foreach が速いとの結論でした。    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0      > PyCallのベンチマークPyCallのベンチマーク \n\nそれでは、PyCallのベンチマークを計りましょう。コードは下記のようになります。   ruby \n\nrequire_relative './helpers' require 'pycall/import' include PyCall::Import pyimport :pandas, as: :pd print_memory_usage do print_time_spent do csv = pd.read_csv.('data.csv') sum = csv['id'].sum.() puts \"Sum: #{sum}\" end end   \n\nPyCallは pyenv との相性が悪いのでSystemインストールしたPythonでたたきます。   sh \n\n$ PYTHON=/usr/bin/python3.4 ruby parse_6_pycall.rb Sum: 499999500000 Time: 1.49 Memory: 54.99 MB   \n\n結果    kind_of_parse time (real) memory (MB)     1. CSV.read  39.13 866.6   2. CSV.parse  36.16 936.87   3. line by line from String Object 23.39 73.42   4. line by line from IO Object 24.55 0.0   5. CSV.foreach  24.04 0.0   6. PyCall 1.49 54.99    \n\nはい、結果が出ました。Daliborのベンチマーク記事で一番速かった CSV.foreach より16倍の実行速度となりました。   > WRAPUPWRAPUP \n\nPyCallのオブジェクトが PyObjectとActiveRecordと相性が悪そうなのと、PythonとRuby双方のメモリー管理が運用を難しくすることから、安易に本番環境のRailsに導入するのは厳しいと思います。 \n\nただし、実行回数が限定されたスクリプトなら積極的に使って良いでしょう。"},"name":"[2017-06-05]RubyのCSVパースをPyCallで実行する（ベンチマーク）","tags":["ruby","benchmark","pycall"],"childPublishedDate":{"published_on":"2017-06-05T00:00:00.000Z","published_on_unix":1496620800}}},{"node":{"number":62,"relative_category":"blog/backend","fields":{"title":"Elixirではてなブックマーク","excerpt":"紆余曲折合ってはてなブックマークの運用を見直す必要が出てきました。人の興味というのは尽きないもので知りたいことが次々出てきます。にも拘わらず人の時間は有限でそれにあがなうための手段を考えたわけです。   > PROBLEMPROBLEM \n\n- フィードリーダーで記事を読んだ後にはてなブックマーク（ブクマ）するとフィード消化するのに時間がかかる フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- フィードをそのままブクマしていると下記の問題がでてくる あとで確認することができない 読みたくない記事をブクマしてしまう 適切でないURLでブクマしてしまう \n- あとで確認することができない\n- 読みたくない記事をブクマしてしまう\n- 適切でないURLでブクマしてしまう   > SOLUTIONSOLUTION \n\nというわけで、下記の方針でブクマすることにしました。設置方法の詳細はGitHubレポジトリを参照ください。そして、方針は下記の通りになります。 \n\n方針 \n\n- フィードごとにタグづけする\n- ブクマ対象になる記事をリンクとタイトルで除外判定する\n- ブクマ対象になる記事をリンクから校正すべきものかリダイレクトすべきものか判定する\n- 上記設定はYAMLファイルで簡単に管理できるようにする\n- フィード読込とブクマを非同期処理できるようElixirで実装する   > ブクマの管理方法ブクマの管理方法 \n\nまずブクマの管理ですが、下記5つのYAMLファイルで構成しています、構造はマップとリストのみ。ブクマしたいと思う記事を読みすすめる中で気になるキーワードが出てきたら都度 feed.yaml を更新します。また、記事にノイズが多いようだったら傾向を分析して除外ファイル feed_excluded_link.yaml feed_excluded_title.yaml を更新します。    item description     feed.yaml フィードグループ名に対するリンク、タグのマップ   feed_excluded_link.yaml 除外すべきフィードリンクのリスト   feed_excluded_title.yaml 除外すべきフィードタイトルのリスト   feed_corrected_link.yaml フィードリンクに対するトリミングすべきパラメータのマップ   feed_redirected_link.yaml フィードリンクに対するリダイレクト先リンクのマップ      yaml \n\n# feed.yaml nabinno/sports/feed_group_name: tags: - ski links: - http://rss.example.com/ski_feed.rss - http://rss.example.com/snowboard_feed.rss - http://ski-status.example.com/rss # feed_excluded_link.yaml - anti-ski.example.com - awesome-snowboard.example.com # feed_excluded_title.yaml - queer - two-planker - beaver-tail # feed_corrected_link.yaml amazon.com: - ref - ie # feed_redirected_link.yaml ski-status.example.com: - Floki.find(fst, \".post__body a\")     > Elixirによる非同期処理Elixirによる非同期処理 \n\nElixirで非同期処理を行っているのですが、大きく分けて監視機構のSupervisorと非同期処理のTask.async_streamを使っています。   > 監視機構 Supervisor監視機構 Supervisor \n\nまず、Supervisor。Elixirには監視機構Supervisorがあり、それが各ワーカーを子プロセスとして管理しています。ここではフィード読込とブクマは別々のワーカーで処理しますが、キャッシュが暖気処理を別ワーカーで行っているため再起動戦略は「失敗したイベントの中にあるすべての子プロセスを再起動」（ one_for_all ）にしてあります。再起動戦略の詳細は「OTPスーパバイザ · Elixir School」を参照下さい。 \n\n下記のように Supervisor.start_link を Keshikimi2.Application.start に適用すると、アプリケーション開始（ mix run ）した時点で監視機構が起動されます。   ex \n\nSupervisor.start_link( [ :hackney_pool.child_spec(:hatena_bookmark_pool, timeout: 15_000, max_connections: 100), # @todo 当該ワーカーで暖気処理を行っていないので `one_for_one` にした場合、再起動時にほかに影響する supervisor(Cachex, [:feed, []]), supervisor(Keshikimi2Feed.Registry, [prefix]), # フィード読込処理 (PubSub) supervisor(Keshikimi2Feed.Subscriber, [prefix]), worker(Keshikimi2Feed.Worker, [prefix]), worker(Keshikimi2Feed.Publisher, [[prefix: prefix, poll_interval: 3_000]]), # ブクマ処理 worker(Keshikimi2.HatenaBookmark.AddEntry, [ [prefix: prefix, poll_interval: 3_000] ]) ], strategy: :one_for_all, name: name(prefix) )     > 非同期処理 Task.async_stream非同期処理 Task.async_stream \n\n次に、Task.async_stream。配列を引き回すリクエスト処理は Task.async_stream がうってつけです。下記ではキャッシュからブクマ対象になるフィードリンクを取り出し、除外処理、校正処理を加えて、ブクマのリクエストを出すという流れを組んでいます。Elixirでは、流れをひとまとめにして視覚的にわかりやすく非同期処理してくことができます。   ex \n\nCachex.keys!(:feed) |> Enum.reject(fn key -> key in [ \"excluded_links\", \"excluded_titles\", \"corrected_links\", \"redirected_links\", \"feed_group\", \"archived_links\" ] end) |> Task.async_stream( fn item_link -> with {:ok, [item_title, feed_tags]} <- Cachex.get(:feed, item_link), :ok <- validate_all(item_link, item_title), corrected_link <- correct_all(item_link), {:ok, payload} <- FormData.create( %{ url: corrected_link, comment: feed_tags |> Enum.map_join(fn tag -> \"[#{tag}]\" end), rks: System.get_env(\"HATENA_BOOKMARK_RKS\"), private: 0, keep_original_url: 1, with_status_op: 1, from: \"inplace\", post_twitter: 0, post_evernote: 0 }, :url_encoded, get: false ) do do_add_entries_to_hb(payload) Logger.info(\"add entry: #{item_link}\") end archive_link(item_link) end, timeout: 15_000 ) |> Stream.run()     > WRAPUPWRAPUP \n\nElixirの非同期処理を使うことではてなブックマークの運用がとても快適になりました。はてなブックマークとの今後の付き合い方は下記のように考えています。 \n\n- 手動でブクマ: 気になった記事があるごとに\n- ブクマの確認: 気になるタグごとにまとめて確認 \n\nブクマの確認については、例えば、CIでデプロイしている間に最近のGitHubの動向を確認したい場合は「nabinno/github」をみる、という感じの運用です。 \n\n融通が利かない点で途中運用が難しくなる気もしますが、しばらく回してみます。"},"name":"[2019-01-01]Elixirではてなブックマーク","tags":["elixir","hatena-bookmark"],"childPublishedDate":{"published_on":"2019-01-01T00:00:00.000Z","published_on_unix":1546300800}}},{"node":{"number":63,"relative_category":"blog/frontend","fields":{"title":"イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","excerpt":"Redという言語はご存じでしょうか。癖になる手触りですぐに虜になりました。新年早々の恋になります。   > PROBLEMPROBLEM \n\n- クロスプラットフォーム用のクライアントソフトをつくるにあたり 重たいフレームワークが多い 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい \n- 重たいフレームワークが多い\n- 汎用的な言語をつかってるものが多く、そのためライブラリー等の依存関係が多くなりやすい   > SOLUTIONSOLUTION \n\nというわけで、年明け見つけたRedがシンプルだったので使ってみました。題材は以前つくったEmacsライブラリ「esa.el」の移植です。 \n\n- https://github.com/nabinno/esa.red   > やったことやったこと   > エディターエディター \n\n構文がすなおなので特にエディタは関係なさそうでしたが、慣れ親しんでるEmacsに「Skrylar/red.el」を適用しました。その際、 red-font-lock-keywords と red-indent-line に足りない箇所があったのでオーバーライドしました。   > 糖衣構文の適用糖衣構文の適用 \n\nRedはコマンドラインREPLがつかえるので、doc.red-lang.orgとred-by-example.orgをみながらひとつひとつ挙動を確認しました。その中でどうしても慣れない表現が2つあったので糖衣構文を実装（nabinno/red-elixir）。 \n\n1. compose \n\nブロック内の変数を評価しブロックとして返す関数 compose は、VIDのフェイス更新によく使われます。HTML/JavaScripでいうところDOM更新にあたるものといえば分かるでしょうか。頻繁に「 compose [foo (bar)] 」のような表現がつづくとほかの変数や関数とまざり可読性がおちるので、Elixirのシジルを参考に compose 関数を省略しました。こんな感じです。 \n\n;-- before compose [foo (bar)] ;-- after ~c[foo (bar)]  \n\n2. 関数の入れ子 \n\n素のRedはイテレーター構文なので、関数の入れ子による可読性低下をおさえるため変数定義をよく使います。個人的には変数は意味のあるものだけ使いたい派なので、パイプを導入しました。といっても、フロントエンドの場合、データ加工はあまりやらないのでつかうケースはほぼありませんでした。あってもこのくらいです。   red \n\n;-- before rejoin collect [ foreach d data [ keep rejoin [d \" \"] ] ] ;-- after data .[ |> Series/map 'd [rejoin [d \" \"]] |> rejoin ]     > タスクランナーの用意タスクランナーの用意 \n\n今回は上で実装したライブラリ「red-elixir」のほかにHTTPリクエスト・JSONパーサーライブラリを使っています。ライブラリパッケージはインストールはgit submodulesで良いですが、呼び出しも考えると実装が冗長的になるのでパッケージ管理とタスクランナーをあわせて用意しました（nabinno/hot、nabinno/mods）。 \n\nタスクランナーインストール後、パッケージのインストールから呼び出しまでの流れ \n\nRedはGoとおなじくワンバイナリーなので、wgetやcurlだけでインストールが完了します。   sh \n\n> mkdir -p ~/.local/bin > wget https://github.com/nabinno/hot/releases/download/0.0.3/hot-linux -O ~/.local/bin/hot > chmod 744 ~/.local/bin/hot   \n\nパッケージ管理はElixirのmixを参考にタスクランナー管理ファイル内に定義します。   sh \n\n> hot cmd/install https://raw.githubusercontent.com/nabinno/mods/master/mods.red > cat hots.red Red [] hots: context [ mods: [ red-elixir #(init: %init.red git: https://github.com/nabinno/red-elixir) json #(init: %json.red git: https://github.com/rebolek/red-tools) http-tools #(init: %http-tools.red git: https://github.com/rebolek/red-tools) ] ] > hot mods/get   \n\nビルド時は #include をつかうのでパッケージ呼び出し機能は使えないですが、コマンドラインREPLで挙動確認している際は do/args %require を使います。   sh \n\n> red >> do/args %require [red-elixir] >> 1 .. 10 .[ |> Series/map 'i [i * 2] |> Series/map 'i [i + 1] ] == [3 5 7 9 11 13 15 17 19 21]     > WRAPUPWRAPUP \n\nクライアントソフトを作る中で感じたことは、この1点です。Redは既存のフレームワークと比べるとまだまだ機能不足感が拭えませんが、それを補えるだけの表現力を持っていました。手触りが本当に良い言語でした。"},"name":"[2019-03-31]イケてるしヤバい言語REBOLの後継Redでクライアントソフトをつくった話","tags":["red","esa"],"childPublishedDate":{"published_on":"2019-03-31T00:00:00.000Z","published_on_unix":1553990400}}}]}},"pageContext":{"number":58}},"staticQueryHashes":[]}