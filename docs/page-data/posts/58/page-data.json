{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/58","result":{"data":{"esaPost":{"number":58,"relative_category":"blog/backend","fields":{"title":"WSL（Windows Subsystem for Linux）でDockerをつかったWebアプリケーション開発をおこなう際の注意点","excerpt":"これは無宗教ななびの  が書くDocker Advent Calendar 2017用記事です。前日はinductorさんの「Docker Meetupの中身まとめ」でした  （写真はクリスマスを日本にひろめた明治屋 ）   > PROBLEMPROBLEM \n\n- macOSとWindowsでWebアプリケーション開発をする際に 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- 環境が異なって管理しづらい それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- それならDockerで と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- と思ったが、macOSはBashでWindowsはPowerShellなのか せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- せめてPowerShellではなくBash... となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- となると、いまWindowsでLinux環境をつかうならWSLか ただ、実際どこまで開発ができるかわからんしなあ \n- ただ、実際どこまで開発ができるかわからんしなあ   > SOLUTIONSOLUTION \n\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。 \n\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。 \n\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。   > 対象環境対象環境 \n\n- Windows 10 Pro 1709 16299.64 Hyper-V 10.0.16299.15 Docker for Windows 17.09.0-ce-win33 Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Hyper-V 10.0.16299.15\n- Docker for Windows 17.09.0-ce-win33\n- Ubuntu 16.04 (Linux 4.4.0-43-Microsoft) Docker Client 1.12.6 \n- Docker Client 1.12.6   > Windowsの開発環境を構築するWindowsの開発環境を構築する \n\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。   > WSLのインストールWSLのインストール \n\n- Windows Subsystem for Linuxをインストールしてみよう！ \n\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。 \n\n1. apt WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します \n2. WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\n3. anyenv プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます \n4. プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\n5. exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\n6. nix ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう また、aptのバージョンが古すぎるパッケージもnixが最適です \n7. ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\n8. また、aptのバージョンが古すぎるパッケージもnixが最適です   > ターミナルのインストールターミナルのインストール \n\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。 \n\n- WSLtty Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- Pros ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い) EmacsでCtrl-SPC set-mark が機能する 画面サイズの変更が柔軟 \n- ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\n- EmacsでCtrl-SPC set-mark が機能する\n- 画面サイズの変更が柔軟\n- Cons PowerShellなどほかのコンソールの呼び出しが面倒 \n- PowerShellなどほかのコンソールの呼び出しが面倒\n- ConEmu Pros PowerShellなどほかのコンソールの呼び出しが楽 Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- Pros PowerShellなどほかのコンソールの呼び出しが楽 \n- PowerShellなどほかのコンソールの呼び出しが楽\n- Cons ファイルの読込速度がおそい EmacsでCtrl-SPC set-mark が機能しない 画面サイズの変更に制限がある \n- ファイルの読込速度がおそい\n- EmacsでCtrl-SPC set-mark が機能しない\n- 画面サイズの変更に制限がある   > WSLttyWSLtty \n\n- mintty/wsltty \n\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは chsh がつかえないのでログイン時につかいたいシェルを指定します。もし、 screen をつかいたい場合は /run/screen ディレクトリを作成してからコマンド指定します。   bat \n\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'   ConEmu \n\n- ConEmu - Handy Windows Terminal \n\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい1のでおすすめしません。 \n\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。   bash \n\n# task parameters /icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\" # task command bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%     > Docker for WindowsのインストールDocker for Windowsのインストール \n\n- Docker For Windows \n\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。 \n\n構成は下記のようになります。  \n\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 DOCKER_HOST をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。 \n\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\n2. WSL上のDockerクライアントに DOCKER_HOST=tcp://0.0.0.0:2375 を設定 \n\nWSLには下記のようなaliasを用意しておくといいでしょう。   bash \n\nexport DOCKER_HOST=tcp://0.0.0.0:2375 alias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\" alias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"     > さて、WSLからDocker for Windowsはどの程度つかえるのかさて、WSLからDocker for Windowsはどの程度つかえるのか \n\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。 \n\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\n2. WSLはLinux形式のパスしか扱えません、C:\\Dev のようなドライブ名にコロンをつけたURIスキーマは扱えません\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません2 \n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります3  \n\nひとつずつ解決方法を見ていきましょう。   > 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません \n\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。   > 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません \n\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。   bash \n\n$ ln -s /mnt/c /C # 開発ディレクトリはこんな感じで参照できます $ ls -al /C/Dev total 0 drwxrwxrwx 0 root root 512 Oct 27 00:54 . drwxrwxrwx 0 root root 512 Dec 8 07:49 .. drwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1 drwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2     > 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません \n\n各OS間での違いを吸収するため、プロジェクトに PRJ_ROOT のような環境変数を用意しましょう。   yaml \n\nservices: app-front: image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front volumes: - ${PRJ_ROOT}/front:/var/www/front     > 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります \n\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました  \n\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。   bash \n\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules $ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules     > WRAPUPWRAPUP \n\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。 \n\n随時、気になる課題が出てきたら追記します。  \n\n1. https://github.com/cmderdev/cmder/issues/901 ↩ \n2. https://github.com/docker/compose/issues/4039#issuecomment-269558432 ↩ \n3. https://github.com/Microsoft/WSL/issues/2448 ↩","thumbnail":"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png"},"wip":false,"body_md":"<img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\">\r\n\r\n\r\nこれは無宗教ななびの :construction_worker: が書く[Docker Advent Calendar 2017](https://qiita.com/advent-calendar/2017/docker)用記事です。前日はinductorさんの「[Docker Meetupの中身まとめ](https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e)」でした :whale: （写真は[クリスマスを日本にひろめた明治屋](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3) :christmas_tree:）\r\n\r\n# PROBLEM\r\n- macOSとWindowsでWebアプリケーション開発をする際に\r\n    - 環境が異なって管理しづらい\r\n        - それならDockerで\r\n            - と思ったが、macOSはBashでWindowsはPowerShellなのか\r\n                - せめてPowerShellではなくBash...\r\n                    - となると、いまWindowsでLinux環境をつかうならWSLか\r\n                        - ただ、実際どこまで開発ができるかわからんしなあ\r\n\r\n# SOLUTION\r\nというわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。\r\n\r\n前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。\r\n\r\n要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。\r\n\r\n## 対象環境\r\n- Windows 10 Pro 1709 16299.64\r\n    - Hyper-V 10.0.16299.15\r\n    - Docker for Windows 17.09.0-ce-win33\r\n    - Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\r\n        - Docker Client 1.12.6\r\n\r\n## Windowsの開発環境を構築する\r\nまず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。\r\n\r\n### WSLのインストール\r\n- [Windows Subsystem for Linuxをインストールしてみよう！](https://qiita.com/Aruneko/items/c79810b0b015bebf30bb)\r\n\r\nWSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。\r\n1. apt\r\n    - WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します\r\n2. [anyenv](https://github.com/riywo/anyenv)\r\n    - プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう\r\n    - exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます\r\n3. [nix](https://nixos.org/nix/)\r\n    - ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう\r\n    - また、aptのバージョンが古すぎるパッケージもnixが最適です\r\n\r\n### ターミナルのインストール\r\nWSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。\r\n\r\n- WSLtty\r\n    - Pros\r\n        - ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)\r\n        - EmacsでCtrl-SPC `set-mark` が機能する\r\n        - 画面サイズの変更が柔軟\r\n    - Cons\r\n        - PowerShellなどほかのコンソールの呼び出しが面倒\r\n- ConEmu\r\n    - Pros\r\n        - PowerShellなどほかのコンソールの呼び出しが楽\r\n    - Cons\r\n        - ファイルの読込速度がおそい\r\n        - EmacsでCtrl-SPC `set-mark` が機能しない\r\n        - 画面サイズの変更に制限がある\r\n\r\n### WSLtty\r\n- [mintty/wsltty](https://github.com/mintty/wsltty)\r\n\r\nWSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは `chsh` がつかえないのでログイン時につかいたいシェルを指定します。もし、 `screen` をつかいたい場合は `/run/screen` ディレクトリを作成してからコマンド指定します。\r\n\r\n```bat\r\n%LOCALAPPDATA%\\wsltty\\bin\\mintty.exe --wsl -o Locale=C -o Charset=UTF-8 /bin/wslbridge -t /bin/bash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen'\r\n```\r\n\r\n#### ConEmu\r\n- [ConEmu - Handy Windows Terminal](https://conemu.github.io/)\r\n\r\nWSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい[^1]のでおすすめしません。\r\n\r\n[^1]: [https://github.com/cmderdev/cmder/issues/901](https://github.com/cmderdev/cmder/issues/901)\r\n\r\nConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。\r\n\r\n```bash\r\n# task parameters\r\n/icon \"C:\\Program Files\\WindowsApps\\CanonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc\\images\\icon.ico\"\r\n\r\n# task command\r\nbash -c 'sudo mkdir /run/screen && sudo chmod 775 $_ && sudo chown root:utmp $_ && SHELL=/usr/bin/zsh screen' -new_console:d:%USERPROFILE%\r\n```\r\n\r\n### Docker for Windowsのインストール\r\n- [Docker For Windows](https://www.docker.com/docker-windows)\r\n\r\nWSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。\r\n\r\n構成は下記のようになります。\r\n\r\n<img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\">\r\n\r\nDockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 `DOCKER_HOST` をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。\r\n1. Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定\r\n2. WSL上のDockerクライアントに `DOCKER_HOST=tcp://0.0.0.0:2375` を設定\r\n\r\nWSLには下記のようなaliasを用意しておくといいでしょう。\r\n\r\n```bash\r\nexport DOCKER_HOST=tcp://0.0.0.0:2375\r\nalias docker=\"DOCKER_HOST=${DOCKER_HOST} docker\"\r\nalias docker-compose=\"docker-compose -H ${DOCKER_HOST}\"\r\n```\r\n\r\n## さて、WSLからDocker for Windowsはどの程度つかえるのか\r\nWSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。\r\n\r\n1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n2. WSLはLinux形式のパスしか扱えません、`C:\\Dev` のようなドライブ名にコロンをつけたURIスキーマは扱えません\r\n3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません[^2]\r\n4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります[^3]\r\n\r\n[^2]: [https://github.com/docker/compose/issues/4039#issuecomment-269558432](https://github.com/docker/compose/issues/4039#issuecomment-269558432)\r\n[^3]: [https://github.com/Microsoft/WSL/issues/2448](https://github.com/Microsoft/WSL/issues/2448)\r\n\r\nひとつずつ解決方法を見ていきましょう。\r\n\r\n### 1. Docker for WindowsはNTFS (WSLからみるとdrvfs `/mnt/`) 上のファイルしかVolumeマウントできません\r\n開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。\r\n\r\n### 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\r\nNTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。\r\n\r\n```bash\r\n$ ln -s /mnt/c /C\r\n\r\n# 開発ディレクトリはこんな感じで参照できます\r\n$ ls -al /C/Dev\r\ntotal 0\r\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 .\r\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\r\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\r\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\r\n```\r\n\r\n### 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\r\n各OS間での違いを吸収するため、プロジェクトに `PRJ_ROOT` のような環境変数を用意しましょう。\r\n\r\n```yaml\r\nservices:\r\n  app-front:\r\n    image: 561534604247952616898.dkr.ecr.amazonaws.com/test/front\r\n    volumes:\r\n      - ${PRJ_ROOT}/front:/var/www/front\r\n```\r\n\r\n### 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\r\nこちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました :tada:\r\n\r\nもし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。\r\n\r\n```bash\r\n$ mkdir /home/foo/tmp/app-test-1/front/node_modules\r\n$ ln -s /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\r\n```\r\n\r\n# WRAPUP\r\nまだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。\r\n\r\n随時、気になる課題が出てきたら追記します。\r\n\r\n","body_html":"<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"2399\" alt=\"thumbnail\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/5292e497-7062-4634-9873-8d03333821a1.png\"></a>\n<p data-sourcepos=\"4:1-4:513\">これは無宗教ななびの <img class=\"emoji\" title=\":construction_worker:\" alt=\":construction_worker:\" src=\"https://assets.esa.io/images/emoji/unicode/1f477.png\"> が書く<a href=\"https://qiita.com/advent-calendar/2017/docker\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Advent Calendar 2017</a>用記事です。前日はinductorさんの「<a href=\"https://mohikanz.kibe.la/shared/entries/c170117c-b876-49da-931a-9788a473164e\" target=\"_blank\" rel=\"noopener noreferrer\">Docker Meetupの中身まとめ</a>」でした <img class=\"emoji\" title=\":whale:\" alt=\":whale:\" src=\"https://assets.esa.io/images/emoji/unicode/1f433.png\"> （写真は<a href=\"https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%9E%E3%82%B9#%E6%98%8E%E6%B2%BB%E6%99%82%E4%BB%A3\" target=\"_blank\" rel=\"noopener noreferrer\">クリスマスを日本にひろめた明治屋</a> <img class=\"emoji\" title=\":christmas_tree:\" alt=\":christmas_tree:\" src=\"https://assets.esa.io/images/emoji/unicode/1f384.png\">）</p>\n<h1 data-sourcepos=\"6:1-6:9\" id=\"1-0-0\" name=\"1-0-0\">\n<a class=\"anchor\" id=\"PROBLEM\" name=\"PROBLEM\" href=\"#PROBLEM\" data-position=\"1-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"PROBLEM\"> &gt; PROBLEM</span></a>PROBLEM</h1>\n<ul data-sourcepos=\"7:1-14:0\">\n<li data-sourcepos=\"7:1-14:0\">macOSとWindowsでWebアプリケーション開発をする際に\n<ul data-sourcepos=\"8:5-14:0\">\n<li data-sourcepos=\"8:5-14:0\">環境が異なって管理しづらい\n<ul data-sourcepos=\"9:9-14:0\">\n<li data-sourcepos=\"9:9-14:0\">それならDockerで\n<ul data-sourcepos=\"10:13-14:0\">\n<li data-sourcepos=\"10:13-14:0\">と思ったが、macOSはBashでWindowsはPowerShellなのか\n<ul data-sourcepos=\"11:17-14:0\">\n<li data-sourcepos=\"11:17-14:0\">せめてPowerShellではなくBash...\n<ul data-sourcepos=\"12:21-14:0\">\n<li data-sourcepos=\"12:21-14:0\">となると、いまWindowsでLinux環境をつかうならWSLか\n<ul data-sourcepos=\"13:25-14:0\">\n<li data-sourcepos=\"13:25-14:0\">ただ、実際どこまで開発ができるかわからんしなあ</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 data-sourcepos=\"15:1-15:10\" id=\"2-0-0\" name=\"2-0-0\">\n<a class=\"anchor\" id=\"SOLUTION\" name=\"SOLUTION\" href=\"#SOLUTION\" data-position=\"2-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"SOLUTION\"> &gt; SOLUTION</span></a>SOLUTION</h1>\n<p data-sourcepos=\"16:1-16:165\">というわけで、この記事ではmacOSとWindowsによるWebアプリケーション開発について、どこまで共有できるか書いていきます。</p>\n<p data-sourcepos=\"18:1-18:283\">前提条件として、当該WebアプリケーションはmacOSというより、Bash/Ubuntu14.04~のLinux環境で動くことを想定しています。macOSはHFS+やAPFSのUnicode正規化以外はおおよそLinux環境に適応できているという判断によります。</p>\n<p data-sourcepos=\"20:1-20:135\">要は、WSLでDockerをつかったWebアプリケーション開発ができるかどうかという点に焦点をしぼります。</p>\n<h2 data-sourcepos=\"22:1-22:15\" id=\"2-1-0\" name=\"2-1-0\">\n<a class=\"anchor\" id=\"対象環境\" name=\"%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" href=\"#%E5%AF%BE%E8%B1%A1%E7%92%B0%E5%A2%83\" data-position=\"2-1-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"対象環境\"> &gt; 対象環境</span></a>対象環境</h2>\n<ul data-sourcepos=\"23:1-28:0\">\n<li data-sourcepos=\"23:1-28:0\">Windows 10 Pro 1709 16299.64\n<ul data-sourcepos=\"24:5-28:0\">\n<li data-sourcepos=\"24:5-24:27\">Hyper-V 10.0.16299.15</li>\n<li data-sourcepos=\"25:5-25:41\">Docker for Windows 17.09.0-ce-win33</li>\n<li data-sourcepos=\"26:5-28:0\">Ubuntu 16.04 (Linux 4.4.0-43-Microsoft)\n<ul data-sourcepos=\"27:9-28:0\">\n<li data-sourcepos=\"27:9-28:0\">Docker Client 1.12.6</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 data-sourcepos=\"29:1-29:40\" id=\"2-2-0\" name=\"2-2-0\">\n<a class=\"anchor\" id=\"Windowsの開発環境を構築する\" name=\"Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" href=\"#Windows%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B\" data-position=\"2-2-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Windowsの開発環境を構築する\"> &gt; Windowsの開発環境を構築する</span></a>Windowsの開発環境を構築する</h2>\n<p data-sourcepos=\"30:1-30:116\">まず、Windowsの開発環境の構築ですが、既知の情報をふまえつつTIPSを順次紹介します。</p>\n<h3 data-sourcepos=\"32:1-32:28\" id=\"2-2-1\" name=\"2-2-1\">\n<a class=\"anchor\" id=\"WSLのインストール\" name=\"WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#WSL%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLのインストール\"> &gt; WSLのインストール</span></a>WSLのインストール</h3>\n<ul data-sourcepos=\"33:1-34:0\">\n<li data-sourcepos=\"33:1-34:0\"><a href=\"https://qiita.com/Aruneko/items/c79810b0b015bebf30bb\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Subsystem for Linuxをインストールしてみよう！</a></li>\n</ul>\n<p data-sourcepos=\"35:1-35:91\">WSLのパッケージ管理は下記3つを押さえておけば問題ないでしょう。</p>\n<ol data-sourcepos=\"36:1-44:0\">\n<li data-sourcepos=\"36:1-37:153\">apt\n<ul data-sourcepos=\"37:5-37:153\">\n<li data-sourcepos=\"37:5-37:153\">WSLではデーモンがつかえないのでDockerクライアントを入れましょう、Dockerデーモンの詳細は後ほど言及します</li>\n</ul>\n</li>\n<li data-sourcepos=\"38:1-40:134\">\n<a href=\"https://github.com/riywo/anyenv\" target=\"_blank\" rel=\"noopener noreferrer\">anyenv</a>\n<ul data-sourcepos=\"39:5-40:134\">\n<li data-sourcepos=\"39:5-39:123\">プログラミング言語をバージョンごとにわけて使いたい場合はこちらをつかいましょう</li>\n<li data-sourcepos=\"40:5-40:134\">exenvがビルドで失敗するためElixirインストールできないほかは、各言語問題なくビルドできます</li>\n</ul>\n</li>\n<li data-sourcepos=\"41:1-44:0\">\n<a href=\"https://nixos.org/nix/\" target=\"_blank\" rel=\"noopener noreferrer\">nix</a>\n<ul data-sourcepos=\"42:5-44:0\">\n<li data-sourcepos=\"42:5-42:154\">ElixirやHaskellのようにanyenvでインストールできない、あるいは、扱われいないパッケージはnixをつかいましょう</li>\n<li data-sourcepos=\"43:5-44:0\">また、aptのバージョンが古すぎるパッケージもnixが最適です</li>\n</ul>\n</li>\n</ol>\n<h3 data-sourcepos=\"45:1-45:40\" id=\"2-2-2\" name=\"2-2-2\">\n<a class=\"anchor\" id=\"ターミナルのインストール\" name=\"%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"ターミナルのインストール\"> &gt; ターミナルのインストール</span></a>ターミナルのインストール</h3>\n<p data-sourcepos=\"46:1-46:174\">WSLttyかConEmuをおすすめします。各々の特徴は下記のとおりですが、通常のWebアプリケーション開発であればWSLttyがいいでしょう。</p>\n<ul data-sourcepos=\"48:1-62:0\">\n<li data-sourcepos=\"48:1-54:74\">WSLtty\n<ul data-sourcepos=\"49:5-54:74\">\n<li data-sourcepos=\"49:5-52:43\">Pros\n<ul data-sourcepos=\"50:9-52:43\">\n<li data-sourcepos=\"50:9-50:87\">ConEmuとくらべてファイルの読込速度が速い (VMよりは遅い)</li>\n<li data-sourcepos=\"51:9-51:53\">EmacsでCtrl-SPC <code>set-mark</code> が機能する</li>\n<li data-sourcepos=\"52:9-52:43\">画面サイズの変更が柔軟</li>\n</ul>\n</li>\n<li data-sourcepos=\"53:5-54:74\">Cons\n<ul data-sourcepos=\"54:9-54:74\">\n<li data-sourcepos=\"54:9-54:74\">PowerShellなどほかのコンソールの呼び出しが面倒</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-sourcepos=\"55:1-62:0\">ConEmu\n<ul data-sourcepos=\"56:5-62:0\">\n<li data-sourcepos=\"56:5-57:71\">Pros\n<ul data-sourcepos=\"57:9-57:71\">\n<li data-sourcepos=\"57:9-57:71\">PowerShellなどほかのコンソールの呼び出しが楽</li>\n</ul>\n</li>\n<li data-sourcepos=\"58:5-62:0\">Cons\n<ul data-sourcepos=\"59:9-62:0\">\n<li data-sourcepos=\"59:9-59:49\">ファイルの読込速度がおそい</li>\n<li data-sourcepos=\"60:9-60:56\">EmacsでCtrl-SPC <code>set-mark</code> が機能しない</li>\n<li data-sourcepos=\"61:9-62:0\">画面サイズの変更に制限がある</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 data-sourcepos=\"63:1-63:10\" id=\"2-2-3\" name=\"2-2-3\">\n<a class=\"anchor\" id=\"WSLtty\" name=\"WSLtty\" href=\"#WSLtty\" data-position=\"2-2-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WSLtty\"> &gt; WSLtty</span></a>WSLtty</h3>\n<ul data-sourcepos=\"64:1-65:0\">\n<li data-sourcepos=\"64:1-65:0\"><a href=\"https://github.com/mintty/wsltty\" target=\"_blank\" rel=\"noopener noreferrer\">mintty/wsltty</a></li>\n</ul>\n<p data-sourcepos=\"66:1-66:477\">WSL用ターミナルとしてのMinttyです。操作はMinttyとかわらず、元Cygwinづかいにはうれしい操作感です。というわけで、いつものごとく起動用ショートカットのターゲットを準備します。WSLは <code>chsh</code> がつかえないのでログイン時につかいたいシェルを指定します。もし、 <code>screen</code> をつかいたい場合は <code>/run/screen</code> ディレクトリを作成してからコマンド指定します。</p>\n<div class=\"code-block\" data-sourcepos=\"68:1-70:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bat</div>\n<div class=\"highlight\"><pre class=\"highlight batchfile\"><code><span class=\"nv\">%LOCALAPPDATA%</span>\\wsltty\\bin\\mintty.exe <span class=\"na\">--wsl -o </span><span class=\"kd\">Locale</span><span class=\"o\">=</span><span class=\"kd\">C</span> <span class=\"na\">-o </span><span class=\"kd\">Charset</span><span class=\"o\">=</span><span class=\"kd\">UTF</span><span class=\"o\">-</span><span class=\"m\">8</span> <span class=\"na\">/bin/wslbridge -t /bin/bash -c </span><span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span>\n</code></pre></div>\n</div>\n<h4 data-sourcepos=\"72:1-72:11\">ConEmu</h4>\n<ul data-sourcepos=\"73:1-74:0\">\n<li data-sourcepos=\"73:1-74:0\"><a href=\"https://conemu.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">ConEmu - Handy Windows Terminal</a></li>\n</ul>\n<p data-sourcepos=\"75:1-75:258\">WSL上で日本語を表示するため、また、WSLのLinux環境とWindows環境でターミナルをわけるため、ConEmuをつかいましょう。ConEmuをスマートにしたCmderはWSLとの相性がわるい<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">1</a></sup>のでおすすめしません。</p>\n<p data-sourcepos=\"79:1-79:127\">ConEmuの設定「Startup-Tasks」では、WSL用にパラメータ、コマンドを下記のように指定しています。</p>\n<div class=\"code-block\" data-sourcepos=\"81:1-87:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"c\"># task parameters</span>\n/icon <span class=\"s2\">\"C:</span><span class=\"se\">\\P</span><span class=\"s2\">rogram Files</span><span class=\"se\">\\W</span><span class=\"s2\">indowsApps</span><span class=\"se\">\\C</span><span class=\"s2\">anonicalGroupLimited.UbuntuonWindows_1604.2017.922.0_x64__79rhkp1fndgsc</span><span class=\"se\">\\i</span><span class=\"s2\">mages</span><span class=\"se\">\\i</span><span class=\"s2\">con.ico\"</span>\n\n<span class=\"c\"># task command</span>\nbash <span class=\"nt\">-c</span> <span class=\"s1\">'sudo mkdir /run/screen &amp;&amp; sudo chmod 775 $_ &amp;&amp; sudo chown root:utmp $_ &amp;&amp; SHELL=/usr/bin/zsh screen'</span> <span class=\"nt\">-new_console</span>:d:%USERPROFILE%\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"89:1-89:43\" id=\"2-2-4\" name=\"2-2-4\">\n<a class=\"anchor\" id=\"Docker for Windowsのインストール\" name=\"Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" href=\"#Docker%20for%20Windows%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\" data-position=\"2-2-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"Docker for Windowsのインストール\"> &gt; Docker for Windowsのインストール</span></a>Docker for Windowsのインストール</h3>\n<ul data-sourcepos=\"90:1-91:0\">\n<li data-sourcepos=\"90:1-91:0\"><a href=\"https://www.docker.com/docker-windows\" target=\"_blank\" rel=\"noopener noreferrer\">Docker For Windows</a></li>\n</ul>\n<p data-sourcepos=\"92:1-92:202\">WSLではDockerデーモンがつかえないのでNTFS (WSLからみるとdrvfs) 側で用意します。インストールはDockerのダウンロードページから手順通りおこないます。</p>\n<p data-sourcepos=\"94:1-94:42\">構成は下記のようになります。</p>\n<a href=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img width=\"1739\" alt=\"image.png (93.7 kB)\" src=\"https://img.esa.io/uploads/production/attachments/16651/2021/01/12/97367/8d95bd97-4e7a-4e20-850c-0e0052d28bcb.png\"></a>\n<p data-sourcepos=\"98:1-98:240\">DockerクライアントからDockerデーモンにつなぐには、セキュリティリスクはありますが、 <code>DOCKER_HOST</code> をつかうのが簡易的です。Docker for WindowsとDockerクライアント、各々設定します。</p>\n<ol data-sourcepos=\"99:1-101:0\">\n<li data-sourcepos=\"99:1-99:118\">Docker for WindowsよりDockerデーモンを「Expose daemon on tcp://localhost:2375 without TLS」として設定</li>\n<li data-sourcepos=\"100:1-101:0\">WSL上のDockerクライアントに <code>DOCKER_HOST=tcp://0.0.0.0:2375</code> を設定</li>\n</ol>\n<p data-sourcepos=\"102:1-102:77\">WSLには下記のようなaliasを用意しておくといいでしょう。</p>\n<div class=\"code-block\" data-sourcepos=\"104:1-108:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nb\">export </span><span class=\"nv\">DOCKER_HOST</span><span class=\"o\">=</span>tcp://0.0.0.0:2375\n<span class=\"nb\">alias </span><span class=\"nv\">docker</span><span class=\"o\">=</span><span class=\"s2\">\"DOCKER_HOST=</span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\"> docker\"</span>\n<span class=\"nb\">alias </span>docker-compose<span class=\"o\">=</span><span class=\"s2\">\"docker-compose -H </span><span class=\"k\">${</span><span class=\"nv\">DOCKER_HOST</span><span class=\"k\">}</span><span class=\"s2\">\"</span>\n</code></pre></div>\n</div>\n<h2 data-sourcepos=\"110:1-110:72\" id=\"2-3-0\" name=\"2-3-0\">\n<a class=\"anchor\" id=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\" name=\"%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" href=\"#%E3%81%95%E3%81%A6%E3%80%81WSL%E3%81%8B%E3%82%89Docker%20for%20Windows%E3%81%AF%E3%81%A9%E3%81%AE%E7%A8%8B%E5%BA%A6%E3%81%A4%E3%81%8B%E3%81%88%E3%82%8B%E3%81%AE%E3%81%8B\" data-position=\"2-3-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"さて、WSLからDocker for Windowsはどの程度つかえるのか\"> &gt; さて、WSLからDocker for Windowsはどの程度つかえるのか</span></a>さて、WSLからDocker for Windowsはどの程度つかえるのか</h2>\n<p data-sourcepos=\"111:1-111:189\">WSLがlxfs、Docker for WindowsがNTFS (drvfs) 上で動いていることからわかるように、ファイルシステム上の制約があります。具体的には下記4点です。</p>\n<ol data-sourcepos=\"113:1-117:0\">\n<li data-sourcepos=\"113:1-113:120\">Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</li>\n<li data-sourcepos=\"114:1-114:146\">WSLはLinux形式のパスしか扱えません、<code>C:\\Dev</code> のようなドライブ名にコロンをつけたURIスキーマは扱えません</li>\n<li data-sourcepos=\"115:1-115:105\">WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">2</a></sup>\n</li>\n<li data-sourcepos=\"116:1-117:0\">WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">3</a></sup>\n</li>\n</ol>\n<p data-sourcepos=\"121:1-121:57\">ひとつずつ解決方法を見ていきましょう。</p>\n<h3 data-sourcepos=\"123:1-123:124\" id=\"2-3-1\" name=\"2-3-1\">\n<a class=\"anchor\" id=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\" name=\"1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#1.%20Docker%20for%20Windows%E3%81%AFNTFS%20(WSL%E3%81%8B%E3%82%89%E3%81%BF%E3%82%8B%E3%81%A8drvfs%20/mnt/)%20%E4%B8%8A%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%97%E3%81%8BVolume%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-1\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません\"> &gt; 1. Docker for WindowsはNTFS (WSLからみるとdrvfs /mnt/) 上のファイルしかVolumeマウントできません</span></a>1. Docker for WindowsはNTFS (WSLからみるとdrvfs <code>/mnt/</code>) 上のファイルしかVolumeマウントできません</h3>\n<p data-sourcepos=\"124:1-124:174\">開発用ディレクトリをNTFS上につくりましょう。普段からWindowsで開発されている方はCドライブ直下につくっているとおもいます。</p>\n<h3 data-sourcepos=\"126:1-126:129\" id=\"2-3-2\" name=\"2-3-2\">\n<a class=\"anchor\" id=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\" name=\"2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#2.%20WSL%E3%81%AFLinux%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%83%91%E3%82%B9%E3%81%97%E3%81%8B%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E3%83%89%E3%83%A9%E3%82%A4%E3%83%96%E5%90%8D%E3%81%AB%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E3%81%A4%E3%81%91%E3%81%9FURI%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AF%E6%89%B1%E3%81%88%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-2\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません\"> &gt; 2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</span></a>2. WSLはLinux形式のパスしか扱えません、ドライブ名にコロンをつけたURIスキーマは扱えません</h3>\n<p data-sourcepos=\"127:1-127:157\">NTFSからのパス参照とWSLからのパス参照を共通化するために、WSLに各ドライブのシンボリックリンクをはりましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"129:1-139:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /mnt/c /C\n\n<span class=\"c\"># 開発ディレクトリはこんな感じで参照できます</span>\n<span class=\"nv\">$ </span><span class=\"nb\">ls</span> <span class=\"nt\">-al</span> /C/Dev\ntotal 0\ndrwxrwxrwx 0 root root 512 Oct 27 00:54 <span class=\"nb\">.</span>\ndrwxrwxrwx 0 root root 512 Dec  8 07:49 ..\ndrwxrwxrwx 0 root root 512 Jul 14 03:06 app-test-1\ndrwxrwxrwx 0 root root 512 Oct 25 00:38 app-test-2\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"141:1-141:105\" id=\"2-3-3\" name=\"2-3-3\">\n<a class=\"anchor\" id=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\" name=\"3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" href=\"#3.%20WSL%E4%B8%8A%E3%81%AEdocker-compose%E3%81%AF%E3%83%91%E3%82%B9%E3%82%92%E7%B5%B6%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%81%E7%9B%B8%E5%AF%BE%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93\" data-position=\"2-3-3\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません\"> &gt; 3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</span></a>3. WSL上のdocker-composeはパスを絶対参照しかできません、相対参照できません</h3>\n<p data-sourcepos=\"142:1-142:128\">各OS間での違いを吸収するため、プロジェクトに <code>PRJ_ROOT</code> のような環境変数を用意しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"144:1-150:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>yaml</div>\n<div class=\"highlight\"><pre class=\"highlight yaml\"><code><span class=\"na\">services</span><span class=\"pi\">:</span>\n  <span class=\"na\">app-front</span><span class=\"pi\">:</span>\n    <span class=\"na\">image</span><span class=\"pi\">:</span> <span class=\"s\">561534604247952616898.dkr.ecr.amazonaws.com/test/front</span>\n    <span class=\"na\">volumes</span><span class=\"pi\">:</span>\n      <span class=\"pi\">-</span> <span class=\"s\">${PRJ_ROOT}/front:/var/www/front</span>\n</code></pre></div>\n</div>\n<h3 data-sourcepos=\"152:1-152:104\" id=\"2-3-4\" name=\"2-3-4\">\n<a class=\"anchor\" id=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\" name=\"4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" href=\"#4.%20WSL%E4%B8%8A%E3%81%AEnpm/yarn%E3%81%AB%E3%82%88%E3%82%8BJS%E3%83%93%E3%83%AB%E3%83%89%E3%82%92NTFS%20(drvfs)%E4%B8%8A%E3%81%A7%E3%81%8A%E3%81%93%E3%81%AA%E3%81%86%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99\" data-position=\"2-3-4\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります\"> &gt; 4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</span></a>4. WSL上のnpm/yarnによるJSビルドをNTFS (drvfs)上でおこなうとエラーになります</h3>\n<p data-sourcepos=\"153:1-153:136\">こちらはFall Creators Updateのデグレですが、更新プログラム (KB4051963) でこの問題が修正されました <img class=\"emoji\" title=\":tada:\" alt=\":tada:\" src=\"https://assets.esa.io/images/emoji/unicode/1f389.png\"></p>\n<p data-sourcepos=\"155:1-155:160\">もし更新プログラムが適用できない場合は、シンボリックリンクでNTFS上のnode_modulesディレクトリをWSLに移しましょう。</p>\n<div class=\"code-block\" data-sourcepos=\"157:1-160:3\">\n<div class=\"code-filename\">\n<i class=\"fa fa-file-code-o\"></i>bash</div>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span><span class=\"nb\">mkdir</span> /home/foo/tmp/app-test-1/front/node_modules\n<span class=\"nv\">$ </span><span class=\"nb\">ln</span> <span class=\"nt\">-s</span> /home/foo/tmp/app-test-1/front/node_modules /C/Dev/app-test-1/front/node_modules\n</code></pre></div>\n</div>\n<h1 data-sourcepos=\"162:1-162:8\" id=\"3-0-0\" name=\"3-0-0\">\n<a class=\"anchor\" id=\"WRAPUP\" name=\"WRAPUP\" href=\"#WRAPUP\" data-position=\"3-0-0\"><i class=\"fa fa-link\"></i><span class=\"hidden\" data-text=\"WRAPUP\"> &gt; WRAPUP</span></a>WRAPUP</h1>\n<p data-sourcepos=\"163:1-163:198\">まだ未検証な部分はのこっていますが、ひととおりmacOSとWindowsによるWebアプリケーション開発は共有できるところまできている、と言えそうです。</p>\n<p data-sourcepos=\"165:1-165:63\">随時、気になる課題が出てきたら追記します。</p>\n<section class=\"footnotes\">\n<ol>\n<li id=\"fn1\">\n<p data-sourcepos=\"77:7-77:98\"><a href=\"https://github.com/cmderdev/cmder/issues/901\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/cmderdev/cmder/issues/901</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\">\n<p data-sourcepos=\"118:7-118:146\"><a href=\"https://github.com/docker/compose/issues/4039#issuecomment-269558432\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/docker/compose/issues/4039#issuecomment-269558432</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\">\n<p data-sourcepos=\"119:7-119:98\"><a href=\"https://github.com/Microsoft/WSL/issues/2448\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Microsoft/WSL/issues/2448</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","tags":["wsl","docker","ubuntu"],"updated_at":"2021-01-12T01:27:16+09:00","childPublishedDate":{"published_on":"2017-12-10T00:00:00.000Z"},"updated_by":{"name":"なびの👷","screen_name":"nabinno","icon":"https://img.esa.io/uploads/production/members/94286/icon/thumb_m_ef5f024307008aa399b91f87fa5f64e8.jpg"}},"relatedPosts":{"edges":[{"node":{"number":47,"relative_category":"blog/organization","fields":{"title":"マネジメントとは何か","excerpt":"組織が大きくなってくると自然と自らの手ではどうしようもできなくなり、マネジメント業務を各メンバーに委譲する必要が出てきます。そうは言っても個別のタスク指示はすんなり出来ても、「よしなにやって」つまり「周辺の整理（マネジメント）も含めて上手くタスクを回せるように調整して」と言う指示は一言では伝えきれません。マネジメント職同士のやりとりなら問題ないのですが、これからマネジメント領域に入っていって欲しいメンバーの場合はどう連携すれば良いのでしょうか。未完ではありますが、今回はマネジメントそのものについて整理しました。   > PROBLEMPROBLEM \n\n- チームメンバーにマネジメントを理解して欲しい けれど、マネジメントに関する書籍が多く、一言でこれを読めと伝えるのが難しい 一方、一言では言い表せないが、一目でなら表せるものが自分の中に出来上がっている 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- けれど、マネジメントに関する書籍が多く、一言でこれを読めと伝えるのが難しい\n- 一方、一言では言い表せないが、一目でなら表せるものが自分の中に出来上がっている 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- 昔手にした書籍をヒントにマネジメントの枠組みというのを自分の頭に構築していた ただ、そのことについて書かれた書籍を見たことがない \n- ただ、そのことについて書かれた書籍を見たことがない   > SOLUTIONSOLUTION \n\nというわけで、自分の頭の中に出来上がったマネジメントのフレームワークについて改めて整理することにしました。 \n\n私はそのフレームワークを「GRPR（グルーパー）マネジメントサイクル」と呼んでいます。GRPRはゴール（G）、リソース（R）、プロセス（P）、ルール（R）の頭文字の組み合わせです。私はこのGRPRを grouper（熱帯や温帯の海域に分布する魚のハタの意）の略字に見立てることで、マネジメントサイクルをハタの形に重ねて覚えています。下記がそのサイクルです。どうです、ハタに見えませんか? \n\n \n\nこのフレームワークはどの職種にも応用ができ、今までいくつかの職種の中でマネジメントを行ってきましたが、どれも無理なく実施できました。そして、これは各種マネジメント関連の書籍を整理する際の枠組みとしても使えます。この当たりを冗長に書こうとすると切りがないのでここでは完結に記す予定です。 \n\nでは、具体的に各要素を見ていきましょう。   > ゴールゴール \n\n計画と意思決定を行います。これはSMARTに則り戦略的かつ具体的に測定可能で達成可能、関連性のある期限あるものが良いです。下記のようなMBOで設定する目標が分かりやすい例です。 \n\n目標例 \n\n- デザインコーディネーション 組織パターン \n- 組織パターン\n- サービスカタログ   > 変化前のリソースとプロセス変化前のリソースとプロセス \n\nゴールを決めた後にその方向に動き出すための現状把握を行います。対象にはリソースとプロセスがありますが、それらは人も含みます。まずリソースについて、人の場合は意志の状態と価値観の確認を行い、人以外の場合は当該リソースのステータスを確認します。 \n\n- マインドフルネス、アンガーマネジメント、心理的安全性\n- キャリアアンカー \n\nプロセスについては各業務フロー、システムフローを確認します。 \n\n- CMMI   > 変化後のリソースとプロセス変化後のリソースとプロセス \n\n現状を把握した後に目指すべきリソースとプロセスが決まったらそちらに変更を促します。所謂 指示と動機付けを元にした「変更管理」を行います。これはリーダーシップという切り口で語られることが多いマネジメント領域です。   > ルールルール \n\n最後にリソースやプロセスの現状や変化を観察し評価します。この評価によってルールを定め、次のゴールへと段階を上げていきます。なお、ルールはリソースやプロセスに制限をかけるものではありますが、長期的に見た際に安全に業務を回すためのガードレールの役割を果たします。 \n\n例えば、ルールには下記のようなものがあります。 \n\n- 業務運用方針\n- 各パブリッククラウドのIAM設定・運用の方針\n- AWS Control Tower   > WRAPUPWRAPUP \n\n最低限の部分をまとめてみました。まずはメンバーからのフィードバックをもらいつつ今後も気になるところを追加していく予定です。"},"name":"マネジメントとは何か","tags":["team-building"],"childPublishedDate":{"published_on":"2021-03-31T22:39:35.000Z","published_on_unix":1617230375}}},{"node":{"number":75,"relative_category":"blog/backend","fields":{"title":"CDKで管理する今どきのJenkins","excerpt":"先日のAWS障害で管理していたECSに多少の影響が出たので、そのタイミングで敷設していたJenkinsの構成を改めて整理しました。今回は課題解決というより、既に稼働していたシステム構成の振り返りを行いました。   > PROBLEMPROBLEM \n\n- インフラ系タスクがコード管理されていないので属人化しやすい 可能なら当該タスクはインフラ担当から手離れして欲しい 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- 可能なら当該タスクはインフラ担当から手離れして欲しい\n- 当該タスクは通常のCIワークフローとは異なるので管理する場所がない そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- そういう意味でJenkinsの出番だけどこれはこれで管理が手間 ヘルスチェックエラーにひっかかったら自動で再起動してほしい \n- ヘルスチェックエラーにひっかかったら自動で再起動してほしい   > SOLUTIONSOLUTION \n\nというわけで、モダンなJenkins2系をAWS CDKで敷設してみました。   > 1. 構成1. 構成 \n\n大方の構成は「nabinno/jenkins-cdk-on-ec2」のシステム構成図をご覧下さい。元ネタはaws-sampleになりますが、今回はAWS FargateではなくAmazon ECSを採用し、CDKはTypeScriptで実装しています。 \n\n使用技術スタック \n\n- Jenkins\n- Amazon ECS（Amazon EC2）\n- Application Load Balancer\n- Amazon EFS    > 2. CDKによるJenkinsの敷設2. CDKによるJenkinsの敷設 \n\nCDKによるJenkinsの敷設はGitHubレポジトリーを見ていただくとして、ここではCDKのコード上の注意点を2点ほど共有しておきます。   > 2-a. CDKの注意点：リソース名を明示する2-a. CDKの注意点：リソース名を明示する \n\nCDKで各リソース名を明示しないとCloudFormation（CFn）独特の命名規則でリソースが敷設されます。インフラ担当が自分一人の場合は良いですが、インフラ担当を増員する際は、他のIaCツールの運用方針とバッティングする等、後で足かせになるので命名規則にのっとりリソース名を付けていくようにしましょう。 \n\n命名規則は「クラスメソッドさんの記事」を参考に決めるのが定番のようです。下記例になります。    AWSリソース 命名規則     ELB {sysname}-{env}-alb/clb   TargetGroup {sysname}-{env}-tg   EC2 {sysname}-{env}-{type}   SecurityGroup {sysname}-{env}-{type}-sg    \n\nCDKでリソース名を明示するには次のいずれかの方法で対応します。 \n\n- 各クラスのコンストラクトプロパティにある名前を記述する\n- 暗黙的生成されるリソースを明示的に作成する \n\n下記コードでは暗黙的に生成されていたSecurity Groupを明示的に作成している様子等が見て取れます。   ts \n\n// ECS: Service const serviceSecGrp = new ec2.SecurityGroup(this, \"JenkinsMasterServiceSecGrp\", { securityGroupName: \"jenkins-production-master-sg\", vpc: network.vpc, allowAllOutbound: true, }); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(50000), \"from JenkinsWorkerSecurityGroup 50000\"); serviceSecGrp.addIngressRule(worker.workerSecurityGroup, ec2.Port.tcp(8080), \"from JenkinsWorkerSecurityGroup 8080\"); const jenkinsMasterService = new ecs.Ec2Service(this, \"EC2MasterService\", { serviceName: 'jenkins-production-master-svc', taskDefinition: jenkinsMasterTask, cloudMapOptions: { name: \"master\", dnsRecordType: sd.DnsRecordType.A }, desiredCount: 1, minHealthyPercent: 0, maxHealthyPercent: 100, enableECSManagedTags: true, cluster: ecsCluster.cluster, securityGroups: [serviceSecGrp] });   \n\nなお、リソース名の明示化について、もちろんCDKのクラスによっては暗黙的なリソースを含んでおり当該リソースに名前を付けることが出来ないケースはあります。今回のケースで言うと、例えば、ECSクラスター（EC2）のIAM RoleやSecurity Group。その場合は、インフラのCDK運用方針としてドキュメントに残しておく等しておくと良いでしょう。   > 2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける2-b. CDKの注意点：cdk.RemovablePolicy.RETAINをつける \n\nネットワーク、ストレージ関連のリソースを扱う場合、削除されるとリソース構成が破綻する可能性があるのでcdk.RemovablePolicy.RETAIN、CFnの言うところの \"DeletionPolicy\": \"Retain\" をつけましょう。今回はEFSがその対象になります。   ts \n\nconst efsFilesystem = new efs.CfnFileSystem(this, \"EFSBackend\"); efsFilesystem.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);   \n\n個人的にはRETAINをつけるとcdk destroy cdk deployを気軽に行えなくなるので、RETAINをつけるならCDK/CFnからはARNで参照する程度に抑えた方が良いと思っています。   > 3. Jenkinsの設定を行う3. Jenkinsの設定を行う \n\nCDKでJenkinsを敷設した終わったらJenkinsの設定を行いましょう。   > 3-a. Jenkinsでつかっているプラグイン3-a. Jenkinsでつかっているプラグイン \n\n昔と違って今のJenkinsは下記プラグインがあれば十分運用できます。 \n\n- github-oauth\n- role-strategy\n- configuration-as-code\n- blueocean \n\nざっと説明するとgithub-oauthでGitHub認証させ、role-strategyでロールごとの権限付与を行い、configuration-as-codeでそれらの管理設定をコード化します。configuration-as-codeは素晴らしく設定情報をコード化することでdockerイメージに当該設定情報を反映させることが出来ます。また、blueoceanはモダンなインターフェイスでジョブ実行します。こちらは次のセクションで詳細を説明します。 \n\nなお、プラグイン管理はIaC化でき下記のようにdockerイメージに反映できます。   sh \n\n$ cat plugins.txt role-strategy:3.1 github-oauth:0.33 thinBackup:1.10 git:4.6.0 authorize-project:1.3.0 configuration-as-code:1.47 blueocean:1.24.4 $ cat Dockerfile [...] COPY plugins.txt /usr/share/jenkins/ref/plugins.txt RUN /usr/local/bin/install-plugins.sh < /usr/share/jenkins/ref/plugins.txt [...]     > 3-b. JenkinsジョブをGitHubで管理する3-b. JenkinsジョブをGitHubで管理する \n\nいよいよJenkinsでジョブの管理設定を行います。具体的には下記手順で実施します。手順が完了すると作ったブランチ分だけJenkinsにジョブが追加されます、とても簡単です。 \n\n1. ジョブを管理させたいGitHubレポジトリでジョブ管理用のブランチを作成し、Jenkinsfile を配置\n2. 「Jenkins - Blue Ocean - New Pipeline」にて下記設定をおこなう Where do you store your code? - GitHub Which organization does the repository belong to? - 任意のuserあるいはorganization Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n3. Where do you store your code? - GitHub\n4. Which organization does the repository belong to? - 任意のuserあるいはorganization\n5. Choose a repository - 任意のレポジトリ（1で作成したレポジトリ） \n\nJenkinsfile の作成方法は「ユーザーハンドブック」にありますが、下記例のように直感的に記述することが出来ます。環境変数は「Jenkins - {{レポジトリ}} - 認証情報 - Stores scoped to {{レポジトリ}} - global - Add credential」から追加します。   Jenkinsfile \n\n pipeline { agent any stages { stage('Show env') { steps { sh '''mysql --version ls -al bin env | sort''' } } stage('Run script') { steps { git(url: 'https://github.com/nabinno/jenkins-jobs', branch: 'master', credentialsId: 'github') sh '''git diff sync-db-from-staging-to-integration | patch -p1 -R -f bin/sync_db_from_staging_to_integration''' } } } environment { STAG_DB_DATABASE = credentials('STAG_DB_DATABASE') STAG_DB_HOSTNAME = credentials('STAG_DB_HOSTNAME') STAG_DB_PASSWORD = credentials('STAG_DB_PASSWORD') STAG_DB_USERNAME = credentials('STAG_DB_USERNAME') INTEG_DB_HOSTNAME = credentials('INTEG_DB_HOSTNAME') INTEG_DB_PASSWORD = credentials('INTEG_DB_PASSWORD') INTEG_DB_USERNAME = credentials('INTEG_DB_USERNAME') INTEG_DB_DATABASE = credentials('INTEG_DB_USERNAME') } }     > WRAPUPWRAPUP \n\n今回の振り返りで、2点気づきを得られました。CDKのリソース名の扱いに困っていたのですが、どうにか制御できそうなのでまたしばらくは付き合っていくことになりそうです。 \n\n1. CDKは意外とかゆいところに手が届く。ただ、暗黙的に生成され、CDK側で制御できないリソース名があるので、そういう前提で運用ポリシーを作ると各IaC使いの平穏に繋がる。\n2. Jenkins2は思った以上に手離れが良い。CDK、ECS、EFS、configuration-as-code、Jenkinsfileの組み合わせは保守性、可用性に大きな貢献をしている。"},"name":"CDKで管理する今どきのJenkins","tags":["aws-cdk","jenkins","amazon-ecs"],"childPublishedDate":{"published_on":"2021-02-24T02:04:50.000Z","published_on_unix":1614132290}}},{"node":{"number":68,"relative_category":"blog/organization","fields":{"title":"飲み会に参加するための機材","excerpt":"以前チーム内でリモート懇親会を画策したのですが、食材の調達や経費精算など手間が多すぎて断念しました。ただ、その言い訳は実は本質的ではなく、実際に後ろ向きにさせていたのは「しゃべりながら食べるのがつらい」ということにありました。今回はそれを解決した機材を紹介します。   > PROBLEMPROBLEM \n\n- リモート飲みがつらい 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい 音声が悪すぎて相手にメッセージが伝わらない 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 何がつらいって、ヘッドホンをしながら飯を食べるのがつらい 有線ヘッドホンだとPCの前に張り付きになりつらい 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい \n- 有線ヘッドホンだとPCの前に張り付きになりつらい\n- 無線ヘッドホンだと音声が悪すぎて相手のメッセージが聞き取りづらい\n- というか、有線だろうが無線だろうが直接PCにつなげると少量のノイズが乗る場合がありつらい\n- 音声が悪すぎて相手にメッセージが伝わらない\n- 「えっ、今なんて言ったの?」という会話を何度も繰り返す様がいたたまれない\n- 自分の顔を相手に見せつけるのが気持ち的にいたたまれない アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- アバターはPCリソースを消費する上、アバターに気を使うのは飲み会の意義から少しずれている 最初は楽しいがすぐ飽きる \n- 最初は楽しいがすぐ飽きる   > SOLUTIONSOLUTION \n\nというわけで、自分がこの1年試行錯誤した末に辿り着いた飲み会参加の機材スタックを共有します。   > オーディオインターフェイスオーディオインターフェイス \n\nオーディオインターフェイスはマイクやギターの音をパソコンに取り込むアナログ・デジタル変換と、取り込んだ音を再生するデジタル・アナログ変換の機能を提供します。 \n\nボイスメモ程度なら必要ないですが、フルリモートで頻繁に会議をしている機会が多いと音質とレイテンシーに多分な影響を与えます。オーディオインターフェイスがない場合、入力時にノイズが乗ったり、出力時に音質が劣化します。また、レイテンシーがひどくなったり音がゆがんだり、下手をするとPCに負荷がかかりフリーズします... \n\n会議を頻繁にする人はとりあえず手に入れたい機材。Steinberg UR22Cが人気です。 \n\n- Steinberg UR22C   > マイクマイク \n\n演説やスピーチ用にダイナミックマイクが使われていますが、オンラインミーティングで使う場合は聞き取りづらいので、何はともあれコンデンサーマイクを使うべきです。 \n\nコンデンサーマイクと言っても、いろいろあります。特にマイクの振動板（ダイアフラム）が大型か小型かで音質の印象が変わるので注意が必要です。私は下記の表のように利用シーンごとに使い分けています。    - 説明 利用シーン     スモールダイアフラム 現実主義。色のない、ニュートラルな音色を提供 ファシリテート   ラージダイアフラム 浪漫主義。音源をより大きく、愛らしいものに変換 発表、音楽活動    \n\nなお、HHKB等の打鍵音が大きいキーボードを利用している方や仕事スペースと家庭スペースとの距離が近い方は、いずれにしてもスモールダイアフラムがお薦めです。スモールダイアフラムはマイクから口元を少しでもずらすと音が入力されずらくなくなるため、期待した音質を提供することが出来ます。 \n\n製品としてはShure Beta87Aが人気です。また、購入する際はマイクスタンドとマイクスポンジもセットで検討すると良いです。マイクの位置を固定し風よけを設置した方が安定した音質に繋がります。 \n\n- Shure Beta87A   > ヘッドホンヘッドホン \n\n食事を取りながら相手の話を聞くには通常のヘッドホンだと食べ物を咀嚼するのに苦労します。口を開けたり閉めたりする際、顎とともにヘッドホンが上下に動くため相手の声が聞き取りづらくなります。 \n\n耳の穴に接しない骨伝導ヘッドホンは、食べ物を咀嚼する際の顎の動きに左右されることがないです。テレワークのヘッドホン多用が外耳炎を引き起こしているという話もあるので、そういう意味で骨伝導ヘッドホンは健康を保つ上でも重要な機材となります。 \n\nまた、使用していて分かったのですが、普段の食事の中でも使うことが出来るので、隙間時間に気軽にメディアに接しやすくなります。例えば、家族と一緒の部屋にいる中、食事を取りながらAWSのWebinarを聞くことができます。 \n\n製品としては業界を牽引しているAfterShokzのAeropexが人気です。今回はオーディオインターフェイスを利用しているので、音質をさらに高めるためにトランスリミッターと組み合わせましょう。 \n\n- AfterShokz Aeropex\n- トランスリミッター TaoTronics aptX-LL   > ビデオビデオ \n\nソーシャルメディアでよく登場するビデオ画像は、表情アップの図（ず）が前面に押し出された絵が一般的ですが、地（じ）の表現が薄く解釈余地がないものが多いです。表情が豊かな方は良いのですが、全員がそういうわけではないので地（じ）の生活の部分に焦点を当てた方が実態に合っています。 \n\n例えば、対面での会話の中では身につけている服装や持ち物等のアトリビュートに焦点が当たりますよね。「その身につけているアクセサリーは何?」「机の上に置いてあるその本、面白そうだね」という会話を思い出してください。 \n\nそういう意味で広角レンズを搭載したアクションカムは望ましい選択です。今時のアクションカムは高解像で鮮やかに表現してくれますし、外にいなくても部屋の中で十分面白い絵になります。 \n\nアクションカムは何でも良いのですが、私は普段「撮れラン」で使っているSony HDR-AS3000をミーティングの際に使っています。 \n\n- Sony HDR-AS3000   > WRAPUPWRAPUP \n\n今回紹介した機材に出会うまで紆余曲折ありましたが、揃えてみて満足しています。 \n\n飲み会でなくても良いですが、機材を揃えた方でいろいろ試してみたい方は一緒に雑談してみませんか。30分雑談会というのを開催しているので、いつでもお気軽にお声がけください。"},"name":"飲み会に参加するための機材","tags":["drinkup","team-building"],"childPublishedDate":{"published_on":"2021-01-30T03:02:00.000Z","published_on_unix":1611975720}}}]}},"pageContext":{"number":58}},"staticQueryHashes":[]}